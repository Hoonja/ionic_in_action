3. AngularJS에 대해 알아야 할 것들

<< 글상자 시작 >>
	이 장에서 다룰 내용
	*	AngularJS 앱을 만드는 방법과 구조
	*	아이오닉을 강력하게 만드는 AngularJS의 기본 지식
	*	컨트롤러, 필터, 디렉티브, 스코프 등을 사용하는 방법
<< 글상자 끝 >>

AngularJS는 웹 어플리케이션 프레임워크로, 오늘날에는 가장 많이 사용되는 자바스크립트 도구 중 하나가 될 정도로 인기를 얻고 있다. 아이오닉은 AngularJS를 기반으로 만들어져 있기 때문에, 이것의 작동 방식을 이해하는 것은 굉장히 중요하다. 아이오닉을 위한 웹 어플리케이션 프레임웍을 통째로 새로 만드는 대신, AngularJS를 사용하여 수 많은 인터페이스 컴포넌트와 모바일 친화적인 기능들을 확장시켰다.
	이번 장에서는 AngularJS가 무엇인지, 효과적으로 이용하기 위해 알아야 할 기본기에 관한 핵심적인 내용들을 다루려고 한다. 이미 AngularJS에 익숙한 당신이라면 이번 장은 건너뛰고 계속 나가면 되겠다. 요컨대, 이 장은 AngularJS를 처음 접하거나, 살짝만 경험한 나머지 적당한 입문서가 필요한 이들을 위한 것이다.
	데이터를 제어하기 위한 목적으로 설계된, (그리하여 이름까지 적절하게 명명된)컨트롤러에 대해서 살펴볼 것이다. 그 다음 스코프가 무엇인지, 이것이 어떻게 컨트롤러와 뷰라고 불리는 유저 인터페이스 사이에서 아교 역할을 하는지 논의한다. 또한 뷰를 깊숙히 들여다 보면서, 이것이 어떻게 템플릿과 스코프를 이용하여 상호작용하는지 이해할 것이다. 계속해서 데이터를 변형하기 위한 필터의 사용법, HTML 엘리먼트의 기능을 향상시키는 디렉티브를 만들고 쓰는 법, 외부에 존재하는 데이터 소스를 로드하거나 저장하는 방법과 같은 몇 가지 다른 주제들도 다룰 것이다.
	이번 장에서는 그림 3.1과 같은 기초적인 웹 어플리케이션을 만들어 보면서 AngularJS에 대해 설명할 것이다. 예제를 만들어 보면서 해도 되고, 깃허브 https://github.com/ionic-in-action/chapter3에 있는 완성된 예제를 봐도 된다. 최종 결과물은 https://ionic-in-action-chapter3.herokuapp.com/ 에서도 확인할 수 있다.
그림 3.1 이번 장의 어플리케이션은 노트 목록과 노트를 조회하고 편집할 수 있는 기능이 있다.
이 장을 마치게 되면 AngularJS가 작동하는 방식에 대해 대강의 이해를 하게 될 것이다. AngularJS가 제공하는 모든 기능을 제대로 다루려면 분량이 너무 많아진다. 다른 책이나 자료를 통해 AngularJS를 깊이 배우도록 하고, 우리는 이 책에서 활용되는 주요 기능만 다룰 것이다.
	코드로 바로 들어가기 전에 AngularJS의 전반적인 내용과 AngularJS가 해결해주는 웹어플리케이션 개발시 직면하는 문제들에 대해 잠깐 이야기를 해보자.
3.1. 한눈에 보는AngularJS
	AngularJS로 어플리케이션을 작성하기 전에 AngularJS로 개발된 어플리케이션의 대표적인 구조를 이루는 부분들을 알아보자. 콘텐츠를 표시하기 위한 뷰와 템플릿부터 시작해서, 컨트롤러가 데이터를 어떻게 불러와서 뷰에 전달하는지 살펴보자. 그림 3.2는 이들이 어플리케이션 안에서 노트 목록을 만드는 방식과 연결 관계를 보여준다.
1.	컨트롤러는 노트 목록을 불러와 스코프에 저장한다.
2.	뷰는 템플릿을 로드한다.
3.	뷰는 스코프를 이용하여 템플릿을 그려, 노트 목록을 표시한다.
4.	목록 내의 노트를 클릭하면 컨트롤러를 호출한다.

그림 3.2 노트 목록을 그리기 위해 컨트롤러에서 로딩된 데이터가 뷰를 통해 표시되는 과정

3.1.1. 뷰와 템플릿: 콘텐츠를 표현하기
	AngularJS는 HTML과 매우 긴밀하게 협력하는데, 여러분도 종종 템플릿을 만들어야 할 일이 발생할 것이다. 템플릿은 필요할 때 어플리케이션으로 로드되는 HTML 블럭이다. AngularJS는 새로운 기능과 확장 능력으로 HTML을 향상시킨다.
	뷰는 템플릿을 사용하여 데이터를 표시한다. 뷰는 항상 템플릿과 사용될 데이터를 가지고 있다. 이 데이터를 근거로 사용자에게 결과를 표시하기 위해 템플릿을 변형시킨다. 다음은 그림 3.2의 예제에서 사용되는 짧은 템플릿 코드이다.
ngClass는 조건에 따라 클래스를 적용시킬 수 있도록 한다.
ngRepeat는 노트 배열내의 각 노트에 대해 <li>를 생성시킨다.
ngClick은 <li>를 클릭했을 때 displayNote() 메서드를 호출한다.
날짜 정보를 ‘짧은 날짜 표시 형식’으로 필터링하여 표시한다.
	이 간단한 템플릿은 <ul> 내부에 <li> 요소가 하나 있는데, Angular 디렉티브라고 하는 몇 가지 어트리뷰트를 가지고 있다. 디렉티브는 그것이 위치한 요소의 동작을 변경시킨다. 위의 경우 ngRepeat는 자바스크립트 객체나 배열을 순회하면서, 각각에 대해 <li>를 생성시킨다. ngClick은 자바스크립트의 onClick 이벤트 핸들러와 유사한 것으로, 클릭시 displayNote()를 호출한다. 템플릿 렌더링이 완료되면, notes 배열의 각 노트에 대한 리스트 아이템이 생성된다.
	중첩된 중괄호({{ }})는 어떤 데이터가 이곳에 표시되어야 함을 나타낸다. 이 개념이 데이터 바인딩이라고 불리는 것으로, 이 때 사용하는 문법을 표현식(expression)이라고 한다. 중괄호 안의 어떤 표현이던 표현식이 되는데, AngularJS가 현재의 모델 데이터를 가지고 처리를 하는 부분이다. 따라서 note.title의 실제 내용이 <li> 요소안에 중첩된 중괄호가 감싸고 있는 부분에 삽입된다.
	템플릿은 추가된 디렉티브나 표현식이 첨부된 HTML이다. 뷰는 데이터를 가져와 이를 기반으로 템플릿에 적용, 최종 결과물을 표시한다 notes가 5개의 노트를 가지고 있다고 한다면, <ul> 요소는 5개의 리스트 아이템 요소를 포함하게 된다(그림 3.2에서 볼 수 있는 스크린샷 참고).
	AngularJS는 많은 디렉티브를 가지고 있는데 모두 ng라는 접두어로 시작된다. 어떤 것은 표시 방식을 변경시키기 위한 것이고(ngShow, ngClass), 또 어떤 것들은 폼을 위한 것이며(ngModel, ngForm), 클릭과 같은 이벤트를 처리하기에 유용한 것들도 있다(ngClick, ngMouseover). AngularJS의 어떤 디렉티브들은 <input>이나 <textarea>, <a>와 같은 원래의 HTML 요소를 대체하여 본래에 없던 추가 기능을 제공한다. 예를 들어, AngularJS는 커스텀 유효성 체크를 할 수 있는 추가적인 어트리뷰트를 추가함으로써 <input type=”text”>의 기능을 개선시킬 수 있다. 이후에 예제를 통해 더 많은 디렉티브를 사용할 것이나, 전체 목록은 AngularJS 공식 문서에서 확인할 수 있다.
ngApp과 ng-app은 무엇이 다른가?
AngularJS에 관한 글을 보다 보면, ngApp이나 ng-app으로 일컫는 디렉티브를 보게될 때가 있다. 사실, 그들은 서로 같은 것에 대해서 이야기하고 있는데, 두 가지가 모두 있는데에는 이유가 있다.
ngApp이나 ngClass는 자바스크립트 버전에서 부르는 이름이다. 자바스크립트 문법은 변수 이름에 하이픈(‘-‘)을 쓰는 것을 허용하지 않는다. 그래서 대신 사용하는 코드 작성 규칙으로 카멜 케이스(역주:소문자로 시작하되, 구별되는 단어의 시작은 대문자로 표기하는 방식) 방식을 채택했다. 공식 문서는 이 스타일을 쓰고 있고, 이 책에서도 그러하다.
ng-app이나 ng-class는 HTML 버전의 이름이다. HTML은 대소문자 구분이 없고, 태그명이나 어트리뷰트 이름에 하이픈을 쓰는 것을 허용한다. 하이픈을 쓰면 마크업 내 디렉티브 이름의 가시성이 올라간다.
이제 데이터가 뷰에 어떻게 연결되어 표시되는지 알아보자.
3.1.2. 컨트롤러, 모델, 스코프: 데이터와 로직 관리하기
	컨트롤러는 DOM 노드에 부착되는 함수로 어플리케이션의 논리를 구성하는데 사용된다. 컨트롤러는 스코프와 이벤트 응답 사이에 전달될 수 있는 자바스크립트 함수 오브젝트이어야 한다.
	스코프는 컨트롤러와 뷰사이에 공유되는 일종의 문맥(컨텍스트)이다. 컨트롤러와 인터페이스 사이에 발생되는 일을 공유하는 연결이라고 생각하면 되는데, 컨트롤러에서 스코프가 갱신 될 때, 뷰에서도 역시 갱신이 된다. 그림 3.2에서 이런 상호 작용을 설명하는 부분이 있는데, 화살표가 뷰와 컨트롤러가 스코프를 중심으로 통신하고 있음을 알려주는 부분이다.
	스코프는 두 가지 핵심 역할을 가지고 있다. 데이터를 저장하는 것과 컨트롤러 메서드로의 접근을 제공하는 것이다. 스코프에 저장되어 있는 데이터를 모델이라고 한다. 모델은 어떤 자바스크립트 값이던 사용될 수 있으며(배열이나 오브젝트가 일반적이지만, 숫자나 문자열 같은 단순 데이터도 가능하다), 스코프를 통해 컨트롤러와 뷰 사이에 공유된다.
	앞서 보여준 뷰와 템플릿에 연결된 컨트롤러 예를 보자.
(코드 있는 부분 제외하고 위로부터 차례로..)
1.	컨트롤러를 정의하고, 스코프에 접근하기 위해 $scope 서비스를 사용한다.
2.	노트 모델을 위한 노트 오브젝트 배열을 생성한다. 뷰의 ngRepeat를 통해 표시될 것이다.
3.	콘텐츠 값을 갱신할 메서드를 추가한다. 뷰의 ngClick 디렉티브에 의해 호출된다.
이 컨트롤러는 notes 모델을 배열로 정의해서 $scope로 불리는 특수 객체에 할당한다. 이 객체는 여러분이 컨트롤러와 뷰 사이에 공유될 데이터를 저장할 스코프를 위해 AngularJS가 제공하는 것이다. 뷰는 <li>내의 ngRepeat를 이용하여 노트 배열을 표시한다. getNote() 메서드는 무슨 노트를 content 모델에 저장해야 할지 지정할 수 있도록 선언되었다. 스코프에 등록되었으므로 뷰는 이 함수를 호출할 수 있다.
	컨트롤러내의 모든 것은 자식 스코프를 제외한, 어플리케이션의 나머지 부분으로 부터 격리되어 있다. 코드와 변수의 유효 범위가 이로 인해 제한되기 때문에 이것은 중요하다. AngularJS를 처음 접하는 개발자들의 공통된 시도가 어떤 값을 다른 스코프로 저장하거나 다른 스코프의 값에 접근하려고 하면서 어려움을 겪는 것인데, 기본적으로 이것은 가능한 방법이 아니다.
	AngularJS의 스코프는 상속 구조를 가진다. 스코프는 DOM처럼 포함구조가 될 수도 있다. 사실 스코프는 페이지의 DOM 구조를 그대로 반영한다. DOM 노드에 스코프가 첨부되어, 특정 HTML 엘리먼트와 그 자식에서만 볼 수 있다. 마치 CSS 클래스가 그것이 적용된 특정 엘리먼트나 자식들에게만 적용되는 것과 비슷하다.
	상속 구조는 스코프들 사이에 통신을 하려고 할 때 특히 더 중요한데, 자식 스코프는 부모만 바라볼 수 있다(자바스크립트의 프로토타입 상속 구조 개념에 익숙하다면, 유사하게 이해할 수 있다). AngularJS의 어떤 디렉티브들은 자식 스코프를 생성하기도 하는데, 이 때문에 어떤 스코프가 어디에 있는지 헷갈릴 수가 있다. 만약에 자식 스코프의 어떤 값을 찾는 중인데 존재하지 않는다면, 그 값이 찾아질 때가지 부모 스코프들을 따라올라가야 할 것이다.
	루트 스코프(특별히 $rootScope로 정의되어 접근할 수 있는 객체)는 AngularJS 어플리케이션에서 생성되는 첫번째 스코프로서, 모든 다른 스코프들의 부모가 된다. 이 말인 즉슨, 루트 스코프에 저장된 것은 무엇이던 간에 다른 스코프에서도 유효하다는 뜻이다. 여러분은 스코프들을 깔끔하게 관리하고 루트 스코프에 뭐든지 쑤셔 넣는 것은 피하고 싶을 것이다. 근본적으로 자바스크립트는 이런 유형의 문제를 내포하고 있는데, 종종 어떤 어플리케이션들은 글로벌 스코프를 변수를 저장할 용도로 쓰기도 한다. id라고 부르는 값이 있다고 치자. 다른 스코프에 별도의 id라는 값을 저장했다면, 이 순간 그 자식 스코프에서는 충돌이 일어나고 루트의 값에는 접근할 수 없게 된다. 더 많은 코드를 작성할수록, 같은 어플리케이션을 개발하는 사람들이 많아지거나 외부의 툴을 점점 더 도입할수록 이런 종류의 이름 충돌 문제를 인지하고 피하기가 어려워진다.
컨트롤러 내에서 뭐든지 해도 되는 것은 아니다.
코드를 유지하고 테스트하기 쉽도록 하기 위해 컨트롤러에 하지 말아야 할 행동들이 몇 가지 있다. 특히 컨트롤러에서 DOM 조작을 하는 것이다. 슬라이드 쇼 기능을 개발하고 있는 상황을 가정해 보자. 컨트롤러는 DOM을 변경하거나 스타일을 조정하는 종류의 작업을 하면 안되는데, 왜냐하면 이런 조작은 커스텀 디렉티브 내에 위치시키는 것이 최선이기 때문이다.
데이터 포맷을 조작하거나 필터링 하는 것도 컨트롤러에서는 피해야 할 일이다. 대신 폼 컨트롤이나 필터를 사용한다.

3.1.3.	서비스: 재사용 가능한 오브젝트와 메서드
AngularJS에는 어플리케이션 전체에 공유되는 자바스크립트 오브젝트인 서비스라는 개념이 있다. 기본적으로 몇 가지 서비스를 제공하고 있고, 여러분만의 서비스를 제작할 수도 있다. AngularJS를 잠시 써보게 된다면, 몇 가지 빌트-인 서비스를 아마 사용하게 될 것이다.
가장 일반적인 서비스 중에 $http가 있는데, 이는 HTTP 요청을 처리하는 AngularJS 서비스이다. get(), post(), 그리고 다른 HTTP 액션을 위한 메서드들이 있다. 서비스는 $http처럼 복잡한 것도 있지만, 단순한 데이터 객체들도 될 수 있다. 이 책에서는 어플리케이션 내 여러 파트들 간 데이터 공유를 위해 사용되는 간단한 서비스 예제를 볼 것이다.
서비스는 늦은 로딩 방식으로 동작하는데, 실제 사용되는 시점까지는 메모리에 올라오지 않는다는 뜻이다. 이들은 또한 싱글턴으로, 한 부분에서 서비스의 값을 수정하면, 다른 부분에도 반영된다. 5, 6장의 예제에서 이런 동작을 보게 될 것이다.
아이오닉은 AngularJS 서비스의 여러 특징을 노출한다. 이 후의 여러 장에서 다를 것인데, 컨트롤러에 포함시키는 것은 서비스라는 점만 계속 유념하길 바란다.
3.1.4.	양방향 데이터 바인딩: 컨트롤로와 뷰의 데이터 공유
AngularJS의 가장 강력한 특징은 양방향 데이터 바인딩이다. 뷰에서 템플릿의 데이터를 어떻게 바인딩 시키는지는 살펴 보았는데, 그 반대 방향으로의 동작도 작동한다. 뷰는 스코프의 값을 변경시킬 수 있고, 이 때 컨트롤러에도 즉시 반영된다. 이것은 폼 사용시 특히 도움이 되는데, 사용자가 텍스트 인풋(<input type=”text>)에서 타이필을 하면 스코프의 값이 즉시 변경된다. 양방향 데이터 바인딩을 위해 특별히 해야할 일은 없고, 자동으로 일어난다.
이 책의 어플리케이션에서는, 여러분이 편집기를 작성할 때 양방향 데이터 바인딩을 보게 될 것이다. 에디터 박스에 입력을 하면, 그 내용이 오른편 미리보기에 나타날 것이다.
이제 시작하기 위해 필요한 기본 배경 지식으로써의 AngularJS 핵심 개념은 대강 요약했다. 이 개념들이 이번 장 프로젝트에서 실제로 동작하는 것을 살펴보자.
3.2.	이번 장 프로젝트를 위한 설정
이 장에서는 기본 HTML 페이지로부터 AngularJS 앱을 개발할 것이다. 기본적인 디자인과 마크업 작업은 필자가 이미 해두었기 때문에, AngularJS 제작에 관련된 특징에만 집중할 수 있다.
이 어플리케이션은 간단한 노트 저장 어플리케이션으로, 노트 목록을 불러오고 변경할 수 있다. 앱이 갖고 있는 특징들을 살펴보자면,
λ	JSON 파일로 노트 저장
λ	노트 조회, 생성, 수정과 삭제 기능
λ	노트에 markdown 형식 사용하기
λ	markdown을 편집과 미리보기 창에서 나란히 보기
본 예제는 필요한 기본 HTML과 CSS가 설정되어 있다. 또한 노트의 목록을 관리하기 위해 노드(node.js)로 작성된 RESTful 서버를 포함하고 있다. 우리는 이를 기반으로 AngularJS를 추가하기 위한 방법, AngularJS의 주요 특징을 다루는데에 집중한다.
3.2.1. 프로젝트 파일 얻기
	이번 장을 읽으면서, 깃의 태그로 특정 버전의 코드를 체크 아웃할 수 있게 될 것이다. 물론, 이 책 예제를 직접 작성해서 따라갈 수도 있다. 깃에 익숙하지 않다면, 뒤에 나오는 명령줄을 실행하거나 기반 파일과 코드를 다운로드 하는 2차 해법을 적용해도 된다.
	깃을 사용한다면, 3장의 저장소를 복제하고, step1 태그를 체크아웃 한 후, 이를 기반으로 시작할 수 있다.
$ git clone https://github.com/ionic-in-action/chapter3.git
$ cd chapter3
$ git checkout step1
	깃을 사용하고 싶지 않다면, 기반 파일을 https://github.com/ionic-in-action/chapter3/archive/step1.zip
에서 다운로드하여 압축을 풀어 기반 파일로 사용할 수 있다(그림 3.3)
	이후 단계들에 대해서도 같은 방식을 적용할 수 있다. 즉, step1 태그의 숫자를 바꿔가면서 코드를 체크하웃 하면 된다.
그림 3.3 예제 어플리케이션을 위한 기본 HTML 템플릿. 현재는 상호작용이 없음.

3.2.2. 개발 서버 작동 시키기
	이제 여러분의 컴퓨터로 프로젝트 파일을 다운로드 했으니, 개발 서버를 설정해야 겠다. 웹 어플리케이션이 올바로 작동하기 위해서, 실제의 제품 환경과 유사하게 동작하는 서버가 필요하다. 이 서버에 대해서 상세하게 파고 싶지는 않지만, 개발 서버로 노드를 사용해 보지 않은 독자들은 몇 가지는 알아야 한다.
	프로젝트 내의 Server.js 파일은 Express.js 프레임워크에 기반한 간단RESTful 서버이다. 기본 기능은 시간의 흐름에 따른 노트의 변경을 주시하고, 어플리케이션이 목록의 노트를 읽고, 만들고, 편집하고, 삭제할 수 있도록 RESTful API를 제공하는 것이다. 서버는 HTTP 통신을 통해 브라우저로 파일을 로딩할 수 있도록 하는데, 아이오닉 앱에서 ionic serve 커맨드가 하는 것과 유사하다.
	서버에는 몇 가지 주석을 달아두었는데, 흥미가 있다면 좀 더 깊이 살펴도 좋겠다. 여기서는 상세 내용을 다루지 않겠지만, 다음의 몇 가지를 알아두는 것은 중요하다:
λ	서버는 3000번 포트를 사용한다. 즉, http://localhost:3000으로 접속해 어플리케이션을 확인할 수 있다.
λ	서버는 요청을 받아 처리하는데, URL과 HTTP 메서드에 따라 노트의 목록을 수정할 것이다.
λ	단순화를 위해 파일 보전을 위한 데이터베이스로 JSON 파일(data/notes.json)을 사용한다. 실제 환경에서는 좀 더 견고한 데이터베이스 솔루션을 사용해야 한다.
	필요한 노드 패키지를 다운로드 할 때까지 서버는 실행되지 않을 것이다. 필요한 파일 설치를 위해서는 노드 패키지 관리자(Node Package Manager: npm)를 사용하는 다음 명령어를 실행하는 것이 쉬운 방법이다. 터미널에서 설치하려는 폴더로 이동해서 다음을 실행한다.
$ npm install
	몇 분 걸릴텐데, npm이 관련된(package.json을 통해 얻은 정보) 모듈 목록을 찾고 GitHub로부터 다운로드를 수행한다. 다운로드 과정은 로그가 남고 완료되었을 때 알려준다.
이제 서버를 실행할 수 있다. 실행을 유지하려면 커맨드 창을 유지시켜야 한다. 서버가 시작되고 3000번 포트에서 응답을 기다릴 것이다. 서버를 멈추고 싶으면 언제든지 Ctrl+S나 터미널 창을 닫는다.
$ node server
	이때부터 브라우저에서 http://localhost:3000으로 접속할 수 있으며, 앞서 그림 3.3과 같은 기본 템플릿 레이아웃을 볼 수 있다. 계속해서 HTML을 수정하고 자바스크립트를 삽입하여 노트 저장 어플리케이션으로 만들 것이다.
그림 3.4 AngularJS가 페이지에 추가되어도 여전히 같아 보인다. 콘텐츠를 수정하기 전에 AngularJS에게 몇 가지를 알려줘야 한다.

3.3. Angular 앱의 기본
	AngularJS 시작의 기본은 자바스크립트 파일에서 AngularJS 어플리케이션을 생성하고 HTML을 참조하도록 하는 것이다. AngularJS는 DOM과 밀접하게 동작하기 때문에, 연결된DOM 엘리먼트와 그 자식들로 범위를 제한시킬 수 있다. 이번 사례에서는 <html> 엘리먼트에 연결할 것인데, 따라서 페이지 전체에 AngularJS가 접근하게 된다. 아이오닉은 종종 <body> 엘리먼트를 사용한다. 그림 3.4는 이전과 같은 브라우저 콘텐츠를 보여주고 있는데, 곧 AngularJS가 설치되고 사용할 준비가 될 것이다.
	다음의 명령줄 실행으로 GitHub로부터 저장소를 복제했다면, 현재 단계의 코드를 얻을 수 있다.
$ git checkout -f step2
실행하면 여러분이 가한 변경 사항은 모두 초기화 되고, step2 태그를 가지는 코드로 대체된다.
	AngularJS 어플리케이션을 만들려면, 요소에 ngApp 디렉티브를 추가하고 어플리케이션 이름을 선언한다. Index.html 파일을 열고 ngApp 디렉티브를 다음과 같이 추가해보자:
<html lang="en" ng-app="App">
이제 App이라는 이름의 AngularJS 어플리케이션을 HTML의 루트 엘리먼트와 연결했다. 이렇게 함으로써 AngularJS 앱은 DOM 전체에 액세스 할 수 있게 되는데, </body> 태그에 삽입할 수도 있다. 필자는 <html>이나 <body>에 위치시키는 것을 추천한다.
	아직 자바스크립트에서 앱을 선언하지 않았으니 이제 해보자. AngularJS는 모듈 시스템을 갖고 있는데, 캡슐화된 프로그램 코드가 독립된 조각이 되도록 지원하는 메커니즘이다. 새로운 모듈을 선언할 때, 앱의 이름과 의존하는 모듈(이번 장은 없다)의 목록을 배열로 제공해야 한다. 아이오닉은 그 자체로 AngularJS 모듈로서, 다른 장들에서 의존 관계를 선언할 것이다. AngularJS 모듈은 다음과 같은 방법으로 선언된다. Js/app.js 경로로 파일을 만들고 다음 줄을 추가하자.
angular.module('App', []);
마지막으로 <script> 태그를 index.html 파일에 추가하여 AngularJS 모듈을 불러온다. index.html 파일에서 </body> 태그 바로 앞에 다음의 태그를 추가하자:
<script src="js/app.js"></script>
이 문장은 AngularJS 라이브러리를 불러오는 부분 뒤에 위치해야 하는데, 자바스크립트는 페이지에서 선언된 순서대로 로드와 실행을 하기 때문이다.
	AngularJS를 선언하고 페이지에 어플리케이션을 연결하는데까지는 완료했다. angular.module() 메서드는 모듈을 생성하고 ngApp으로 DOM에 연결한다. 이것이AngularJS 어플리케이션의 가장 기본이지만, 사실은 아직 아무것도 수행되는 것은 없다. 모든 AngularJS 앱은 이런 식으로 선언된다.
3.4. 컨트롤러: 데이터와 비즈니스 로직 제어하기
	어플리케이션에 비즈니스 로직을 넣어 보자. 어플리케이션의 여러 부분을 제어할 비즈니스 로직을 관리하는 컨트롤러를 추가해 볼 것이다. 이번 단계는 아직 브라우저에서 보이는 어플리케이션의 모습을 바꾸지는 못한다. 컨트롤러는 데이터만 관리할 뿐이지 가시적인 부분은 고려대상이 아니기 때문이다. 그러나, 앞으로 엘리먼트의 표현을 관리하려면, 컨트롤러가 필요하다.
	컨트롤러를 추가하면 페이지 내에 접근할 수 있는 특정 영역이 컨트롤러에 주어진다(그림 3.5). 예를 들어, 데이터를 불러오고 스코프에 할당하는 것을 관리할 수 있어야 한다. Git을 사용한다면, step3 태그로 체크아웃하자.
$ git checkout -f step3
목록 3.1은 기본 컨트롤러를 선언한다. 먼저 App 모듈을 참고하고 컨트롤러 메서드를 가지는 컨트롤러를 선언한다. 컨트롤러 이름과 비즈니스 로직을 포함하는 함수를 전달한다. Js/editor.js 파일을 생성하고, 다음 목록의 코드를 추가한다.
리스트 3.1 에디터 컨트롤러(js/editor.js)
1.	[왼쪽] 모델 값을 생성하고 $scope에 저장
2.	[오른쪽 위] App 모듈 참조를 얻어, 여기에 컨트롤러를 등록
3.	[오른쪽 아래] EditorController라는 이름과 서비스에 의존하는 함수를 넘겨 컨트롤러를 생성
이것은 매우 단순한 컨트롤러인데, 지금은 state라는 간단한 모델을 만들기만 한다. $scope 서비스가 주입되어 state 속성을 저장할 수 있다. $scope에 있는 값을 모델이라 부르고, 뷰를 위한 것임을 기억하자.
$로 시작하는 서비스들
AngularJS의 서비스들은 $ 부호로 시작하는 것을 볼텐데, 이는 아이오닉 서비스에 대해서도 같다. $로 시작하는 서비스를 본다면, AngularJS나 아이오닉 코어 서비스임을 뜻한다.
이 책에서 예제로 우리가 만드는 서비스들에 이런 접두어를 붙이지 않는다. 대신에 대문자로 시작한다. 서비스 이름을 만드는 방법에 대한 제약은 없으나, 코어 서비스는 $ 접두어 규칙을 따른다.
이제 index.html 파일에 방금 생성한 파일을 추가하여 어플리케이션에 포함시키자. </body> 태그 앞에 다음의 <script> 태그를 추가하자.
<script src="js/editor.js"></script>
마지막 단계는 컨트롤러를 DOM에 결합시키는 것이다. 이렇게 하면, 컨트롤러가 사용할 자식 스코프가 신규로 생성된다. 방법은 AngularJS 디렉티브를 어트리뷰트로 추가하여, 컨트롤러가 부착될 엘리먼트를 선언하는 것이다. 이번 경우에는 index.html 파일의 25번째 줄에 있는 container 클래스를 가지는 div에 붙인다:
<div class="container" ng-controller="EditorController">
ngController 디렉티브를 사용했고, 자바스크립트 파일에서 생성한 컨트롤러의 이름을 선언했다. DOM에 컨트롤러를 연결함으로써 컨트롤러가 이 엘리먼트 내의 무엇이든 제어할 수 있게 되었다. 그림 3.5에서 컨트롤러의 스코프가 유효한 부분을 볼수 있는데, 상단 타이틀 바를 제외한 대부분의 영역이다.
[그림에 앞선 설명부분] 컨트롤러의 스코프는 점선 안쪽의 모든 영역으로 제한된다.
그림 3.5 컨트롤러의 스코프는 점선 안쪽의 마크업만 대상으로 한다. 헤더 부분은 스코프 영역 밖이다.

이 프로젝트의 서버에 관한 추가 내용
포함된 서버는 두 가지를 수행한다 : 어플리케이션을 위한 정적 파일을 제공하고 RESTful API를 가지고 있는 것이다. RESTful API를 만드는 주제는 이 책의 범위를 벗어나지만, 이 구현에 관한 기초적인 부분은 다룰 짬은 내고 싶다. 이 서버는 이미 설치한 노드를 사용하려 실행된다. 노드는 여러분이 컴퓨터의 파일 시스템을 다루고 HTTP 요청에 응답하는 류의 재미있는 일을 할 수 있도록 해준다.
노드는 프로그램에 포함될 수 있고, 재사용할 수 있는 모듈들이 있다. 이 예제에서는 Express라는 유명한 노드 모듈을 사용했다. Express는 HTTP 서버를 만들기 위해 탑재된 많은 기능들이 있다. 여기서는 노트 목록을 JSON 파일로 운영하기 위해 파일 시스템 모듈을 사용했다. 이런 것은 브라우저 안의 자바스크립트로는 할 수 없는 성격의 일인데, 노드에서는 가능해진다.
서버 코드를 확인하기 위해 프로젝트 내의 server.js 파일을 참고하자. 완전한 기능을 갖춘 서버이며, 노드로 작성하는 것이 얼마나 쉬운지 보여주는 예제이다. Express에 대한 더 많은 내용은 www.expressjs.com에서 확인할 수 있다.

3.5. 데이터 불러오기: 컨트롤러로 로딩하하고, 뷰로 표시하자
	데이터를 불러와서 어플리케이션에서 표시해 보자. 왼쪽 영역은 이미 생성된 노트의 목록을 보여주는 부분이다. 여러분이 시작할 때 바로 쓸수 있는 노트 몇 개를 미리 생성해 두었다. 앞서 컨트롤러를 만들었기 때문에 앱으로 데이터를 불러오기 위해 수정하면 된다. $http 서비스를 이용할 것인데, 노드 서버로부터 데이터를 가져오기 위해 HTTP 요청을 만들기 위한 것이다. 그림 3.6은 어플리케이션이 노트 목록을 표시할 영역을 보여준다. Git을 사용한다면, 다음과 같이 step4로 프로젝트 소스 코드를 설정할 수 있다:
$ git checkout -f step4
[그림 내의 원문] 왼쪽 열에서 노트 목록이 나타난다.
그림 3.6 데이터를 로드한 후 왼쪽에 목록이 표시된다. 현재 5개의 노트가 보인다.
이제 컨트롤러를 수정해서 노트 서비스에 HTTP 요청을 추가하고, 결과 데이터를 스코프에 대입해야 한다. Js/editor.js 파일을 열고 다음의 코드로 수정한다.
리스트 3.2 서비스로부터 노트를 불러오는 데이터 컨트롤러
[이하 위에서 아래로 순서로 번역]
$http 서비스를 컨트롤러로 주입한다
$http.get으로 노트를 불러 온다; 성공시 반환된 데이터를 처리한다
http로부터 반환된 데이터를 $scope에 등록한다.
이제 컨트롤러가 로딩되면, data/notes.json 안의 기본 노트 목록을 불러오기 위해 http://localhost:3000/notes로 HTTP 요청을 만들것이다. 브라우저의 개발자 툴을 통해 네트워크 요청을 보면, 노트 배열이 반환되는 것을 알 수 있을 것이다. AngularJS는 유효한 JSON 문자열을 응답에서 감지하면 자동으로JSON을 해석해서 자동으로 자바스크립트 객체로 변환한다. 별도의 파싱을 위해 직접 개발할 필요 없이 JSON 데이터를 로딩할 수 있어 편리하다.
	컨트롤러 함수에서 함수에 사용할 파라미터는 얼마든지 선언할 수 있다. AngularJS는 선언된 이름에 맞는 서비스를 찾아 컨트롤러에 주입하려고 할 것이다. 예컨대, 컨트롤러에 $http 서비스를 주입하여 데이터를 불러오기 위해 사용할 수 있다. 이런 방식을 의존성 주입(Dependency Injection : DI)이라고 부르는데, 서비스를 컨트롤러에서 사용할 수 있게 해주는 AngularJS의 강력한 특징이다. AngularJS 서비스는 전역적이지 않으며, 처음 주입 없이 사용될 수 없다.
	사용할 수 있는 AngularJS의 서비스가 모두 나열되어 있는 레스토랑의 메뉴를 갖고 있다고 상상해 보자. 의존성 주입은 웨이터와 같아서, 여러분의 테이블로 와 메뉴상의 특정 아이템에 대한 주문을 받는다. 그는 주방으로 돌아가서 아이템을 준비하고, 만든 것을 여러분에게 갖다 준다. 유사하게 DI 시스템은 여러분이 요청한 서비스들을 주시하고, 그것들을 사용할 수 있도록 세팅해서 컨트롤러 함수로 서비스를 제공한다. AngularJS의 기본 서비스를 주입할 수 있고, 직접 만든 것도 사용할 수 있다.
	위 코드의 $http.get() 함수에는 두 개의 메서드 체인이 있다. success() 함수의 내부 코드는 데이터가 로드되었을 때 실행되는 반면, error() 함수의 내부 코드는 data 획득에 실패한 경우에 실행된다(이를테면, 서버가 다운되어 HTTP 요청이 실팼다거나).
AngularJS와 비동기 메서드
자바스크립트는 싱글 스레드 환경에서 실행되며, 이것은 한번에 한 가지 일만 처리할 수 있음을 의미한다. 서버로부터 데이터를 불러오는 것과 같은 작업은 긴 시간이 걸릴 수도 있다. 동기식 프로그래밍 방식이라면 이 작업이 완료될 때까지 다른 작업은 정지 상태가 되어, 인터페이스가 이 기간 동안 먹통이 될 수 있다.
자바스크립트가 비동기 작업을 실행할 때, 작업의 첫 부분만 실행하고 다른 작업 실행을 계속한다. 비동기 작업이 완료되면 자바스크립트에 알려주고, 작업지 나머지를 실행 큐에 넣는다. 이런 식으로 자바스크립트는 작업 처리를 계속 할 수 있도록 해준다. 자바스크립트에서의 HTTP 요청은(AJAX나 XHR 요청 같은 것) 비동기 함수 처리의 한 가지 예인데, 서버가 응답할 때까지너무 많은 시간을 소모하기 때문이다.
비동기적 함수를 처리하는 두 가지 주요 방법이 있다: 콜백과 프라미스이다. AngularJS는 비동기 함수 호출에 대해서 프라미스를 사용하는데, 여러분은 사용하는 모듈이나 어플리케이션 구조에 맞게 두 가지 다 쓸 수 있다.
AngularJS의 프라미스에 대한 상세 내용을 알고 싶다면, Xebia's blog의 다음 글을 읽어보길 추천한다: http://blog.xebia.com/2014/02/23/promises-and-design-patterns-in-angularjs/
아직 화면에서 데이터를 볼 수 없으므로 템플릿을 수정해서 왼쪽 컬럼에 노트 목록이 보이도록 해야 한다. 이를 위해 템플릿을 바인딩 시키고 $scope으로부터의 데이터 표시를 조정하기 위한 몇 가지 AngularJS 디렉티브를 이용한다. index.html 파일을 열고 다음 리스트가 보여주는 마크업을 찾아 볼드체로 표시된 부분을 템플릿에 추가하자.
리스트 3.3 노트 목록 템플릿(index.html)
(소스는 제외. 나머지는 위에서 아래 순서로)
ngif는 노트의 존재 여부에 따라 연관된 DOM 요소를 포함하거나 제거한다.
날짜를 표시하기 위해 바인딩 했으나 날짜 필터를 사용하여 짧은 형식으로 지정했다.
이제 컨트롤러가 로드되면 템플릿이 노트 목록을 보여준다. 노트 목록을 불러오는 중이거나 없는 경우 ngRepeat 리스트는 비어있고 ngIf에 의해 “No notes” 메세지를 보여준다. notes 모델이 갱신될 때마다 표현식이 평가되기 때문에, 노트 아이템이 하나라도 추가되면 그 즉시 !notes.length 표현식이 false를 반환되므로 이 메세지 단락은 숨김 처리가 된다.
	ngRepeat는 배열의 모든 아이템을 순회하면서 각 아이템을 위한 엘리먼트를 생성한다. 예제로 보자면 <li>가 아이템마다 생성되어 제목과 마지막으로 저장된 시점이 표시된다.
	AngularJS가 제공하는 수많은 디렉티브의 모든 기능을 살펴볼 수도 있다. 아이오닉 앱을 개발하면서 그 중의 많은 수를 사용하게 될 것이나, 필자는 새로 다루는 몇 개만 자세히 다룰 생각이다.
3.5.1. 필터: 데이터 표시를 위해 변환하기
	템플릿에서 note.data 데이터 바인딩 뒤에 | date:'short'가 뒤따르고 있다. 필터라고 부르는 이것은 스코프의 값을 바꾸지 않고 바인딩 된 데이터의 표현을 바꿔준다. 예를 들어, date 객체를 가지고 있는 상황에서 AngularJS date 필터를 사용해서 스코프 상의 원래 date 객체는 보전한 채 읽기 쉬운 형태로 바꿔 표시할 수 있다.
	필터는 파이프(|) 문자와 함께 추가하는 방식으로 표현식 내에서 사용된다. 필터는 연달아 사용될 수 있는데, 바꿔 말하자면 한 개 이상의 필터를 추가할 수 있다는 뜻이다. 필터로 배열을 정렬했다면(orderBy 필터를 사용해서), 배열 아이템의 갯수를 10개로 줄이는 또 다른 필터를 추가할 있다(limitTo 필터를 사용). 이 때의 표현식은 다음과 같다:
{{notes | orderBy:'title' | limitTo:10}}
AngularJS는 간편한 필터를 기본적으로 제공하고 있는데, 브라우저 설정에 근거해 숫자를 통화 단위(US 달러 $100.00나 유로 €34 와 같은)로 바꿔 주는 필터같은 것들이다. 필터도 서비스처럼 사용될 수 있는데, 보편적인 방식은 아니다.
3.6. 노트 선택을 위해 클릭 이벤트 핸들링 하기
	이제 노트를 개별적으로 보여줄 구현을 해야 한다. 왼쪽 목록의 노트를 클릭하면, 오른쪽에 내용이 나타난다. 그림 3.7은 이 상황을 나타낸다. Git을 사용한다면 다음의 명령으로 현재 단계 상태로 설정할 수 있다:
$ git checkout -f step5
1. 목록의 아이템을 클릭
2. $scope.view() 함수를 호출하여 $scope.content에 노트 데이터를 할당
3. 뷰는 노트의 전체 내용을 보이도록 갱신
그림 3.7 아이템을 클릭하면 컨트롤러를 호출해 선택한 노트로 뷰를 갱신한다.
유저가 아이템을 클릭하면 이를 처리하기 위해 ngClick을 이용하고, 노트의 데이터를 새로운 모델에 대입시킨다. 템플릿을 다시 열어 노트 목록 섹션을 수정하여 클릭 핸들러를 추가하자. 다음 리스트에서 볼드로 표시된 부분을 참고한다.
리스트 3.4 노트 목록에 ngClick 추가(index.html)

ngClick은 노트의 인덱스를 인자로 제공하여 view()를 호출한다. 노트가 선택되었다면 active 클래스를 추가하기 위해 ngClass도 추가한다.
목록의 각 노트는 이제 클릭이 가능하게 되었고, 클릭한다면, AngularJS는 $scope.view() 함수를 호출하려 할 것이다. ngClass 디렉티브는 요소에 CSS 클래스를 조건에 따라 적용하기에 유용한 방법이다. 예제에서는 노트를 보기위해 클릭한 아이템에 하이라이트 효과를 주기위해 active 클래스를 사용했다.
	$index 값이 view 함수로 전달되는데, 이것은 ngRepeat이 제공하는 특별한 변수이다. 배열 내 아이템의 인덱스 값을 알 수 있도록 해주는데, 여기서는 클릭한 노트의 인덱스를 확인하는데 사용되었다.
	view 함수를 아직 만들지 않았으므로 추가해 보자. editor 컨트롤러를 열고, 다음 리스트에서 보여주는 대로 view 함수를 추가한다.
리스트 3.5 editor 컨트롤러에 view 함수 추가하기(js/editor.js)
[위에서 아래의 순서로]
view라는 신규 $scope 메서드를 선언한다. 클릭된 아이템의 인덱스 값을 전달 받는다.
아이템을 보기 위한 목적이므로 editing 상태는 false 처리한다.
클릭된 노트의 내용을 포함하는 content라는 새 모델을 만든다.
이제 사용자가 노트를 클릭했을 때 cllick 이벤트가 발생하여 컨트롤러의 view() 함수를 호출할 것이다. view() 메서드는 content라는 새 모델의 값을 클릭된 노트의 내용으로 설정한다. 또, editing 모델을 false로 설정하는데, 아이템을 보기 위해 클릭했을 때는 편집 모드가 아닌 조회 모드가 되어야 하기 때문이다. 편집 모드는 좀 단계를 밟고 난 후에 다룰 것이다.
	아직 선택한 노트를 뷰에서 볼 수는 없는데, 다음 단계는 선택된 노트를 올바로 표시하기 위해 템플릿을 수정하는 것이다.
	노트 내용을 담고있는 content 모델을 만들었으나, 이를 보여주도록 템플릿을 업데이트 한다. 여기까지의 내용을 적용한 소스를 얻기 위해 Git으로 step6 태그를 체크아웃 해도 된다:
$ git checkout -f step6
이제 두 패널을 적절히 표시하기 위해 어플리케이션의 오른쪽 영역을 수정해보자. 오른쪽 영역은 패널이 두 개인데, 한번에 하나만 나타나도록 설정해야 한다. 첫번째 패널은 노트를 조회하기 위한 패널이고, 두번째 패널은 편집하기 위한 것이다. 이전에 $scope.editing 속성 값을 설정는데, 이것을 이용해서 어떤 패널을 보여줄지 결정한다. index.html 파일을 다시 열고, 다음 리스트의 볼드 표시 영역을 참고하여 오른쪽 영역에 관련된 부분을 수정한다. HTML 문서 내의 panel 클래스를 가지는 첫 번째 <div> 부분이다.
리스트 3.6 노트 표시를 위해 템플릿을 수정한다(index.html)
[코드 생략. 왼쪽에서 오른쪽 방향으로]
제목을 패널 해더에 연결한다.
ngHide는 조건이 true일 때 상단 패널을 숨긴다. 여기서는 editing이 true인 경우.
(다음페이지. 역시 왼쪽에서 오른쪽 방향으로)
내용을 panel-body로 연결
ngShow는 조건이 false일 때 아래 패널을 보여준다. 여기서는 editing이 false인 경우.
노트 날짜를 표시. 짧은 형식을 위해 필터 처리.
이제 어플리케이션을 실행하면, 노트 아이템을 클릭할 수 있고, 각 노트의 내용을 볼 수 있다. 템플릿은 content와 editing 모델을 설정하는 view() 메서드가 만드는 상태 변경과 상호 작용한다. editing 모델이 true가 되면 편집용 패널이 나타나고, 그렇지 않은 경우에는 조회용 패널이 보여진다. ngShow와 ngHide 디렉티브는 그림 3.6에서 보여주듯이 요소들의 표시 상태를 토글하는데 유용하다.
	노트의 제목, 내용, 날짜를 바인딩 시켰다. 날짜는 date 필터가 앞서 수행했듯이 적용되었다. 이제 노트의 내용을 해석해서 적절하게 표시하기 위한 새로운 디렉티브를 만들어야 한다.
3.7. Markdown 형식의 노트를 파싱하기 위한 디렉티브 만들기
	지금 시점에서는 노트를 볼 수는 있으나 형식이 제대로 나오지는 않는다. 이 어플리케이션은 Markdown으로 노트를 작성할 수 있도록 지원한다. Markdown은 HTML 마크업으로 쉽게 변경될 수 있는 텍스트를 작성할 수 있는 간편한 방법이다. Markdown에 대해서는 http://daringfireball.net/projects/markdown/에서 배울 수 있다. 그림 3.8은 Markdown을 사용한 형식을 보여준다. 현재까지의 과정은 step7 태그를 체크아웃하면 받을 수 있다:
$ git checkout -f step7
Markdown 형식의 일반 텍스트를 HTML로 변환한 내용
그림 3.8 Markdown 형식으로 작성된 노트의 내용은 파싱되어 HTML로 변환된다.
이제부터 Markdown 형식으로 작성된 텍스트를 HTML로 변환해주는 AngularJS 디렉티브를 만들어보자. 이를 위해 Showdown이라는 자바스크립트 Markdown 라이브러리를 사용할 것이다. 이미 내려받은 어플리케이션 파일에 포함되어 있다.
	디렉티브를 생성하기 위해 app.js 파일을 연다. 디렉티브는 컨트롤러 종류가 아니기 때문에 메인 app 파일에 저장된다(더 큰 프로젝트에서는 디렉티브를 위한 별도의 파일로 분리하는 것도 방법이다). 다음의 리스트에서 Markdown을 HTML로 변환하기 위해 사용할 디렉티브를 확인할 수 있다.
리스트 3.7 Markdown을 HTML로 변환하는 디렉티브(js/app.js)
[위에서 아래, 왼쪽에서 오른쪽 방향]
디렉티브는 관련 설정을 정의한 객체를 반환
디렉티브를 선언하고 'markdown'으로 이름을 지정
나중에 사용할 Showdown 변환기를 생성
Markdown을 변환하여 content 변수에 대입
변수가 Markdown 어트리뷰트에 지정되도록 커스텀 스코프를 선언
변환된 HTML 컨텐츠를 엘리먼트에 주입
모델이 변경되면 즉시 반영하도록 스코프의 왓쳐를 사용
Markdown->HTML 변환을 실제로 관리하는 링크 함수 선언
이 디렉티브는 콘텐츠가 변경될 때마다 자동으로 Markdown을 HTML로 변환시켜주기 때문에 노트 편집 시 유용할 것이다. 디렉티브는 Showdown 컨버터 서비스를 새로 생성하는 것으로 시작한다. 또한 컨트롤러 스코프내에 포함되어 자체적인 스코프를 별도로 가지게 된다. Markdown을 스코프의 속성으로 정의했는데, 다음 섹션에서 이 값이 어떻게 자리를 잡는지 보여주겠다.
	link 함수는 렌더링 과정에서 AngularJS가 사용한다. 이 함수는 $scope.$watcher를 사용해서 Markdown 컨텐츠가 변경되는 시점을 주시한다. 변화가 감지되면, 텍스트 컨텐츠가 Showdown 변환기로 전달되고, 결과물이 HTML 형식으로 엘리먼트에 주입된다. 스코프 내의 원본 컨텐츠는 텍스트 버전으로 남아있지만, 언제나 변환된 HTML로 보여질 것이다.
	이 디렉티브를 실제로 장착시켜 Markdown 컨텐츠가 전달되는 방식을 알아보자. 작성한 노트를 받아, Showdown으로 해석하고, HTML 결과물을 엘리번트에 주입할 것이다. index.html 파일을 열어 현재의 컨텐츠 바인딩을 다음과 같이 수정한다:
<div class="panel-body" markdown="{{content.content}}"></div>
만든 디렉티브가 지금껏 사용한 다른 디렉티브처럼 HTML 어트리뷰트임을 보라. 디렉티브가 소유한 별도의 스코프로 content 모델을 전달하기 위해 markdown 어트리뷰트에 content.content 모델을 할당했다. 이 디렉티브는 컨텐츠를 주입하고 싶은 엘리먼트의 어트리뷰트로 사용되었다. HTML은 div 엘리먼트의 내부에 삽입되었고, content.content가 변경될 때마다 디렉티브 스코프의 $watch함수가 새 컨텐츠를 재변환하도록 할 것이다.
	디렉티브는 매우 복잡한 주제로, 우리는 이걸로 할 수 있는게 뭔지만 살짝 다루어 보았다. 이 디렉티브를 만드는 다른 방법이 있고, AngularJS의 디렉티브 특성을 훨씬 강력하게 해주지만, 정복하기에 다소 어려움이 따른다.
나만의 디렉티브를 만들 필요가 있는가?
자신만의 디렉티브를 만들어야 하는 것은 아니다. 디렉티브는 DOM 내의 엘리먼트를 변경하고 싶은 상황을 위한 것이지만, 컨트롤러를 사용해서 같은 로직을 구현할 수도 있다. 그러나 커스텀 디렉티브를 만들고 싶지 않은 고민에 대한 많은 좋은 이유들이 있다.
디렉티브는 잘 작성되면 테스트하기가 쉽다. 디렉티브는 기능(컨트롤러나 링크 함수를 포함)과 템플릿(템플릿 조각을 포함) 두가지를 내포하고 있다. 이렇게 하면 모듈성이 강화되고 다른 코드로부터 격리가 되어 디렉티브 자체에만 집중된 테스트를 만들수 있다.
또한 재사용성을 가지고, 여러 군데에서 작성되는 동일한 코드를 줄여준다. 어플리케이션에서 디렉티브를 재사용하고 싶은 장소가 어디인지에 상관없이 일관성을 가진다. 컨트롤러에 로직을 구현하고 다른 컨트롤러에서 다시 사용하고 싶은 경우가 발생한다면, 같은 코드를 두 번 작성하던가 스코프를 공유할 방법을 강구해야 한다.
나만의 디렉티브 없이 AngularJS와 아이오닉 앱을 만들수는 있다. AngularJS에 익숙해질 때까지는 초심자가 디렉티브에 집중하지 않기를 권한다. 익숙해질 때 커스텀 디렉티브로 대체할 곳을 찾기 위해 중복된 코드가 존재하는 곳이나 컨트롤러로부터 조작되는 DOM이 있는 곳을 찾는 방법이 있다.
이제 존재하는 노트를 보여주는 기능은 완료가 되었다. 다음부터는 편집 기능을 구현하는데 집중할 것이다.
3.8. 콘텐츠 편집, 관리를 위해 모델 사용하기
편집기는 두 가지의 주요 기능이 있다: 이미 있는 노트를 수정하거나 새 노트를 만드는 것이다. 어플리케이션이 처음 로드되거나 New 버튼을 사용자가 클릭하면 새 노트를 생성하기 위한 에디터를 구축하는 것부터 시작해보자. 그림 3.9는 이번 섹션에서 변경할 것을 나타낸다. 이번 섹션을 위해 step8 태그를 Git 저장소에서 체크아웃할 수 있다:
$ git checkout -f step8
1. 사용자가 텍스트 영역에 타이핑을 하면 스코프의 content가 갱신된다.
2. 스코프는 현재 컨텐츠를 따라간다.
3. 미리보기 영역은 스코프가 바뀔때마다 갱신되고 markdown을 변환한다.
그림 3.9 모델은 텍스트 영역에서 유저가 수정하고, 미리보기 영역은 변화가 있을때마다 갱신된다.
폼에 모델을 몇 개 추가하여 폼 컨트롤이 데이터를 업데이트 할 수 있도록 만들어야 한다. 한편 편집기 오른편은 타이핑하는 컨텐츠의 미리보기를 제공하는데, 여기에도 Markdown 디렉티브를 추가할 것이다.
	index.html 파일을 열어 다음 리스트의 볼드 표시된 부분을 반영하여 폼 내부의 마크업을 수정한다:
리스트 3.8 편집기 수정(index.html)
input에 title 모델 추가
(다음페이지)
textarea에 content 모델 추가
컨텐츠 미리보기를 위해 markdown 디렉티브 사용
모델 값을 input과 textarea에 연결하기 위해 ngModeld을 사용하였는데, 사용자가 각 필드에 타이핑하여 바뀔때마다 content 모델의 값이 바뀔 것이다. preview 필드는 콘텐츠의 변화를 즉시 반영해야 하고, Markdown 포맷을 사용한다면, 미리보기 영역에서 HTML로의 변환도 일어나야 한다.
	사용자가 New 버튼을 클릭해 새 노트를 만들수 있게도 하고 싶은데, 현재로써는 편집기가 어플리케이션이 처음 로드될 때만 나타나기 때문이다. 따라서 New 버튼에 click 이벤트를 추가할 필요가 있다.
	한편 노트를 수정할수 있도록 해야 하는데, 이 때문에 노트가 열린 후 편집을 할 수 있는 추가 버튼이 필요하다. 이것은 editing 모델 값을 변경함으로써 간단히 처리할 수 있는데, 편집용 패널을 보여주고 조회용 패널을 숨긴다.
	index.html 파일에서 다음의 볼드 표시처럼 New 버튼을 수정한다:
<h3 class="panel-title"><button class="btn btn-primary btn-xs pull-right" ng- click="create()">New</button> My Notes</h3>
그리고 Edit 버튼도 다음처럼 수정한다:
<h3 class="panel-title">{{content.title}} <button class="btn btn-primary btn- xs pull-right" ng-click="editing = true">Edit</button>
New 버튼은 다음에 정의할 컨트롤러의 create() 메서드를 호출한다. Edit 버튼은 메서드를 호출하지 ㅇ낳고, edting 모델의 값을 true로 설정한다. 물론 이렇게 작동하는 함수를 만들어도 되지만, 여기서는 템플릿 내에서 표현식을 사용하는 법을 보여주려고 이렇게 했다.
	이제 컨트롤러에서 crate() 메서드를 정의한다. editor 컨트롤러를 열어 다음 리스트 처럼 새 메서드를 추가한다.
리스트 3.9 Create 메서드(js/editor.js)
[왼쪽에서 오른쪽으로]
editing 값이 true가 되어야 함.
content 모델은 빈 값으로 초기화.
메서드를 생성하여 스코프에 등록하면, 템플릿의 ngClick을 통해 호출될 수 있다
Edit 버튼이 클릭되면, create() 메서드가 호출된다. editing 모델을 true로 설정하고 content 모델을 공백 노트로 초기화 시킨다. 이렇게 하면 편집기가 표시되고 공백 노트가 폼에 표시되는데, 이게 바로 새노트이다.
3.9. 노트의 저장과 삭제
이제 노트를 만들고 수정할 수 있다. 그러나 아직 저장할수는 없다. 컨트롤러에 save() 메서드를 추가하고 Save 버튼이 호출하도록 하자. 헌데 아이템 저장은 노트가 유효할 때 이뤄저야 한다. 무슨 말이냐면, 제목과 내용이 있어야 한다는 듯이다. 그림 3.10은 편집 중일 때의 Save와 Delete 버튼이 click 이벤트를 받아 컨트롤러의 메서드를 호출하는 흐름을 보여준다. 이번 섹션의 소스코드는 Git 저장소에서 step9 태그를 체크아웃하면 얻을 수 있다:
$ git checkout -f step9
[왼편]
1. 제목과 내용이 채워지면 Save 버튼을 클릭
2. 컨트롤러의 save 메서드를 호출
[오른편]
1. 존재하는 노트를 수정 중일 때 Delete 버튼을 클릭
2. 컨트롤러의 delete 메서드를 호출

그림3.10 Save, Delete 버튼은 click 이벤트를 받아 컨트롤러의 메서드를 호출한다.

3.9.1. save() 메서드 추가하기
노트 저장을 위해 $http 서비스를 이용하여 노트를 전송한다. 서버측 서비스는 POST 메서드를 노트 생성을 위해 이용하고, PUT 메서드를 갱신한다. $http.post()와 $http.put() 메서드는 모두 두 번째 파라미터를 받는데, 이것은 서버쪽으로 전송할 데이터를 뜻한다. 이것이 없으면 $http.get()과 문법이 같아진다.
	노트를 저장하기 전에 노트가 신규 생성된 것인지 이미 존재했던 것인지 판단해야 한다. 이를 위해 content의 id를 확인한다. 새 노트는 저장되기 전까지는 id 값이 없다. 따라서 값이 존재하면 업데이트를 하면 된다. 노트가 신규인지, 기존 것인지 확인이 되면, 그에 따른 서버측 api를 호출하면 된다.
	editor 컨트롤러를 열고 다음과 같은 save() 메서드를 추가한다.
리스트 3.10 서버로 노트를 저장하기 위한 save 메서드 추가(js/editor.js)
[위에서 아래, 왼쪽에서 오른쪽]
스코프에 save() 메서드를 추가
이 노트의 마지막 저장 날짜를 설정
이 노트가 id 값이 있다면 기존 노트를 업데이트하고, 그렇지 않으면 새로 생성
업데이트를 위해 PUT 요청을 보내고, 완료되면 편집 모드를 끔
새 노트이므로 현재 타임스탬프에 기반한 고유값 id를 설정
노트 생성을 위해 POST 요청을 보내고, 편집 모드를 끄기 전에 노트 목록에 추가
save() 메서드는 현재의 타임스탬프로 date를 업데이트하는 것부터 시작한다. 마지막으로 저장한 날짜를 기록하기 위해서다. 그다음 PUT이나 POST 요청을 보내는데, 이것은 노트가 신규이냐 기존 것이냐에 따라 달라지는데 id 값의 존재여부로 판단한다. 요청이 완료되면, 두가지 형태의 요청 모두 편집 모드를 중지시키고 저장된 노트를 조회하도록 바꾼다. 노트가 신규라면 id 값을 추가하고 컨트롤러의 노트 배열에 추가한다. 이것은 어플리케이션과 원격의 서비스의 동기를 맞추기 위해 중요한데, 이 처리를 안하면 새 노트는 서비스에는 저장되지만 현재의 노트 목록에서는 안 보이게 된다.
3.9.2. 유효성 확인을 위한 Angular 폼 사용
아이템을 저장하기 전에 폼의 유효성을 체크해서 유효하지 않은 상황에는 Save 버튼을 비활성화 시키기 위해 AngularJS에 탑재된 폼 관련 기능을 이용하려고 한다. AngularJS는 여러분이 기존에 알고 있던 HTML의 폼 기능을 확장했는데, 그중 특히 유용한 기능 하나가 자동 유효성 검사이다.
	required 어트리뷰트를 가지고 있는 폼 컨트롤을 살펴보자. AngularJS는 이를 감지하고 폼이 유효한지 감시하기 위해 스코프에 몇 가지 값을 설정한다. 예제의 경우 노트는 제목과 내용이 필요한데, 한 개라도 빈 상태이면 유효하지 않은 상태이다.
	AngularJS는 보통의 HTML 폼 엘리먼트를 사용하기도 하고, 폼을 개선시키기 위해 ngForm 어트리뷰트를 쓰기도 한다. 이번에는 보통의 폼 엘리먼트를 쓰고, editor라는 이름을 지정했다. 그리면 폼은 같은 이름의 속성을 스코프에 추가하고, $valid, $invalid, $dirty나 $pristine과 같은 값을 가진다. 이 값은 input이 유효한지, 변경이 되었는지 등을 이해하는데 유용하다.
	폼이 유효할 때까지 Save 버튼을 비활성화 시키기 위해 유효성 검사를 사용하고, click 이벤트를 Save 버튼에 추가한다. index.html 파일에서 Save 버튼의 위치에 다음의 볼드 처리된 디렉티브를 추가한다:
.	<button class="btn btn-primary" ng-click="save()" ng- disabled="editor.$invalid">Save</button>

ngClick은 이제 익숙해져야 한다. 컨트롤러의 save() 메서드를 호출해서 노트를 저장할 것이다. 그러나 editor.$invalid의 값이 true이면 이벤트를 발생시킬 수 없을 것이다. ngDisable 디렉티브는 폼 유효성 여부를 주시하는데, 두 폼 컨트롤이 비어 있으면 비활성화 시킨다. AngularJS는 required와 같은 어트리뷰트를 알고 있다. ngModel이 폼 필드에 연결되면, 폼은 자동으로 유효성 체크를 제공한다.
3.9.3. 삭제 메서드 추가
	마지막으로 만들어야 할 것은 노트의 삭제 기능이다. Delete 버튼은 존재하는 노트를 편집하는 상황에서만 나타난다. Git 저장소에서 이번 섹션의 변경 내역을 얻으려면 step10 태그를 체크아웃 한다:
.	$ git checkout -f step10
.
.
먼저 remove() 메서드를 추가하여 서버에 노트 삭제 요청을 보내고 어플리케이션의 목록에서 제거시킨다. 다음 리스트의 코드를 참고하여 editor 컨트롤러를 수정한다.
.	리스트 3.11 노트를 삭제하는 메서드(js/editor.js)
.	[위에서 아래로, 왼쪽에서 오른쪽]
.	remove() 메서드 선언
.	노트 API 서버로 삭제 요청 전송
.	삭제된 노트의 인덱스를 찾기 위해 notes 순회
.	(다음 페이지)
.	노트를 찾았다면 목록에서 삭제
.	신규 노트 생성을 위해 content 모델 초기화
.
remove() 메서드는 서버로 HTTP delete 요청을 노트의 id와 함께 보낸다. 그런 후 컨트롤러의 notes 배열의 아이템을 삭제한다. notes 모델에서 노트를 지우기 위해 모든 노트를 루프를 돌며 삭제된 id와 일치하는지 확인하고, 찾은 경우에 배열로부터 제거한다. 또한 content 모델을 초기화하여 새 노트 작성 준비를 한다.
	마지막 변경은 ngClick을 Delete 버튼에 추가하여 remove() 함수를 호출하도록 하는 것이다. 여기에도 ngIf를 적용하여, 존재하는 노트를 편집하는 경우에만 Delete 버튼이 보이도록 한다. 아직 저장되지도 않은 새 노트를 삭제할 수는 없기 때문이다. 다음 코드는 Delete 버튼에 사용된 AngularJS의 디렉티브 이다.
<button class="btn btn-danger pull-right" ng-click="remove()" ng- if="content.id">Delete</button>
이제 버튼은 존재하는 노트를 수정할 때만 나타나고, 클릭하면 remove() 메소드를 호출하여 모델에서 노트를 지운다.
	이제 AngularJS 노트북 어플리케이션 개발을 완료했다. 이 어플리케이션을 만들기 위해 AngularJS의 이모저모를 두루 여행했는데, 우리가 한 것은 수박 겉핥기 수준의 것이다. AngularJS 에서 아이오닉 개발로 옮겨갈때도 여기서 익힌 내용은 계속 된다. 우리가 다루지 않은 개념들이 더 있지만, 여기서 할애할 수 있는 분량을 훨씬 넘어간다.

3.10. AngularJS로 쭉 갑시다
AngularJS를 익히는 것은 아이오닉 앱 개발을 위해 매우 중요하다. 따라서 이번에 AngularJS를 처음 봤다면, 필자는 좀 더 시간을 들여서 공부하라고 격려하고 싶다. AngularJS를 배우는 최고의 방법은 직접 고민하고 만드는 것이라고 믿는다.
	AngularJS로 최고의 작업을 하기 위한 방법에 대한 많은 의견들이 있다. 그 중에는 확실히 그간 알아낸 최고의 방법도 있지만, 역시나 많은 견해가 있다. AngularJS 어플리케이션을 만드는 "올바른"방법을 논의하는 온라인 상의 수많은 글들에 압도되지 않도록 주의하자. 좋은 관점들이 있지만, 여러분의 프로그래밍 스타일이나 요구 사항에 맞지 않은 의견들도 많다.
	매닝 출판사의 AngularJS in Action (http://manning.com/bford/, 번역본: AnguarJS 인 액션(제이펍))이나 AngularJS in Depth(http://manning.com/aden/, 번역본 없음)으로 AngularJS 공부를 계속해 볼 수도 있을 것이다. AngularJS 웹사이트(https://angularjs.org 또는 https://angular.io)는 중요한 문서 자원이며 처음 시작하기에 좋은 가이드도 포함하고 있다. 유튜브에도 초보적인 부분부터 매우 특수한 부분까지, 고급 주제들을 다루는 컨텐츠들이 많다. 예를 들어 https://www.youtube.com/user/angularjs를 보라.
	AngularJS의 상세 내용까지 모르더라도 괜찮은 아이오닉 앱을 만들수 있다손 치더라도, 대단한 아이오닉 앱을 개발할 수 있는 능력은AngularJS 기술을 배우고 확장시켰을 때 올라간다.
3.11. 도전할 거리
이제 이번 장에서 다룬 내용으로 AngularJS의 기본은 살펴 봤다. 여러분의 이해도를 향상시키기 위해 좀 더 파볼 주제들을 나열해 본다.
λ	에러 표시하기 - $http.get() 메서드에서 $scope.error를 설정하는 부분을 보면, 아무 것도 하는게 없다. 템플릿을 수정해서 $scope.error 값이 지정되면 에러 메세지를 보여주도록 해보라.
λ	다른 $http 에러 처리하기 - $http 메서드는 모두 오류 상황을 처리할 수 있고, 예제에서는 get() 메서드에 대해서만 처리를 했다. 다른 메서드에도 에러 핸들링을 추가하여 개선시켜 보자.
λ	ngResouce 사용하기 - $http를 사용하는 대신 ngResource 모듈을 사용할 수 있다. 이것은 RESTful API와의 상호 작용을 추상화 해서 $http 서비스의 사용을 쉽게 해준다. 관련 파일을 추가(AngularJS 사이트에서 찾아보고 다운로드 할 수 있다)하고 모듈을 포함시켜야 하는데, 어플리케이션에 다른 모듈을 포함시키는 법을 익혀라.
3.12. 정리
이번 장에서 노트북 어플리케이션을 예제로 만들면서 AngularJS의 많은 면을 다루었다. 주요 주제들을 요약해 보자.
λ	AngularJS는 제공하는 많은 디렉티브나 직접 만든 디렉티브를 통해 HTML에 기능을 추가하고 확장시킨다.
λ	템플릿은 HTML이고 AngularJS의 디렉티브나 표현식을 포함할 수도 있다. 이 템플릿이 뷰로 변환되어 사용자와 상호작용한다.
λ	컨트롤러는 어플리케이션의 비즈니스 로직을 담당한다. 이들은 함수이며, AngularJS의 의존성 주입 시스템의 지원을 받아 갯수에 관계 없이 서비스를 주입할수 있다.
λ	스코프는 컨트롤러와 뷰를 엮어주는 풀과 같으며 AngularJS의 양방향 데이터 바인딩의 핵심이다. 뷰나 컨트롤러의 데이터가 변경되면, 자동으로 서로 동기화 시킨다.
λ	필터는 템플릿 내에서 스코프에 저장된 원본 모델을 수정하지 않고 데이터를 변형하는 방법이다.
λ	디렉티브는 강력하고, AngularJS에 익숙해질 때 자신만의 디렉티브를 만들면 된다. 꼭 필요한 것은 아니지만, 적절한 상황에서는 사용되어야 한다.
4장에서는 여러분의 첫 아이오닉 앱을 바닥부터 만들어 보면서 앱 개발에 사용할 여러가지 특징들을 배워볼 것이다.
