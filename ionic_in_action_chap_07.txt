7. 프로페셔널한 앱을 위한 고급 기술들

<< 상자 시작 >>
  이 장에서 다룰 내용
  * Sass 변수를 사용해서 아이오닉 스타일 커스터마이징 하기
  * 제스쳐와 이벤트 다루기
  * 앱이 사용하는 데이터를 저장하고 지속시키기
  * 다른 플랫폼에 적용하기 위해 앱을 변경하기
  * 아이오닉 기본 동작과 설정을 조정하기
<< 상자 끝 >>

이번 장은 대부분의 앱에 적용되는 고급 기술들을 다룬다. 아이오닉 개발자가 플랫폼을 깊이 팔수록, 아이오닉의 코어 컴포넌트들이 유용하기는 하지만, 잘 설계된 앱들에 필요한 모든 것을 제공하지는 않는다는 것을 알게 될 것이다. 모든 앱마다 고유의 그런 요소들이 있을 것이다. 아이오닉의 컴포넌트를 바꾸거나 만들지 않고, 있는 그대로 사용하는 것은 고품질의 앱을 만들때 좋은 접근이 아니다.
이번의 여러 기술을 다루면서, 여러분은 아이오닉의 힘을 이용함과 동시에, 고유한 사용성을 위해 확장하면서 앱을 설계할 수 있게 될 것이다. 또한, 다른 플랫폼 적용을 위해 디자인과 행동 방식을 수정하고, 사용성을 높이기 위해 이벤트와 저장소를 다루게 될 것이다.

7.1 이번 장 프로젝트를 위한 설정
이번 장은 이전의 장들에서 시작부터 끝까지 앱을 만들던 것과는 조금 다르다. 이번 장의 예제들은 그 때 그 때 다루는 기능에 대해서만 집중한 최소화 버전들의 집합이다. 예제 소스를 다운로드 받을 수도 있고, Git으로 체크 아웃해서 복사할 수도 있다.
예제들은 각 절에 대한 폴더로 구성되어 있다. 앞으로 진행하면서 봐야할 폴더를 알려주겠다. 각각의 폴더에 대해 브라우저 미리보기를 하려면, 해당 폴더 안에서 ionic serve를 실행해야 한다. 어떤 폴더들은 에뮬레이터나 디바이스 상에서 실행해야 할 수도 있다.

7.1.1 코드 얻기
이번 장 예제의 최종본을 복사하려면, 완료된 파일을 다운로드 받거나 GitHub 저장소에서 체크아웃을 하면 된다. 다음의 링크에서 zip 파일을 다운로드해서 압축을 풀고 보면 된다: https://github.com/ionic-in-action/chapter7/archive/master.zip. 체크아웃을 하려면, 다음의 명령을 실행해서 저장소를 복제한다(이번 장은 마스터 브랜치를 사용하고, 각 단계를 체크아웃 하기 위한 태그가 없다):
$ git clone https://github.com/ionic-in-action/chapter7.git
$ cd chapter7

7.2 Sass로 아이오닉 스타일을 커스터마이징 하기
아이오닉은 모든 컴포넌트에 대한 기본 색상과 스타일 세트를 미려하게 만들어 제공한다. 지금까지의 예제는 극소수의 커스텀 스타일만 사용했고, 아이오닉 기본 스타일에 대부분 의존해왔다. 이런 점이 아이오닉을 배우기 좋게 하고, 그 진가를 보여주긴 하지만, 제대로 할려면 여러분의 니즈에 맞는 디자인을 꾸미고 싶을 것이다.
필요에 따라 앱의 표현을 커스터마이징하는 것이 가장 좋은 일이다. 색에 대해서는 특히 옳다. 왜냐하면, 여러분의 앱에 자신만의 디자인과 브랜딩을 녹여내길 원하기 때문이다. 만들고 있는 앱에 가장 좋은 것이 무엇일지 고민하는데 시간을 들이는 것은 보편적인 상황이면, 앱의 브랜딩과 스타일에 대한 고민은 비전을 명확하게 만들어준다.
아이오닉의 기본 CSS 파일 자체를 바꾸려고 하는 건 안된다고 재차 말하고 싶다. 이건 좋지 못한 방식이고, 아이오닉을 이 후에 업데이트 할 때 문제가 생길 수 있다. 또한, 아이오닉 스타일을 바꾸기 위한 새로운 규칙을 추가하는 것은 유지 보수에 있어서 오래도록 스트레스를 받게 하는 요인이 될 수 있다. 특히 모든 컴포넌트의 기본 색상을 바꾸려는 경우는 더 그렇다.
이번 절에서는 프로젝트의 sass 디렉토리에 있는 예제를 사용할 것이다. Sass를 설정하는 법을 작동하는 예제를 해보면서 알게 될 것이다. 아이오닉의 스타일을 우리의 목적에 맞게 커스터마이징 하기 위해 Sass를 사용해 보자.

7.2.1 Sass 설정하기
Sass(Syntactically Awesome Stylesheets)는 CSS 프로세서 이다. Sass는 CSS의 서브 셋이고, 이는 표준 CSS를 사용할수 있고, Sass도 이를 이해한다는 것을 의미한다. Sass는 CSS로 컴파일 되기 때문에, 브라우저가 별도로 필요로 하는 것은 없다. 그러나 Sass는 CSS가 지원하지 않는 많은 기능(변수 사용, 중첩, 상속)을 지원하기 때문에 스타일을 커스터마이징하는데 있어서 매우 유용하다. http://sass-lang.com에서 Sass에 대하여 더 알아볼 수 있다.
아이오닉은 Sass를 사용해서 스타일이 작성되었고, 변수를 광범위하게 사용했다. 변수는 한번 선언되면 여러 군데에서 사용될 수 있다.
따라서 색을 지정하는 변수를 한번 수정하면, 이것이 사용되는 곳 모두의 색을 바꿀수 있게 된다. 주요 색과 스타일, 폰트, 패팅, 테두리, 그리고 기타등등을 제어하는 변수가 굉장히 많이 있다. 여기에 우리는 변수를 오버라이드 해서, 새로운 값을 가지는 CSS를 다시 생성할 수 있다.
일단 앱이 Sass를 쓸 준비가 되도록 설정을 해주어야 한다. 프로젝트에 필요한 Node 관련 모듈을 설치하고, ionic setup 코맨드를 실행해서 앱의 일부분을 업데이트한다:
$ npm install -g gulp
$ ionic setup sass
첫 번째 코맨드는 Gulp라는 빌드 도구를 설치한다. 아이오닉은 Sass 파일을 CSS로 변환하는 등의 작업을 실행하기 위해 Gulp를 사용한다. Gulp는 gulpfile.js 파일을 사용하는데, 이 파일은 아이오닉 프로젝트를 처음 구성할 때 생성된다. 용도는 Gulp가 수행할 작업을 관리하는 것이다. Gulp 파일을 수정해서 실행하고 싶은 작업을 추가할 수도 있는데, 기본적으로 아이오닉이 만들어 놓은 작업은 Sass 빌드에 관련된 것 뿐이다.
두 번째 명령은 Sass를 위해 필요한 몇 가지를 설치하게 한다. 노드 패키지 관리자(npm)을 사용해서 의존적인 모듈을 설치하고, Gulp 파일이 Sass 작업을 갖고 있는지 확인한다. Gulp 파일을 찾았다면(여러분이 어쩌다 지운게 아니라면 있어야만 한다), 작업을 실행하고 첫 번째로 CSS를 빌드한다. 또한 ionic.project 파일에 몇 가지 노트를 추가할 것이다. 마지막으로 index.html파일을 수정하여 새로 커스터마이징 되고 컴파일된 CSS 파일(www/css/ionic.app.css)을 참조하도록 한다. 새로 생성된 파일이 www/index.html 파일안에서 연결이 제대로 되어 있는지 여러분이 확인해야한다.
새 프로젝트를 만들 때 이 작업도 수행하는 것이 나중에 할 때를 기다리는 것보다 훨씬 쉽니다. 이제 아이오닉을 커스터마이징 하기 위해 기본 변수를 수정하는 방법을 살펴보자.

7.2.2 Sass 변수로 아이오닉 커스터마이징 하기
아이오닉은 스타일에 관련된 각기 다른 영역들을 위해 수백개의 기본 변수를 가지고 있다. 수정하기에 가장 명확하고 유용한 것은 9개의 기본 컬러 옵션이다. 정확한 변수의 갯수는 아이오닉이 업데이트 될 때마다 변할수 있지만, www/lib/ionic/scss/_variables.scss 파일에 모든 변수가 나열되어 있다. 그러나, 이 파일을 바로 수정하면 안된다! 커스터마이징에 필요한 변수를 찾기위한 참고로만 활용하고, 다른 경로의 파일에서 이를 오버라이드 해야 한다.
변수를 커스터마이징 하기 위해, scss/ionic.app.scss 파일을 수정할 것이다. 열어보면 주석이 몇개 보이지만, 실제 핵심은 다음의 두 명령이다.

// The path to ionicons font files, relative to the built CSS in www/css
$ionicons-font-path: "../lib/ionic/fonts" !default;

// Include all of Ionic
@import "www/lib/ionic/scss/ionic";

첫 번째는 폰트 아이콘 디렉토리를 올바로 링크하는 변수인데, 왜냐하면 이 파일은 디폴트 파일이 아닌 다른 장소에 있기 때문이다. 두 번째는 @import 명령인데, www/lib/ionic/scss/ionic.scss 파일을 임포트 함으로써 다른 Sass 파일들도 함께 포함시키게 한다. @import 명령 앞에 있는 변수는 모두 기본 변수를 오버라이드 하게 되므로, 여기가 바로 새 값을 할당할 수 있는 곳이된다. 변수를 추가할 때마다 Sass 파일을 다시 빌드해야 한다.
아이오닉의 기본 컬러 집합을 구글 머티리얼 디자인 표준 세트의 색으로 변경한다고 해보자. @import 명령 앞에 변수를 추가하고 다음 리스트처럼 새로운 기본값으로 설정한다.

<< 리스트 시작 >>
  리스트 7.1 Sass 변수들 (scss/ionic.app.scss)

  요구 사항에 맞게 변수의 기본값을 설정
  아이오닉의 Sass 파일 라이브러리 임포트. 여러분의 변수는 여기에 있는 변수를 오버라이드 하게 됨
  앱의 Sass 파일 임포트
<< 리스트 끝 >>

아이오닉 색상 클래스를 사용하는 곳이라면(bar-positive라던가 tab-positive와 같은)어디든지 기본 색이 새로운 색으로 바뀔것이다. 우선 CSS 파일을 재생성해야 하는데, Gulp 작업을 실행함으로써 이를 수행할 수 있다:
$ gulp sass
순식간에 리빌드가 끝나고 www/css/ionic.app.css 파일이 새로운 색상 설정으로 갱신되어야 한다. 매우 멋진 기능이긴한데, 스타일을 바꿀때마다 Gulp 작업을 재실행해야 한다는 사실을 생각해야 하는건 좀 짜증나는 일이다. 그래서, 변경 내용을 저장할 때마다 자동으로 리빌드를 수행하도록 하는 왓치 태스크가 있다. 별도의 코맨드 라인 창을 가지고 실행되어 백그라운드에서 지속적으로 실행된다. 코맨드라인 창을 새로 열거나 탭을 연 후 gulp watch 명령을 실행한다:
$ gulp watch
아니면, ionic serve를 사용하고 Sass를 설정하면, serve 명령이 자동으로 파일이 변경될 때마다 CSS를 리빌드해서 브라우저 리로딩 없이 CSS를 갱신시켜, 변경 내용을 바로 볼 수도 있다.
때때로 gulp watch나 serve 명령은 에러를 토해 내거나 실행이 멈출수도 있다. serve 명령은 이런 사실을 알려줄수도 있지만, 만일 변경한 내용이 의도한 대로 나타나지 않는다는 것을 알았다면, serve 명령이 제대로 계속 실행되고 있는지 확인해 보기 바란다. 가끔 코드상의 문법 오류가 serve 명령 실패를 야기하기도 한다.

7.2.3 나만의 스타일을 위한 Sass 사용하기
아이오닉의 변수를 변경하는 수준을 넘어 커스터마이징을 하기 위해 Sass를 사용할 수 있다. 게다가 Sass를 사용해서 모든 커스텀 스타일 코드를 작성하는 것은 좋은 생각이다. 도움되는 기능들을 많이 활용할 수 있는데다가 원한다면 CSS를 그대로 쓸 수도 있다. 필자는 개인적으로 여러분이 Sass의 확장된 기능의 필요성을 잘 모를지라도 추천하고 싶다. 최소한, 파일을 저장하려고 할 때 바로 문법 오류라도 알려주니까 써보길.
시작하는 가장 쉬운 방법은 scss 디렉토리에 새 파일을 생성하고, 거기에 스타일을 작성하는 것이다. ionic.app.scss 파일에 아이오닉의 스타일을 포함시키는 것처럼, 여러분의 scss 파일을 불러오기 위해서 import를 추가할 필요가 있다. 단, 아이오닉 라이브러리를 먼저 포함시킨 후에 해야 한다. import 문법의 예는 다음과 같다:

@import "cusomizations"

대상 파일의 이름에 .scss가 들어 있다면, 확장자는 생략해도 된다. 기본적으로 Gulp 왓치 태스크는 scss 디렉토리내의 모든 Sass파일을 주시하기 때문에, 스타일을 변동시키면 자동으로 리빌드를 수행한다.
필자는 www 디렉토리에 작성한 스타일을 두는 걸 좋아한다. 예전에도 말했지만, 필자는 같은 뷰에 관련된 자바스크립트, CSS와 HTML 파일은 같은 디렉토리에 둔다고 했었다. 이 정책도 문제 없이 지킬수 있는데, ionic.app.scss 파일을 마치 app.js 파일처럼 이용해서, www 디렉토리 내의 파일들을 포함시키면 되기 때문이다. 기본적으로 아이오닉의 Gulp 작업은 scss 디렉토리에 Sass 파일을 모두 두는 걸로 가정하기 때문에 변경 감지를 위해 www 디렉토리를 감시하지는 않는다. 그러나 이것도 gulpfile.js의 paths.sass 속성의 정의를 수정함으로써 쉽게 바꿀수 있다. 이 속성은 경로를 담은 (와일드 카드나 패턴 매칭이 가능한)배열을 받는데, 예제는 www 디렉토리를 감시하기 위해 다음을 추가했다:
var paths = {
  sass: ['./scss/**/*.scss', './www/**/*.scss']
};
이 간단한 수정으로 여러분의 스타일을 HTML과 자바스크립트와 함께 모아둘 수 있다. 원하는 대로 코드를 조직화 할 수 있지만, 가장 중요한 것은 일관성을 유지하는 것이다.

7.3 온라인, 오프라인 모드를 지원하기
4장에서 6장까지의 세 가지 예재에서 우리는 장치가 인터넷 연결이 되어 앱으로 데이터를 불러 올 수 있는 온라인 상태라고 가정했다. 그러나 모바일의 세계에서는, 인터넷 연결이 드문드문 이뤄지기도 하고, 유저가 (비행기 모드 같은 걸로)직접 인터넷 연결을 꺼버릴수도 있다. 장치가 온라인 상태인지 확인하기 위해 뭔가를 수행하고, 장치가 오프라인인 상태를 처리할 수 있다.
* 장치가 현재 연결된 상태인지 질의할 수 있는 코르도바 플러그인을 사용한다.
* 온라인과 오프라인 이벤트를 리스닝한다.
두 번째 옵션을 구현해 보자. 코르도바 플러그인은 온라인인지 오프라인인지 감지하기 위해 필수적으로 필요한 것은 아니다. 이번 절은 연결이 되어 있거나, 없는 상태를 처리하는데에만 관심을 가진다. 필요하다면 Cordova Network Connection PluginAPI를 사용해서 연결 형식(Wi-Fi인지, 셀룰러 망인지 등)에 대한 상세 내용을 얻어 조사할 수도 있다.
브라우저는 서버와의 연결이 있는지 없는지를 판단하기 위한 지원을 갖고 있다. 현재 온라인인지 오프라인인지를 알 수 있는 기본 코드 자체는 간단하다. 그보다는 두 가지 상황에 대해 가능한 한 최선의 조치를 취하도록 애플리케이션을 설계하는 일이다.
다음의 리스트는 두 개의 이벤트 리스너를 애플리케이션에 추가해서 네트웍 연결의 기본 상태를 확인한다.

<< 리스트 시작 >>
  리스트 7.2 온, 오프라인 이벤트 리스닝 (offline/www/js/app.js)
  1. 로딩시 온라인 상태를 알려준다
  2. 오프라인 이벤트를 리스닝하면서 통지한다
  3. 온라인 이벤트를 리스닝하면서 통지한다
<< 리스트 끝 >>

예제는 이벤트 리스너를 만드는 방법과 로딩시 온라인 상태를 확인하는 것만 보여준다. $window.navigator.onLine 값은 true 혹은 false 값을 브라우저가 네트웍에 연결된 상태인지에 따라 반환한다(1). 그 다음 브라우저가 온라인이나 오프라인 상태로 바뀌는지 추적하도록 두 개의 이벤트 리스너를 윈도우에 추가한다(2, 3).이들은 상태가 바뀔 때에만 발생하며, 로딩중에는 발생하지 않는다. $digest() 호출이 있는데, 이것은 네이티브 이벤트 리스너에서 발생한 변화가 AngularJS의 다이제스트 루프에 등록되어 있지 않기 때문이다. 이벤트 콜백을 안에서 AngularJS 애플리케이션의 뭔가를 바꾸었다면, 변경 내용을 앱을 통해 전달하기 위해 $digest() 호출로 끝낼필요는 없다.
이 예제는 네트웍 연결을 갖고 있는지 여부만 알려주기 때문에 여러분이 확인하고 싶은 것이 아닐 수도 있다는 점을 기억해야 한다. 예를 들어, ionic serve의 라이브 리로드 기능을 쓰고 있다면, 브라우저는 아이오닉 라이브 리로드 서버도 네트웍 연결로 인식하기 때문에, 작업 컴퓨터가 실제로 네트웍에 연결된 상태가 아니더라도 오프라인으로 뜨는 일은 없을 것이다. 이것을 테스트하기 위한 가장 좋은 방법은 라이브 리로드 옵션 없이 에뮬레이션을 실행한 상태에서 상태 변화 이벤트가 발생하도록 컴퓨터의 네트웍 커넥션을 끊은 것이다.
$ ionic platform add ios
$ ionic emulate ios
앱이 에뮬레이터에서 구동되면 연결을 껐다 켤 수 있는데, 상태 변화에 따른 통지를 받아야 한다. 예제는 단순하게 만들었지만, 변화를 감지하는 기법에 대한 소개는 되었을 것이다.

7.4 아이오닉에서 제스쳐 이벤트 다루기
때때로 자신만의 컴포넌트나 인터페이스를 만들어야 할 필요가 있는데, 스와이프나 드래그 같은 사용자 제스쳐 이벤트를 다루어야 할 것이다. 아이오닉은 이를 위해 사용할 수 있는 몇가지 옵션을 가지고 있다.
극소수의 앱 만이 커스터마이징 된 인터페이스 엘리먼트를 만들지 않고 만들어질 수 있을 것이다. 어떤 앱은 엘리먼트와 상호작용을 하기 위해 매우 독특한 터치 조작이 필요하다.필자는 복잡한 제스쳐나 유저가 특별한 제스쳐를 배워야 하는 걸 만드는 것은 피하라고 권한다. 대부분의 유저는 앱 사용법을 배우는데 장벽을 느끼기 때문이다. 여러분의 커스텀 인터페이스가 보편적이지 않거나 맥락상 어떻게 써야할 지 충분한 정보를 주지 못한다면, 사용자는 앱 이용을 포기하려는 경향을 보인다. 아무도 스스로가 바보라고 느끼거나 혼란스러워 하고 싶지 않아 하기에, 조작법이 단순하도록 고심해야 한다.
제스쳐를 위해 아이오닉이 제공하는 두 가지 방법은 이벤트를 리스닝할 수 있는 디렉티브 세트와 콘트롤러에 프로그래밍으로 이벤트 리스너를 추가하는 법에 관한 것이다.

7.4.1 아이오닉 이벤트 디렉티브로 이벤트 리스닝하기
아이오닉 이벤트 디렉티브는 특정 이벤트를 리스닝하고, 이벤트가 발생했을때 표현식이나 함수를 호출할 수 있도록 하는 것이다. 해당하는 이벤트는 홀드, 탭, 드래그와 스와이프이다. 이 이벤트들이 발생하는 타이밍에 대해서는 도큐먼트에 나열되어 있다. 이번 절은 프로젝트의 event 디렉토리를 사용하는데, 그림 7.1이 결과물을 보여준다.

<< 그림 시작 >>
  상자는 OnTouch와 onRelease 이벤트를 가지고 있다
  상자가 터치되면, 콘트롤러는 박스를 유저가 손가락으로 드래그하는 방향으로 이동시킨다. 손을 떼면, 그 자리에 남아 있는다.

  그림 7.1 이벤트 디렉티브를 사용하여 터치에 따라 이동하는 상자
<< 그림 끝 >>

이 이벤트 디렉티브들이 이벤트를 리스닝하기 위한 가장 쉬운 방법이다. 어떻게 사용하는지 예제를 살펴보자. 리스트 7.3은 사용자가 화면 주위의 아이콘을 드래그 할 수 있게 하는 이벤트의 조합을 보여주는데, 유저가 아이템을 터치했다가 손을 뗄때까지 걸린 시간을 밀리초 단위로 콘솔에 로그를 뿌린다. 다음 리스트의 코드는 디렉티브를 구현했는데, 간단하게 보여주기 위해 app.js 파일에 그냥 추가했다.

<< 리스트 시작 >>
  리스트 7.3 상자 디렉티브 (events/www/js/app.js)
  상자 디렉티브가 이벤트 리스너를 추가하기 위한 링크 함수
  위치를 추적하기 위한 변수 설정
  드래그 시작 시간을 쫓기 위한 터치 이벤트 핸들러
  드래그를 수행한 총 시간을 추적하고 콘솔에 로그를 남기는 릴리즈 이벤트 핸들러
  박스의 위치를 드래그 위치를 따라가도록 하되, 경계를 넘지 않도록 하는 드래그 이벤트 핸들러
  (다음 페이지)
  인라인 템플릿: 상자는 이벤트를 기다리는 아이콘으로 드래그할 때 스타일이 갱신된다
<< 리스트 끝 >>

이 예제는 화면 주위를 움직이는 아이콘을 생성한다. 아이콘이 화면 공간을 벗어나지 않도록 제한을 받되, 사용자가 드래그하는 어느 곳이든 따라갈 수 있다. onTouch와 onRelease 이벤트 핸들러는 사용자가 아이콘을 터치한 동안의 총 시간을 추적하는데 사용되었고, onDrag 이벤트 핸들러는 아이콘의 top과 left 값을 위한 스코프 변수를 수정해서 ngStyle을 갱신하는 방법으로 아이콘을 이동시킨다.
앱에 Box 엘리먼트를 추가만 하면 바로 사용할 수 있다. 예제에서는 상자 한 개를 추가했는데, 사용자가 바로 드래그를 할 수 있다.
<body ng-app="App">
  <box></box>
</body>
위치 이동이 작동하기 위해서는 CSS 정의도 필요하다. CSS 규칙을 통해 엘리먼트의 position 속성이 absolute 값을 가지게 되고, 드래그 이벤트를 통해 전달되는 값으로 top과 left가 지정된다.
#box {
  position: absolute;
  width: 50px;
  height: 50px;
  font-size: 50px;
  text-align: center;
}
이와 같은 작동을 구현하는 방법은 여러가지가 있지만, 여기서는 이벤트 디렉티브가 사용자 제스쳐에 반응하기 위해 어떻게 쓰이는지를 보여주는데 초점을 두고 있다. 예제에서 따로 디렉티브를 만들어 적용한 이유는 DOM을 조작해야할 일이 있을 때 디렉티브를 사용하는 것이 가장 좋은 방식이기 때문이다. 그러나, 물론 일반적인 템플릿에 디렉티브를 사용하고 콘트롤러에 이벤트 핸들러를 메소드로 선언해도 된다.

7.4.2 $ionicGesture 서비스를 가지고 이벤트 리스닝하기
이벤트를 리스닝하는 또 다른 방법은 $ionicGesture 서비스를 사용하는 것이다. 이 방법은 더 넓은 범위의 이벤트를 리스닝할 수 있도록 해주지만, 좀 더 프로그래밍적 접근을 필요로 한다. 이번 절의 예제는 gesture 디렉토리를 참고하면 된다.
$ionicGesture 서비스를 콘트롤러에 주입하면, 어떤 이벤트를 리스닝할 지 선언할 수 있다. 또한 리스터가 장착될 엘리먼트도 선언해야 한다. 이 방식은 가능하면 (앞의 예제보다)디렉티브 안에서 $ionicGesture 서비스를 쓰도록 하는 것이 더 좋은 방법인데, 그래야 엘리먼트를 쉽게 사용할 수 있다.
그림 7.2에서 볼 수 있듯이, 화면 밖으로 스와이핑 해서 카드를 없앨 수 있는 간단한 예제를 만들것이다. 사용자가 카드를 오른쪽이나 왼쪽으로 스와이핑 하면 그 방향으로 에니메이션이 일어나고, 사용자가 손을 뗀 순간 카드가 일정 거리 이상을 움직였다면 화면에서 사라져 버리고, 그렇지 않으면 중앙으로 돌아온다. 다음 리스트에 코드를 볼 수 있으며, 이번장 프로젝트 코드의 gesture 디렉토리에도 있다.

<< 그림 시작 >>
  카드를 움직이기 위해 오른쪽으로 스와이핑
  각각의 카드는 드래그 제스쳐 이벤트 리스너를 가지고 있다
  카드가 일정 방향으로 충분히 그래그가 되었다면, 화면에서 사라딘다.
  화면 중앙으로 움직이면, 중앙 위치로 초기화 된다.
<< 그림 끝 >>

<< 리스트 시작 >>
  리스트 7.4 $ionicGesture 서비스 (gesture/www/js/app.js)

  (왼쪽)
  드래그 이벤트를 리스닝하고, 드래그가 발생하면 수평으로 이동시킨다
  카드가 아직 중앙에 가까우면, 5ms마다 5픽셀씩 중앙으로 복귀
  (오른쪽)
  $ionicGesture 서비스를 콘트롤러에 주입
  드래그 이벤트를 리스닝하고, 카드가 제거되어야 할지 초기화 할지 결정
  카드가 화면의 33%이상 이동하면 제거
  (다음페이지)
  카드가 아직 중앙에 가깝다면, 5ms마다 5픽셀씩 중앙으로 복귀
<< 리스트 끝 >>

카드 디렉티브는 drag와 dragend 이벤트 리스너를 장착하고 있다. 기술적으로는 drag 이벤트를 기다리고 있는데, 스와이핑 이벤트의 경우 스와이핑이 완료될 때까지는 발생하지 않기 때문이다. 즉, 스와이핑 이벤트를 리스닝하고 있으면, 스와이핑을 완료할때까지는 카드가 움직이지 않기 때문에, 지연이 발생하고 있는 것처럼 보여 사용자가 혼란을 느낄수 있다. 디렉티브는 서비스를 주입하기 위해 콘트롤러를 사용한다. on 메소드를 사용해서 이벤트 리스너를 부착할 때는 최소한 세 개의 정보를 전달해야 한다. 이벤트 이름, 이벤트가 발생했을 때 호출될 콜백 함수, 그리고 핸들러가 부착될 엘리먼트가 그것이다. 디렉티브로 구현을 했기 때문에, $element라는 특별한 서비스를 바로 사용할 수 있는데, 그렇지 않은 경우, 콘트롤러 내에서는 angular.element()를 사용해서 리스너를 장착할 엘리먼트를 지정해야 한다.
예제를 작동시키려면, www/css/styles.css에 CSS 규칙 한 줄을 추가해야 한다:
.card { position: relative; left: 0; }
이로써 card 디렉티브를 몇 개든 앱에 추가할 수 있고, 각각이 별개로 화면에서 스와이핑 될 수 있다.
<body ng-app="App">
  <card>Card 1</card>
     <card>Card 2</card>
  <card>Card 3</card>
  <card>Card 4</card>
  <card>Card 5</card>
</body>
카드 엘리먼트의 내용은 card 태그 안에 삽입되면, 트랜스클루젼이라는 AngularJS의 기능을 이용하여 보존된다. 트랜스클루젼이란 디렉티브 태그 안에 삽입된 HTML 콘텐츠를 모두 복사한 후, ngTransclude로 선언된 디렉티브 템플릿으로 위치시키는 것을 말한다.
이런 접근은 좀 더 유연하고 이전에 살펴봤던 이벤트 디렉티브보다 제스쳐 이벤트를 좀 더 확장할 수 있게 해준다. 그러나, 제스쳐 이벤트는 좀 더 많은 사전 작업을 필요로 한다. 결국에 같은 목적을 달성하기 위한 선택에 있어서, 최종 결정은 선호하는 스타일에 달렸다고 할 수 있다.

7.4.3 사용할 수 있는 제스쳐 이벤트들
처리할 수 있는 제스쳐 이벤트는 종류가 많다. 표 7.1은 가능한 제스쳐, 이름, 관련 디렉티브(있다면), 그리고 이벤트를 발생시키는 동작에 대한 목록을 보여준다.

<< 표 시작 >>
  표 7.1 지원되는 제스쳐, 자바스크립트 이벤트 이름, 가능한 디렉티브, 그리고 사용예

  (행단위로 번역하되, 각 열은 ;으로 구분함)
  Hold; hold; on-hold; 최소 500ms 이상 터치를 유지하고 있을 때
  Tap; tab; on-tab; 250ms보다 짧게 엘리먼트를 터치
  Double tab; doubletap; ; 300ms 이내로 같은 위치를 두 번 터치
  Touch; touch; on-touch; 터치가 감지되면 발생
  Release; release; on-release; 손을 뗄 때 발생
  Drag; drag; on-drag; 어느 방향이든 움직이면서 터치를 길게 유지
  Drag start; dragstart; ; 드래그가 최초로 감지될 때 발생
  Drag end; dragend; ; 드래그가 릴리즈 되었을 때
  Drag up; dragup; on-drag-up; y축 방향 위로 드래그
  Drag down; dragdown; on-drag-down; y축 방향 아래로 드래그
  Drag left; dragleft; on-drag-left; x축 방향 왼쪽으로 드래그
  Drag right; dragright; on-drag-right; x축 방향 오른쪽으로 드래그
  Swipe; swipe; on-swipe; 터치후 빠르게 어떤 방향으로든 튕겨냄
  Swipe up; swipeup; on-swipe-up; y축 방향 위로 스와이핑
  Swipe down; swipedown; on-swipe-down; y축 방향 아래로 스와이핑
  Swipe left; swipeleft; on-swipe-left; x축 방향 왼쪽으로 스와이핑
  Swipe right; swiperight; on-swipe-right; x축 방향 오른쪽으로 스와이핑
  Transform; transform; ; 두 손가락을 터치하고 움직임
  Transform start; transformstart; ; 트랜스폼이 처음 감지되었을 때 발생
  Transform end; transformend; ; 트랜스폼 상태에서 손가락을 떼었을 때 발생
  (다음 페이지)
  Rotate; rotate; ; 두 손가락이 회전
  Pinch; pinch; ; 두 손가락을 꼬집어 모으거나 떨어뜨릴 때
  Pinch in; pinchin; ; 두 손가락을 꼬집어 모을 때
  Pinch out; pinchout; ; 두 손가락을 꼬집어 떨어뜨릴 때
<< 표 끝 >>

7.5 데이터를 영속적으로 저장하기
4장에서 6장까지의 예제에서는 앱이 로딩될 때마다 그 전에 수정한 내용이 초기화 되고, 마치 처음으로 앱을 사용하는 상태로 시작했었다. 분명히 이것은 유저에게 짜증을 유발시키고 좋지 않은 경험을 선사한다. 예를 들어, 사용자가 좋아하는 아이템에 대해서 찜을 해두면, 계속 그 상태가 유지되어야 한다. 앱이 그 사실을 기억하고, 유저가 멈췄던 장소에서 다시 시작한다면 멋지지 않겠는가? 좋은 소식은 이렇게 할 수 있는 몇 가지 방법이 있다는 것이고, 여기서는 별도의 플러그인을 추가하지 않고 할 수 있는 훌륭한 방법을 알려주겠다.
아이오닉 앱은 웹 애플리케이션이기 때문에, 웹 플랫폼의 빌트인 저장소 기능을 어느정도 사용할 수 있다. 키-밸류 쌍으로 관리되는 localStorage를 제공하거나 Web SQL, IndexedDB, 또는 SQLite와 같은 좀더 견고한 데이터베이스를 제공한다.
이런 옵션들을 사용하는 기본적인 관점은 데이터를 저장할 필요가 있고, 앱이 리줌되었을 때, 첫번째로 해야할 작업은 저장소로부터 데이터를 불러온다는 것이다. 기록을 남길 수 있는 앱은 백엔드 서비스와 적절히 커뮤니케이션하기 위해 저장소에 세션 정보나 사용자 정보를 유지시킬 수 있다.
영속적인 데이터를 가지는 앱은 캐시로부터 데이터가 제거되었을 상황을 처리할 수 있도록 설계해야 한다. 저장된 데이터가 무기한으로 남아있을 거라 가정하면 안된다.
장치에 데이터를 저장할 때, 사용자가 봐선 안될 무언가를 저장하는 것에 대해서는 경계해야 한다. 장치에 저장된 데이터는 무엇이던지 잠재적으로 장치 소유자가 디버깅 툴을 통해 볼 수 있지만, 그 사용자를 위한 사적인 데이터(예컨대, OAuth 토큰 같은거)를 저장하는 것은 합리적인 일이다. 사용자에게 보여져서는 안되는 데이터는 무엇이든지 서버 환경에 저장되어야 한다(웹 서버를 위한 프라이빗 API 키 같은 것).

7.5.1 localStorage 사용하기
localStorage는 브라우저 캐시 디렉토리에 데이터를 저장하는 매우 단순한 저장소이다. 기본적으로 키-밸류-쌍으로 저장하는 시스템인데, 언제나 문자열로 값을 가지는 속성을 갖고 있는 자바스크립트 객체라고 생각해도 무방하다. 필자는 localStorage를 언제나 즐겨쓰는 편인데, 데이터를 저장하는 가장 손쉬운 방법이기 때문이다. 브라우저에서는 사용자가 언제든지 localStorage의 데이터를 제거할 수 있지만, 하이브리드 앱 상에서는 디버깅 도구를 사용하지 않는 한, 날려버릴 수 없다.
localStorage는 쓰기도 매우 쉬운데, 두 가지 제약 사항이 있다. 첫째는 저장할 대상 데이터의 형식이 원래 무엇이었던 간에, 문자열로 저장되어야 한다는 것이다. 이 말인 즉, 정수도 저장되는 동안에는 문자열로 변환된다는 이야기다. "1" === 1과 같은 비교를 문자와 숫자 사이에 비교하려고 하면 문제가 된다. 둘째는 전체 사용 공간의 제한이 있다는 점인데, 브라우저들 사이에 표준화가 되어있지 않다. 따라서 설치하려는 플랫폼의 도큐먼트를 참조해서 현재 사용가능한 공간이 얼마인지 살펴봐야 한다(이 책을 쓰고 있는 현재에는 안드로이드 브라우저 4.3은 2MB, 사파리는 5MB, 그리고 크롬은 10MB를 가지고 있다). 아니면 http://mng.bz/7J3R을 방문하면 여러가지 저장 형식에 대한 제약 사항을 잘 정리한 내용을 볼 수 있다. 이정도도 많은 공간이지만, 초과하게 되면 오류를 얻게 된다. 많은 양의 데이터를 처리하는 앱이라면 시간이 지날수록 관리하기 어려워 질 수 있다.

<< 그림 시작 >>
  좋아하는 목록이 localStorage에 저장되어 있다
  앱이 로딩될 때 사용자가 저장한 지역을 기억해내기 위해 localStorage에서 리로드를 한다.

  그림 7.3 localStorage는 지역 목록을 저장하고, 앱이 구동될 때 리로드 한다.
<< 그림 끝 >>

그러나 저장소에 대한 필요성이 간단하다면, localStorage는 대체로 최고의 해결책이다. 그림 7.3은 6장의 날씨앱이 localStorage에 지역 목록을 저장하고, 앱이 다시 열릴 때 불러오도록 갱신된 버전이다. 이번 절에서는 storage 디렉토리 내의 코드를 사용할 것이다. 6장의 예제에서 바꾼 것은 storage/www/js/app.js에 있는 Locations 서비스 뿐이다(다음 리슽의 볼드 표시 부분 참고).

<< 리스트 시작 >>
  리스트 7.5 localStorage로 저장, 불러오기 (storage/www/js/app.js)

  JSON 문자열 데이터를 localStorage로 저장하기 위한 store() 메소드 생성
  (다음 페이지)
  목록내 지역이 토글링 된 후에 store() 메소드 호출
  주 지역이 새로 설정되면 store() 메소드 호출
  앱이 시작될 때, localStorage로부터 데이터 로딩을 시도하고 실패할 경우 빈 배열로 설정
<< 리스트 끝 >>

localStorage는 자바스크립트 내에서 글로벌 범위로 사용할 수 있는데, 자바스크립트 API의 기본 스펙에 속해있기 때문이다. localStorage로 데이터를 저장하기를 원하는 곳이 여러군데에 있기 때문에 store() 함수를 추상화한 형태로 만들었다. store()가 호출되면, 지역에 대한 배열을 받아 localStorage로 저장하는데, 일단 배열을 JSON 문자열로 변환하고 진행한다(localStorage는 문자열만 저장한다고 앞서 설명했다). 그리고 나서 지역 목록이 변경되면, 캐시된 데이터를 갱신하기 위해 store() 메소드를 호출한다.
try-catch 문을 보면, 앱은 데이터를 localStorage로부터 불러온다고 가정하고 있고, 값을 얻어오면 JSON 파싱을 수행한다. 값이 없거나, localStorage로부터 데이터를 불러오는 중에 오류가 발생하였다면, 지역 목록은 빈 배열로 설정된다.
이제 앱은 언제나 저장된 지역 목록을 불러오려고 시도하고, 빈목록으로 시작하는 대신 이를 사용할 것이다. 유저 입장에서는 분명한 개선을 이루었는데다가, localStorage는 구현하기도 매우 쉬웠다.
브라우저의 개발자 도구를 사용해서 localStorage에 저장된 값을 볼 수 있는데, 지역 목록을 확인할 수 있어야 하겠다. loclaStorage는 앱마다 부여되는 것이기에, 저장한 데이터는 다른 앱으로부터 안전하다. 그러나 개발자가 뜯어 볼 수 있기 때문에, 다른 사람들이 절대로 보지 못하도록 안전하게 저장할 수는 없다는 점도 이해해야 한다.

7.5.2 Web SQL, IndexedDB와 SQLite 사용하기
Web SQL, IndexedDB와 SQLite는 브라우저 기반의 데이터 베이스의 여러 종류들이다. localStorage처럼 데이터는 브라우저의 캐시 시스템에 저장된다. 이들은 큰 사이즈의 데이터를 저장하기에 좋은 것들이고, 직접 질의하고 싶을 때 사용하기도 좋다. 그러나, 좀 더 사용하기는 어렵고, 플랫폼에 따라 지원 내용이 다소 차이가 있다.
Web SQL은 테이블을 질의하기 위해 SQL을 사용할 수 있는 풀 기능을 갖춘 데이터베이스라고 볼 수 있다. SELECT, UPDATE 등등의 SQL문을 사용할 수 있다. 문제는 Web SQL의 명세를 잡는 작업이 2010년에 브라우저 벤더들이 표준화에 동의를 하지 못하면서 중단되었다는 것이다. 이 책을 쓰는 시점에서 iOS와 안드로이드는 모두 Web SQL을 지원하지만, 앞으로의 지원은 중단될 수 있는 가능성이 있다.
IndexedDB는 Web SQL과 localStorage의 중간쯤에 위치하는 객체 저장소이다. localStorage처럼 키-밸류 쌍으로 저장으 ㄹ하지만, 저장되는 아이템은 특정 데이터 타입으로 필드를 지정할 수 있고, 주어진 값을 필드에 가지고 있는 레코드를 요청함으로써 결과를 제한할수도 있다. IndexedDB는 현 시점에서는 iOS와 Android에서 지원되지 않는다.
SQLite는 데이터 로딩을 위해 SQL과 유사한 문법을 사용한다는 점에서 Web SQL과 비슷한 로컬 데이터베이스이다. 브라우저의 표준으로 채택되지는 못했지만, and standardization bodies for first-class support in browsers. 현재 SQLite의 기능 대부분을 지원하는 코르도바 플러그인이 있다.
localStorage와 같이 이런 데이터베이스로부터의 데이터는 다른 앱에서 볼 수는 없지만, 역시 디버깅 도구로 개발자들이 볼 수 있다.
현재 시점에서 Web SQL은 코르도바의 도움을 받아 iOS와 안드로이드를 모두 지원할 수 있는 선택지가 될 수 있고, IndexedDB는 적절한 지원이 없어 곤란하다. 그러나 Web SQL은 2010년 이래로 관리되고 있지 않고 향후에 없어질 수 있기 때문에, 시간이 지나면 점차 IndexedDB쪽으로 기울것이다. 어떤 것이 지원되고 안되고를 확실히 하고 싶다면 http://mng.bz/1UYx의 도큐먼트를 확인해보자. 프로젝트에서 사용하는 코르도바의 버전에 일치하는 도큐먼트를 찾아 확인한다. 버전 정보는 cordova info를 실행해서 알 수 있다. 한편, 다음의 명령 중 하나를 실행해보면 현재 플랫폼에서의 지원여부를 간단히 테스트해볼 수 있다.

alert('WebSQL: ' + ((window.openDatabase) ? 'yes' : 'no'));
alert('IndexedDB: ' + ((window.indexedDB) ? 'yes' : 'no'));

이 명령에 대한 적절한 메세지를 얻으려면 에뮬레이터나 장치에서 실행해야 한다. 그냥 자바스크립트 상단에 넣고 실행하면 위 두옵션에 대한 지원 여부를 알려줄 것이다.

7.5.3 코르도바 플러그인을 이용한 다른 옵션
코르도바는 장치의 추가 기능에 접근할수 있도록 하는 플러그인을 제공한다. 8장에서 좀 더 깊이 플러그인을 살펴볼 것이지만, 저장을 위한 코르도바 저장소 플러그인이 다수 있다는 점은 알아두자.
가능한 방법은 수시로 변하고 있다. 모든 장치를 지원하는 IndexedDB나 WebSQL도 몇 개 있고, SQLite와 같은 다른 저장 시스템을 지원하는 것도 있고, 파일 기반으로 저장하는 것도 있다. 저장소 플러그인은 http://plugins.cordova.io/npm/index.html에서 찾아볼 수 있다.

7.6 다중 플랫폼을 지원하는 하나의 앱 만들기
아이오닉으로 앱을 개발하는 것의 가장 큰 장점은 하나의 앱으로 여러 종류의 디바이스와 플랫폼을 타겟으로 할 수 있다는 점이다. 그러나, 특정 장치나 플랫폼에 대한 설계상으로나 구현상 꼼수가 필요할 때도 있다.
플랫폼의 차이로 인한 다른 경험에 대해서 생각해야 하는 여러가지 상황이 있다. 아이오닉은 코어에 몇 가지 지원을 담고 있다. 예컨대, 안드로이드에서의 탭은 iOS와는 다르게 나타난다. 이유는 아이오닉 개발자들이 탭의 기능은 동일하게 제공하되, 플랫폼 네이티브 스타일에 룩앤필을 맞추었기 때문이다. 탭은 동일하게 작동하지만, 나타나는 모습은 다소 다르다.
플랫폼에 맞추기 위한 방법은 크게 두 가지가 있다. 비주얼을 바꾸거나 작동을 바꾸는 것이다. 살펴보기 앞서 플랫폼에 맞게 적용된 앱을 만들도록 신경써야 하는 이유를 조금만 더 알아보자.

7.6.1 하나의 사이즈로 모두를 맞출 수 없다
앱 개발자라면, 여러분이 개발하기에 쉬운 앱을 만드는 것이 아닌, 여러분의 사용자에 최적화된 앱을 만드는 것에 중점을 둬야 한다. 안드로이드와 iOS에서 완전히 동일한 동작을 하는 앱을 만드는 것이 모든 유저들에게 납득되지는 않을 수 있기에 주의깊게 고민해야 한다. 유저들이 어떤 작동을 하는데 익숙해져 있는 경우들에 대해서는 특히 그렇다.
안드로이드와 iOS는 외형과 조작에 있어서 많은 차이점이 있다. iOS와 안드로이드가 각각의 버전들 사이에도 크게 차이가 날 수 있기 때문에, 앞으로도 이런 양상은 계속될 것이라고 가정할 수 있다. 아이오닉은 각 플랫폼들의 현재 버전들에 대해서 지원을 하고 있고, 모바일 플랫폼이 진화해감에 따라 함께 적응해 나갈 것이다.
기억해야 할 점은 아이오닉의 많은 기능들은 개발자를 향해 있다는 것이다. 즉, 여러분이 만드는 앱이 제대로 작동하고 각각의 플랫폼에서 납득할 만한 형태가 되도록 할 책임은 여러분에게 있다는 것이다. 따라서 이런 차이점들에 대해 친숙해지고자 iOS와 안드로이드의 공식 스타일 가이드를 이해하려고 시간을 들이는 것은 가치가 있다. 그러고 나면 여러분의 앱을 디자인할 때 플랫폼에 최적화된 디자인과 플랫폼에 특화된 디자인을 구성해야할 지를 판단할 수 있게 될 것이다. 공식 스타일 가이드를 찾을 수 있는 곳은 다음과 같다:
* 안드로이드 스타일 가이드 : http://developer.android.com/design/style/index.html
* iOS 스타일 가이드 : https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/

7.6.2 플랫폼이나 디바이스 타입에 맞게 스타일 조정하기
아이오닉은 사용중인 플랫폼이나 디바이스가 어떤 것인지 판단할 수 있는 간단한 방법을 제공하기 때문에, 필요에 따라 앱의 스타일을 적응시킬 수 있다. 무슨 플랫폼인지 결정하기 위해 body 엘리먼트에 여러개의 클래스가 추가되어 있다.
* iOS을 위한 platform-ios
* 안드로이드를 위한 platform-android
* 브라우저를 위한 platform-browser
이 클래스들은 사용하고 있는 플랫폼의 종류에 따른 통찰을 제공한다. 또한 플랫폼의 버전 넘버에 기반한 다른 클래스들도 제공하고 있는데, 예를 들어, platform-ios-ios7과 같은 것이 있다. 때때로 특정 버전을 타켓으로 해야할 때가 있다. version 클래스는 이런 정보를 제공해 준다.
이런 테크닉을 써야할 필요가 있는 경우가 크게 두 가지가 있는데, 플랫폼 종속적인 스타일을 제공하기 위한 경우와 특정 플랫폼에서만 나타나는 버그를 다뤄야 할 때 이다. 대개의 경우에는 플랫폼 종속적인 디자인의 양을 제한하고 싶을 것이다. 늘어날 수록 테스트해야 할 양이 추가되기 때문이다.
이번 절에 대한 코드는 adaptive-style 디렉토리에 있다. 배경 위에 아이오닉 로고가 보이는 단순한 앱이지만, 플랫폼에 따라 배경색이 다르게 보일 것이다(그림 7.4). 관련 템플릿은 다음 리스트를 참고하고, CSS는 리스트 7.7에서 확인할 수 있다.

<< 리스트 시작 >>
  리스트 7.6 적응형 스타일 템플릿 (adaptive-style/www/index.html)
<< 리스트 끝 >>

<< 그림 시작 >>
  body 클래스를 사용하여, 플랫폼에 따라 앱의 배경색을 바꾼다
  (그림 밑의 영문은 별도의 번역이 필요 없음)
  그림 7.4 플랫폼 종속적인 스타일, 안드로이드(왼쪽)과 iOS(오른쪽)
<< 그림 끝 >>

<< 리스트 시작 >>
  리스트 7.7 적응형 CSS 스타일링 (adaptive-style/www/css/style.css)

  iOS에만 적용되는 CSS 셀렉터
  안드로이드에만 적용되는 CSS 셀렉터
<< 리스트 끝 >>

CSS 규칙 앞에 body의 플랫폼 클래스를 붙여주면, 플랫폼에 따라 다른 배경 화면을 볼 수 있다.

7.6.3 플랫폼이나 디바이스에 따라 다른 동작
플랫폼에 따라 앱의 동작도 다르게 할 수 있다. 예를 들어, iOS에서는 액션 시트 컴포넌트를 사용하지만, 안드로이드에서는 팝오버를 사용할 수 있다. 아이오닉은 어떤 플랫폼상에서 작동하는지 감지할 수 있기 때문에, 그에 따라 동작을 수정하면 된다.
ionic.Platform 서비스가 이런 정보를 제공한다. isIOS()와 isAndroid() 같은 메소드들은 각각의 플랫폼이 활성화 되어있느냐에 따르는 불리언 값을 반환하고, platform() 메소드는 현재 플랫폼의 이름을 반환한다.
그림 7.5에 나타난 간단한 예제는 (세 개의 점으로 표시된)더보기 버튼을 눌렀을 때 플랫폼에 따라 다른 행동을 보여준다. iOS로 확인되면 액션 시트를 보여주고, 그렇지 않은 경우에는 팝오버를 보여준다.

<< 그림 시작 >>
  안드로이드에서는 팝오버, iOS에서는 액션시트
  콘트롤러에서 현재 플랫폼을 확인하기 위해 platform 서비스를 사용
  (그림 밑의 영문은 별도의 번역이 필요 없음)

  그림 7.5 플랫폼에 따라 버튼의 동작을 바꿀 수 있다
<< 그림 끝 >>

<< 리스트 시작 >>
  리스트 7.8 플랫폼에 따른 적응된 동작 (adaptie-behavior/www/js/app.js)
  (왼쪽)
  iOS인지 판단하기 위해 ionic.Platform 사용
  (오른쪽)
  콘트롤러를 생성하고 서비스를 주입
  ngClick으로 호출되는 more() 메소드
  iOS라면 더미 버튼을 장착한 액션 시트가 나타남
  그렇지 않은 경우 더미 버튼 버튼을 장착한 팝오버를 보여줌
<< 리스트 끝 >>

예제로 장치가 iOS에서 작동하는지를 확인하는 메소드를 한 개 갖고 있는 콘트롤러를 만들었다. ionic.Platform 서비스는 AngularJS 서비스가 아니기 때문에, 별도로 주입할 필요는 없다. $ionicPlatform 서비스도 있긴 한데, 이것은 코르도바 플러그인고 함께 사용할 용도리고, 현재 플랫폼에 대한 정보를 제공하지 않는다.
플랫폼을 확인하면, 액션 시트를 보여줄 것인지 팝오버를 보여줄 것인지 선택한다. 예제를 위한 마크업은 다음 리스트에 나타나 있다.

<< 리스트 시작 >>
  리스트 7.9 적응형 동작을 위한 템플릿 (adaptive-behavior/www/index.html)

  more() 메소드 호출을 위해 ngClick을 사용하고 팝오버를 위해 이벤트를 전달한다
<< 리스트 끝 >>

ionic.Platform 서비스는 플랫폼에 관한 현재 정보를 제공해준다. 앱의 동작을 변경할 수 있는 메소드도 몇 개 가지고 있는데, 전체 화면으로 실행하게 한다거나 프로그래밍적으로 앱을 종료시킬 수도 있다.

7.7 $ionicConfigProvider로 기본 동작을 수정하기
아이오닉은 몇 가지 기본 동작을 변경할 수 있는 방법을 가지고 있다. 앞서 커스텀 Sass 변수를 이용해서 기본 스타일을 수정하는 법을 살펴봤다. 같은 개념으로 트랜지션 타입(뷰 사이를 이동할 때 적용되는 효과)이라던가 네비게이션 바의 배치등을 바꿀 수있다.
아이오닉의 기본값은 구동되고 있는 현재의 플랫폼에 맞추도록 설계되어 있다. 예컨대, 네비게이션 바의 타이틀 배치가 안드로이드에서는 왼쪽 정렬, iOS에서는 중앙 정렬로 각각의 스타일 가이드라인을 맞추고 있다. 그러나, 플랫폼의 종류에 관계 없이 타이틀을 동일하게 보이도록 강제할 수 있다.
설정 가능한 항목에 대한 전체 목록은 도큐먼트에 나타나 있다. 이번 예제에서는 탭 스타일의 기본값을 수정하여, 항상 스트라이프 형태로 하단에 표시되도록 해보겠다. 모든 설정 가능한 옵션은 예제에서 보는 바와 같은 방식으로 수정될 수 있다. 그림 7.6은 갱신된 탭 모습을 보여주고 있다.

<< 그림 시작 >>
  $ionicConfigProvider로 탭의 기본 표현 방식을 오버라이딩 한다.
  탭은 모든 플랫폼에서 스트라이프 스타일로 아래에 나타난다.

  그림 7.6 아이오닉의 기본 탭 오버라이딩
<< 그림 끝 >>

설정 기본값은 이전의 예제에서 상태를 선언했었던, 모듈의 config() 메소드 안에서 설정된다. 다음 리스트에서는 탭에 대한 기본값을 수정하고 있다.

<< 리스트 시작 >>
  리스트 7.10 기본 설정 갱신하기 (config/www/js/app.js)

  $ionicConfigProvider 주입
  tabs 설정을 변경, 메소드 체인으로 호출할 수 있다
<< 리스트 끝 >>

$ionicConfigProvider는 아이오닉 설정을 위한 특별한 서비스 프로바이더인데, 메소드 호출시 인자를 전달해서 값을 갱신할 수 있다. 한편 예제에서는 두 개의 탭 메소드를 체인 형식으로 호출했다. 만일 탭에 관련되어 있지 않은 다른 부분에 대한 값을 수정하게 되면, 메소드 체인은 작동하지 않을 것이다. 위의 코드는 탭을 스트라이프로 설정하고 하단에 위치시킨다.
이런 설정은 CSS 클래스를 사용해서 탭 구현 방식을 오버라이딩 할 수도 있다. 탭 표현 방식과 같은 것은 꼭 config()에서 바꿀 필요는 없는 것이, 탭에 CSS 클래스를 설정해서 표현 방식을 수정할 수도 있기 때문이다. 그러나, 어떤 설정들은 아무데서나 바꿀수 없는 경우도 있다. 뷰의 정보를 캐싱하는 것에 관한 것이 그 예다.

7.8 요약
이번 장은 아이오닉 앱을 만들기 위한 추가적인 도구와 관점을 다루었다. 큰 주제 위주로 복습해보자:
* Sass를 사용해서 아이오닉의 앱 스타일링을 커스터마이징 하는 방법과 아이오닉이 Gulp를 이용하는 프로세스 만들기
* 이벤트 디렉티브와 $ionicGesture 서비스로 이벤트와 제스쳐 지원하기
* 앱 데이터의 영속성을 유지하기 위한 locaStorage와 Web SQL, IndexedDB 같은 대안들
* 플랫폼에 특화된 경험을 제공하기 위해 앱이 구동되고 있는 디바이스의 플랫폼에 기반하여 동작과 표현 방식을 바꾸기
* 글로벌 파라미터를 설정해서 아이오닉의 기본 설정값을 수정하기
다음장에서는 코드도바에 대해서 좀 더 깊이 파보려고 하는데, 아이오닉 앱을 위한 플러그인의 에코시스템을 활용하는 방법을 배우게 될 것이다.
