9. 미리보기, 디버깅 그리고 테스트 자동화

<< 상자 시작 >>
  이 장에서 다룰 내용
  * 아이오닉 뷰와 아이오닉 랩으로 앱 미리보기
  * iOS와 안드로이드의 장치, 에뮬레이터에서 디버깅하기
  * 앱 자동화 테스트 작성하기
<< 상자 끝 >>

준비하시라. 이 장에서는 미리보기, 디버깅 그리고 적절히 테스트하는 방법에 대해 많은 내용을 다룰 것이다. 이번 장의 목표는 앱의 품질을 더 좋게 관리하는 방법을 돕는데에 있다. 그간 개발해온 프로젝트가 시간이 흐를수록 점점 더 복잡해지고, 유지하기가 까다로워지는 경향이 있음을 아마 느꼈을지도 모르겠다. 이런 식의 흐름을 막기 위해서는 개발자의 작업과 규율이 필요하다. 이번 장에서는 그런 작업을 돕는 몇 가지 도구에 대해서 이야기 하려고 한다.

9.1 미리보기, 디버깅 그리고 테스트
본격적으로 뛰어들기 전에 일단 세가지 용어-미리보기, 디버깅 그리고 테스트-를 먼저 명확히 이해하고 넘어가자. 차이점을 그림 9.1에 표시해 보았다.

<< 그림 시작 >>
  (왼쪽)
  미리보기
  아이오닉 뷰(Ionic View):
  앱스토어에 출시하지 않고 다른 사람에게 앱을 쉽게 공유하기
  아이오닉 랩(Ionic Lab):
  브라우저에서 iOS와 안드로이드에서의 모습을 빠르게 훑어보기

  (가운데)
  디버깅
  장치에서 디버깅:
  USB로 장치를 연결하면, 웹 페이지로 개발할 때 사용했던 것과 같은 브라우저 개발자 도구를 컴퓨터에서 열 수 있다.

  (테스트)
  단위 테스트:
  격리된 환경에서 앱 코드의 부분을 실행하는 테스트 세트를 자동으로 실행하고, 각 '유닛'이 기대한 대로 동작함을 확인한다.
  테스트 작성
  앱 코드
  테스트를 로딩하고, 브라우저로 보낸다
  브라우저가 테스트를 실행한다
  통합 테스트:
  브라우저에서 전체 앱을 실행하는 테스트 세트를 실행하고, 의도한 대로 작동함을 확인하기 위해 사용자의 액션을 시뮬레이션한다.
  테스트 작성
  테스트를 로딩하고 브라우저로 보낸다.
  테스트가 브라우저에서 실행된다.

  그림 9.1 미리보기, 디버깅 그리고 테스트의 핵심 요약
<< 그림 끝 >>

미리보기는 장치나 에뮬레이터에서 앱을 실행하고 조작해 보는 것을 의미한다. 미리보기는 개발자가 앱이 어떻게 보이고, 기대한 대로 작동하는지 눈으로 확인하는 일반적인 방법이다. 혼자서 미리보기를 점검하는 것은 꽤 골치가 아플수 있는데, 이는 개발자가 직접 실행하고 앱 전체를 조작해야 하는 프로세스 때문이다. 앱이 커지고 지원하는 플랫폼이 늘어날수록 수동으로 미리보기를 해보면서 품질을 검증하는 작업의 난이도가 기하급수적으로 증가한다. 앞으로 아이오닉에 탑재된 몇 가지 추가적인 미리보기 기법을 살펴볼 것이다.
디버깅은 버그의 원인을 분석하고 찾아내는 기술이다. 1장에서 언급했던 아이오닉의 스택을 이루는 기술과 도구들을 상기해보자. 디버깅은 오류가 어디서 일어나는지 밝혀내는 행위이다. 어떤 버그들은 여러분의 코드와 관련이 없고, 손상된 파일 같은 것이 원인일 수도 있다. 요즘에는 많은 버그가 에러 메세지를 온라인에서 검색하거나 이를 다루는 블로그나 포럼의 글을 찾는 방식으로 해결된다. 버그의 원인을 추적하는데 도움이 되는 몇몇 도구와 테크닉에 대해서 논의할 것이다.
자동화 된 테스트는 작성한 코드가 의도한 동작을 하는지 확인할 수 있는 코드를 작성하는 작업이다. 컴퓨터는 반복 작업을 수행하기에 아주 적절한 기계이므로, 테스팅 도구로 앱을 로드해서 원하는 대로 작동하는지 점검하는 코드를 실행한다. 자동화된 테스트를 위해서 테스트 코드를 작성하고, 테스트 도구는 이 코드를 불러와서 특정 작업을 수행하는지 확인한다. 수동 테스트도 방법이긴 하지만, 자동화된 테스트가 상용 앱 품질 관리를 위해 훨씬 더 실용적인 방법이다.

9.1.1 왜 테스트가 중요한가?
여러분이 앱 스토어를 통해 판매하려고 한 중간 정도 사이즈의 (내용은 무엇이든 좋다)앱을 갖고 있다고 가정해 보자. 과거에 고칠려고 생각했었던 문제를 경험한 수많은 유저들의 피드백을 받게 될 것이다. 앱의 새 버전을 출시하기 전에 이 버그가 수정되었음을 빨리 확인할 수 있어야 한다. 테스트를 작성하는 것은 버그가 수정되었는지 확인하는 가장 좋은 방법이다. 왜냐하면, 출시때마다 버그를 수동으로 확인할 필요 없이 반복해서 테스트 할 수 있기 때문이다.
대규모의 애플리케이션을 개발해 본적이 없는 웹 개발자라면, 테스트 작성이 쓸데없이 과하거나 구현해야 할게 너무 많아 보일지도 모른다. 프로페셔널한 코드를 위해, 고품질의 앱은 그 품질을을 유지하기 위한 테스트 코드를 포함하고 있어야 한다. 모든 앱은 테스트의 혜택을 받기 때문에, 여러분은 개발 단계에서 항상 테스트 작성의 우선 순위를 높이기 위해 애를 써야 한다. 테스팅은 초반에 비용이 좀 들지만, 길게 보면 언제나 효과를 발한다.

9.2 이번 장 예제 설정하기
이 장의 예제는 6장의 날씨 앱을 기초로 하고 있는데, 이번에 몇 가지 기능을 추가하고 자동화된 테스트를 포함시키려고 한다. 이번 장의 예제는 git clone 명령으로 얻거나  https://github.com/ionic-in-action/chapter9/archive/master.zip을 통해 다운로드 할 수 있다.

git clone https://github.com/ionic-in-action/chapter9

복제를 하거나 다운로드 해서 압축을 풀었다면, 프로젝트 디렉토리로 이동해서 플러그인과 최소한 하나의 플랫폼을 추가한다. ionic start 명령을 사용하는 대신 예제를 체크아웃 했기 때문에, ionic start가 알아서 설정해주는 플러그인을 직접 추가해줘야 한다.

ionic plugin add org.apache.cordova.console
ionic plugin add org.apache.cordova.device
ionic plugin add com.ionic.keyboard
ionic platform add [ios/android]

이제 6장에서의 마지막 버전과 동일해진 프로젝트에 이번 장을 진행하면서 필요하게 될 테스트 파일을 추가하면 된다.

9.3 앱 미리보기를 위한 다른 방법들
아직 다루지 않았던 앱 미리보기를 위한 유용한 방법이 몇 가지 있는데, 각각의 상황에 따라 유용하다. 아이오닉 팀은 개발자를 위한 기능을 지속적으로 만들고 있는데, 이것은 그들이 가장 사랑하는 것들 중 하나이다.
ionic serve, ionic emulate나 ionic run을 쓰는 방법 대신 두 가지 다른 방법을 살펴 볼 것이다. 첫 번째는 아이오닉 랩(Ionic Lab)으로 iOS와 안드로이드를 나란히 두고 미리보기를 할 수 있다. 두 번째는 아이오닉 뷰(Ionic View)를 이용하면, 아이오닉 플랫폼으로 앱을 업로드해서 별도의 앱 스토어 등록 과정 없이도 다른 사람이 다운로드해서 살펴볼 수 있게 할 수 있다.

9.3.1 아이오닉 랩
만일, 여러분이 만든 앱이 iOS와 안드로이드에서 나타나는 모습을 동시에 봐야할 필요가 있다면 아이오닉 CLI의 랩 기능을 써야할 때이다. 이 방법은 iOS 미리보기를 할 때라도 맥을 필요로 하지 않는다. 그러나, 실제 에뮬레이터는 아니며 오로지 겉모습만 보고 비교할 수 있다. 사실 이미 알고 있는 ionic serve 명령어의 한 갈래인데, 브라우저에서 열면 두 개의 버전이 실행된 모습을 볼 수 있다. 그림 9.2를 보면, 5장의 예제가 아이오닉 랩을 통해 어떻게 나타나는지 볼 수 있다. 이를 통해, 장치에 따라 인터페이스가 표현되는 방식에 연관된 버그를 잡는데 도움을 받을 수 있다.
그림 9.2의 왼쪽에는 iOS 버전이 보이는데 탭이 하단에 나타나는 반면, 오른쪽에서는 상단에 나타난다. 플랫폼에 따라 앱이 어떻게 달라 보이는지 빠르게 확인할 수 있다. 아이오닉 랩을 이용하려면, serve 명령어에 --lab 플래그를 붙인다.

$ ionic serve --lab

자동으로 두 가지 버전을 표시하는 새 브라우저 윈도우가 열릴 것이다. 7장에서 우리는 플랫폼의 스타일 가이드를 고려해서 앱을 디자인하는 것이 얼마나 중요한지 이야기했었는데, 아이오닉 랩이 이를 빠르게 확인할 수 있는 멋진 방법이 된다. 브라우저 내에서 앱을 표시하기 때문에 여전히 제약사항은 있기 때문에, 몇몇 코르도바 기능들은 에뮬레이터나 실제 장치가 아니라는 이유로 동작하지 않을 것이다.

<< 그림 시작 >>
  버튼이 왼쪽에 나타난다.
  버튼이 오른쪽에 나타난다
  탭이 하단에 위치해 있다.
  탭이 상단에 위치해 있다.

  그림 9.2 아이오닉 랩은 플랫폼간 표현 차이를 볼 수 있도록 iOS와 안드로이드의 모습을 동시에 보여준다
<< 그림 끝 >>

9.3.2 아이오닉 뷰
아이오닉에는 아이오닉 개발자들의 삶을 더 편하게 만들기 위한 기능을 플랫폼 레벨에서 갖추고 있다. 아이오닉 뷰(http://view.ionic.io/)는 아이오닉으로 개발한 앱을 미리보기 위해 앱스토어를 통해 설치할 수 있는 모바일 앱이다. 즉, 이 앱을 통해서 여러분의 앱을 앱스토어에 실제로 출시하지 않고도 고객이나 베타 테스터가 접해 볼 수 있음을 의미한다. 예를들어, 아이오닉 뷰를 사용하여 개발 현황 보고 미팅 때 상사에게 앱을 보여줄 수도 있다. 앱을 개발함에 있어서 직접적인 도움을 주는 도구는 아니지만, 먼저 스토어에 올리기 전에 다른 사람들에게 앱을 보여주기 위해 주로 사용할 수 있는 방법이 된다.
아이오닉 뷰를 이용하려면, 아이오닉 계정을 만들어야 한다. https://apps.ionic.io/signup에서 무료로 계정을 만들수 있다. 그 다음 아래의 명령으로 로그인 한다.

$ ionic login

로그인 상세를 채우고 인증을 받으면, 여러분의 앱을 무엇이든 업로드 해서 아이오닉 뷰를 통해 공유할 수 있다.
터미널에서 업로드 하고 싶은 프로젝트 디렉토리로 이동한다. 거기서 앱을 업로드하기 위한 명령을 실행하면, 아이오닉이 등록을 수행하고 여러분의 계정으로 업로드 할 것이다.

$ ionic upload

이 명령어는 유효한 아이오닉 프로젝트를 찾아서 아이오닉 플랫폼 서버로 전송한다. 앱마다 고유한 ID를 만들고 여러분의 계정에 추가해 줌으로써 공유할 수 있게 된다. https://apps.ionic.io/apps에서 업로드된 앱을 조회하고 관리할 수 있다.
업로드를 마치면, 장치에 설치되어 있는 아이오닉 뷰를 실행했을 때 업로드했던 앱 목록으로 나타나야 한다. 앱을 하나 골라 탭하면, 아이오닉 뷰가 다운로드해서 기기에 실행을 시킨다.
앱을 탭하여 선택한 후 확인해 보라. 앱이 전체 화면으로 실행되기 때문에, 앱에서 나가려면 세 손가락으로 쓸어 내려야 한다.

<< 그림 시작 >>
  그림 9.3 두 개의 예제 앱이 업로드 된 상태의 아이오닉 뷰 앱
<< 그림 끝 >>

아이오닉 뷰의 제약 조건
아이오닉 뷰에는 몇 가지 제약이 존재한다. 플랫폼의 구조에 기인한 문제로, 몇 가지의 코르도바 플러그인만 지원된다. http://docs.ionic.io/docs/view-usage의 문서에서 지원되는 플러그인 목록을 볼 수 있다. 몇몇 플러그인은 보안 관련 문제로 지원되지 않을 수 있다.
또한 디버깅 정보를 지원하지 않는다. 상품화된 앱은 보안의 이유로 디버깅의 여지가 더욱 제한된다. 디버깅을 하려면 앱과 컴퓨터가 커뮤니케이션을 해야 하는데, 내가 만들지 않은 앱이 내 컴퓨터에 직접 접근할 수 있는 것은 여러분도 원하지 않을 것이다. 몇 가지 기능을 추가함으로써 디버깅 할 수 있는 방법을 배우려면 아이오닉 뷰 도큐먼트를 읽어보도록 하자.

<< 그림 시작 >>
  브라우저는 USB를 통해 연결된 장치를 인식한다. 이 때문에 개발자 도구를 열어 디바이스 상의 웹 뷰를 살펴볼 수 있다.

  그림 9.4 브라우저 개발자 도구가 연결된 장치의 웹 뷰 디버깅을 지원하는 방법
<< 그림 끝 >>

9.4 장치 디버깅
지금까지는 개발과 디버깅을 위해 컴퓨터상의 브라우저를 사용해 왔다. 그러나, 때로는 장치에서 앱을 띄워 디버깅을 할 필요가 생기기도 한다. 네이티브 앱으로 개발하고 있는 것이 아니기 때문에 지금껏 사용해 왔던 브라우저 디버깅 툴을 그래도 쓸수 있으면 멋질 것이다. 좋은 소식은.. 방법이 있다는 것이다!
안드로이드와 iOS는 에뮬레이터나 연결된 장치에서 브라우저 개발자 툴로 디버깅을 할 수 있도록 허용한다. 본질적으로는 크롬이나 사파리가 장치에 연결되어서 앱 안의 웹 뷰를 (개발자 도구를 쓸 수 있는)브라우저 윈도우로 간주하는 것이다(그림 9.4).
2장에서 우리는 CLI를 사용해서 앱을 에뮬레이트 하거나 장치 위에서 구동시키는 방법을 다뤘었는데, 그 중에 터미널 창으로 콘솔 메세지를 표시하는 옵션이 있었다. 다음의 명령은 iOS에 해당하는 것인데, 안드로이드를 에뮬레이트하라면 ios를 android로 바꾸면 된다.

$ ionic emulate ios -l -c

여기서의 문제는 브라우저 콘솔에 찍히는 자바스크립트 로그만 볼 수 있다는 것이다. 브라우저 콘솔에서 보통 보는게 자바스크립트 오류를 확인하는 정도였으면 괜찮지만, DOM을 살펴보거나 엘리먼트의 스타일까지 확인할 수는 없다. 개발자 도구를 완전히 사용할 수 있게 되면 앱을 다각도로 분석할 수 있게 된다.
디버깅은 여러분이 개발했고 직접 장치에 심은 앱에 대해서만 가능하다. 앱스토어를 통해 설치한 앱을 디버깅 할수는 없다.

9.4.1 안드로이드 장치 디버깅
안드로이드 원격 디버깅은 사용하기 쉬운 편이지만, 우선 장치의 디버깅 옵션을 켜야만 한다. 아직 이 작업을 하지 않았다면 2.2 절의 내용을 복습하기 바란다. 그런 후에 디버깅에 가장 적합한 브라우저를 설정하고 디버깅 도구를 구동시킬 수 있다.

구글 크롬 카나리아 브라우저 설정
안드로이드 개발을 위해서 구글 크롬 카나리아 브라우저를 사용할 것을 추천한다. 크롬 카나리아는 크롬의 최첨단 버전으로 개발자들이 테스트 할 신규 기능이 대중들이 사용할 버전에 적용되기 전에 먼저 변경이 적용된다. 안드로이드 개발 문서는 앱을 연결하고 디버깅 할 때 최선의 결과를 얻으려면 컴퓨터의 브라우저가 장치에 설치된 것보다 향상된 것을 써야 한다고 언급하고 있다. 크롬 카나리아가 그에 부합하는 것인데, 계속해서 업데이트 되는 베타 버전이기 때문이다. https://www.google.com/intl/en/chrome/browser/canary.html에서 다운로드 할 수 있다.
장치에 연결되면, 크롬 카나리아를 열고 chrome://inspect라는 주소로 이동한다. 주소창에 입력 하면 그림 9.5와 같은 화면을 보게 될 것이다. 아무런 장치도 찾을 수 없다면, 목록이 비어 있을 것이다. 장치가 실행되고 있기 때문에 inspect 링크를 클릭해서 앱을 위한 개발자 도구를 열수 있다. 여기서 스타일을 바꿀 수도, 자바스크립트 콘솔 로그를 조회할 수도 있고, API 요청과 같은 네트워크 호출도 볼 수 있으며, 개발자 도구로 평소에 할 수 있었던 모든 것이 가능하다.
안드로이드 에뮬레이터는 이 기법으로 디버깅을 할 수 없다. 그러나, Genymotion이라는 다른 도구가 있는데, 에뮬레이터처럼 동작하지만 실제로는 연결된 장치인 것처럼 컴퓨터에 나타난다. https://www.genymotion.com에서 개인 프로젝트를 선택하면 무료로 다운로드 할 수 있는데, https://www.virtualbox.org에서 VirtualBox도 받아야 한다. 앱을 Genymotion으로 설치하고 싶다면, 그냥 Genymotion을 연상태에서 ionic run android 명령을 실행하면 된다. 에뮬레이터로 실행하면 Genymotion을 사용하지 않을 것이다.
이것이 안드로이드 장치에 디버깅 도구가 접근하기 위해 해야 할 작업의 전부이다.

9.4.2 iOS 장치, 에뮬레이터 디버깅
iOS에서 디버깅하는 것도 안드로이드와 거의 비슷한데, 사파리를 사용한다는 점이 다르다. 먼저 장치에서 사파리를 통해 디버깅할 수 있도록 설정해야 한다. iOS 에뮬레이터의 경우 기본으로 설정되어 있지만, 그래도 확인은 해봐야 한다. 장치에서 설정하려면 설정 앱을 켠다. 사파리 설정을 열고, 아래쪽의 고급 옵션을 선택한다. 웹 속성 옵션을 켜면, 사파리로 웹뷰의 디버깅을 할 수 있게 된다. 그림 9.6에 이 과정이 나타나있다.

<< 그림 시작 >>
  연결된 장치를 보기 위해 chrome://inspect로 이동한다. 장치가 연결되어 있어야 한다.
  해당 장치를 위한 개발자 도구를 열기위해 Inspect 링크를 클릭한다.

  그림 9.5 연결된 안드로이드 장치에 개발자 도구 연결하기
<< 그림 끝 >>

<< 그림 시작 >>
  설정앱을 열고 사파리를 선택
  하단의 고급 옵션을 선택
  디버깅을 활성화 하기 위해 웹속성을 켬

  그림 9.6 모바일 사파리의 웹속성 옵션 켜기
<< 그림 끝 >>

이제 컴퓨터에서 사파리를 열어보자. 메뉴 바에서 개발자용 메뉴가 보이지 않는다면, 사파리의 개발자 설정을 켜줘야 한다. 환경설정을 열고 고급 탭을 선택한다. 고급 탭 하단에 '메뉴 막대에서 개발자용 메뉴 보기' 체크 박스가 있다. 체크하고 창을 닫는다. 이제 상단 메뉴에서 개발자용 메뉴가 보여야 한다. 이 과정은 그림 9.7에 나타나 있다.
이제 iOS에서 앱을 디버깅할 수 있게 되었다. 먼저 앱을 에뮬레이터나 장치에서 실행시킨다. 이번 장 예제를 에뮬레이터에서 실행하면, 개발자 도구에서 스크린샷을 볼 수 있을 것이다.

<< 그림 시작 >>
  사파리를 연다. 개발자용 메뉴가 안보이면, 설정 패널을 연다.
  고급 탭을 선택하고, 하단의 '메뉴 막대에서 개발자용 메뉴 보기'를 클릭한다.
  개발자용 메뉴가 이제 메뉴바에서 보일 것이다.

  그림 9.7 개발자 도구를 실행하기 위해 개발자용 메뉴 켜기
<< 그림 끝 >>

<< 그림 시작 >>
  연결된 장치나 에뮬레이터가 실행될 때 사파리를 연다. 개발자용 메뉴에서 장치와 앱을 선택한다.
  새 웹 인스펙터 창이 뜨면, 앱을 조작하면서 분석할 수 있다.

  그림 9.8 에뮬레이터나 장치에 연결해서 사파리 개발자 도구를 구동시키는 방법
<< 그림 끝 >>

앱이 실행되면 개발자용 메뉴를 연다. 메뉴에서 장치나 에뮬레이터의 목록을 볼 수 있을텐데, 그림 9.8처럼 해당 장치의 index.html 옵션을 선택한다. 웹 인스펙터창이 새로 뜨고, 여기에서 DOM 항목을 선택해서 속성이나 스타일, 콘텐츠를 확인할 수 있다.
이런 식으로 사파리로 디버깅을 실행하는 것의 가장 큰 문제는 웹 인스펙터를 열기 전에 장치나 에뮬레이터에서 앱을 먼저 실행해야 한다는 것이다. 다시 말해 웹 인스펙터는 앱이 실행되기 전에 먼저 열 수 없다. 앱이 로딩되는 순간에 버그가 있거나 오류가 있을 때, 아직 열리지 않은 웹 인스펙터로는 정보를 얻을 수 없다. 이런 경우에는 로딩 시 자바스크립트 코드로 얼럿을 띄우는 식의 꼼수를 써야 한다.
여기까지 iOS 에뮬레이터와 장치에 디버깅 설정을 하는 방법을 설명했다. 이제 자동화된 테스트 설정을 파보자.

9.5 테스트 자동화
테스트는 앱이 기대하는 대로 동작하는지 확인하는 작업이다. 지금까지 우리는 만든 앱을 그냥 미리보기로 실행한 후 화면 여기저기를 탭하면서 직접 테스트를 해왔다. 이런 방식은 모든 플랫폼에 대해 출시할 때마다 모든 기능을 직접 테스트하기 때문에, 앱의 규모가 너무 커지기 전까지만 가능한 방식이다.
이제 개발 주기에 앱을 수정할 때마다 도와줄 자동화된 테스트를 사용할 것이다. 고객들이 요청한 신규 기능을 적용하거나 디버깅을 하는 중에 찾아낸 버그를 수정할 수도 있겠지만, 자동화된 테스트를 사용하면 앱이 기능을 제대로 수행하는지 빠르게 확인할 수 있게 된다.
여기서 배우게 될 것은 테스트 자동화로써 앱이 의도하는 대로 작동하는지 여부를 프로그램으로 확인할 수 있는 코드를 작성하는 것이다. 제대로 적용하면, 테스트가 수 초 이내로 확인하기 때문에 개발자 어깨 위에 놓인 짐을 한결 덜 수 있게 된다. 팀 단위로 작업을 하는 상황에서는 테스트 수행을 통해 내가 다른 팀원들이 작성한 코드를 망가뜨리지 않았음을 확인할 수 있다. 테스트를 작성해야 하는 좋은 이유는 수도 없이 많은데, 그렇다면 왜 어떤 프로젝트들은 이를 사용하지 않는 것일까?
간단히 살펴보자면, 테스트를 작성하는 것이 처음에는 도전적인 주제가 될 수 있다. 테스트 자체도 코드이기 때문에, 여러분이 직접 테스트 코드를 작성해야 한다. 개발자들은 테스트 자동화를 배우고 작성하는 것보다 자신이 직접 테스트하는게 더 빠를것이라고 생각할지도 모른다. 그러나 장기적 관점에서 보면 앱 안정성을 유지하고, 뭔가 망가뜨릴지도 모른다는 공포에서 벗어나 쉽게 개발하고, 팀원 간의 코드가 충돌이 나는 것을 막을 수 있다는 점에서 테스트 자동화가 더 고려해볼 만하다.
자동화된 테스트에는 두 가지 형태가 있다. 단위 테스트와 통합 테스트(종단간 테스트라고도 부른다)가 그것이다. 사용할 테스트 도구는 AngularJS에 연동되는 것으로 우리가 개발하는 앱이 AngularJS에 기반히기 때문이다.
단위 테스트는 서비스나 콘트롤러와 같은 코드의 각 부분을 테스트하기에 최적인데, 단위 테스트 자체가 개개의 함수에 대해서 원했던 값이 반환되는지 확인하는데에 맞춰 설계되었기 때문이다.
통합 테스트는 목록내 아이템을 탭해서 상세 뷰로 이동하는 것처럼 사용자의 행동을 흉내내서 앱 전체를 테스트하도록 설계된 것으로, 인터페이스가 기대한 응답을 주는지 확인하는데 목적이 있다. 각 테스트에 대한 뉘앙스를 좀 더 깊이 볼 것이지만, 대부분은 앱의 경우 두 가지 테스트 모두 가치가 있다.
우선 테스트를 작성하는 기본부터 시작할 것이다. 이번 절이 끝날때 쯤이면 테스트를 작성할 수 있게 되고, 테스트의 세계로 더 깊이 들어가야겠다는 용기가 생길것이다.

9.5.1 재스민과 카르마로 단위 테스트 하기
단위 테스트는 작성한 코드가 의도한 대로 실행하는지 확인하기 위해 자동화된 테스트이다. 스코프의 메소드와 같이 애플리케이션의 작은 부분들을 테스트 하면서 올바른 결과를 반환하는지 확인한다.
예컨대, 좋아하는 지도 앱을 생각해 보자. 아마도 그 앱은 위도와 경도 값을 받아 두 지점 사이의 거리를 계산하는 메소드를 가지고 있을 것이다. 이런 경우에는 여러 가지 다른 값(심지어 유효하지 않은 값도 될 수 있다)을 함수에 넘겨서 기대한 결과가 나오는지 확인하는 테스트 세트를 작성하는 것이 좋을 것이다. 다음에 이 개념을 테스트하기 위해 작성된 가상의 샘플 테스트를 나타내었다.

<< 코드 시작 >>
  테스트에 사용할 두 쌍의 위도, 경도 값을 생성
  mapCalculate() 메소드가 유효한 값에 대해 기대한 값을 반환하는지 테스트
  mapCalculate() 메소드가 유효하지 않은 값을 처리하는지 테스트
<< 코드 끝 >>

단위 테스트는 앱의 작은 조각들이 의도한 대로 작동하는지 검증하기 위한 최고의 방법이다. 여러분이 단위 테스트를 실행하고, 모든 메소드가 예상한대로 동작하고 있음을 확신하고 있다면, 이미 존재하는 기능들이 깨질지도 모른다는 두려움 없이 애플리케이션의 다른 부분들을 쉽게 고칠 수 있게 된다. 필자의 경우 테스트 없이는 시간이 흐르면서 앱을 유지하기가 매우 어려워 진다는 사실을 뼈져리게 배웠다.
단위 테스트를 작성하기 위한 테스트 프레임워크로써 재스민(http://jasmine.github.io/)을 사용하고, 이를 실행할 도구로 카르마(http://karma-runner.github.io/)를 쓰려고 한다. 재스민은 테스팅에 막 입문하는 개발자를 위한 가장 보편적인 선택지라 할 수 있고, 아이오닉과 AngularJS 프로젝트에서도 주요 테스팅 프레임워크로 사용되는 것이다. 그림 9.9에서 볼 수 있듯이 카르마는 테스팅 프레임워크(이 경우에는 재스민)에 연결해서 모든 테스트 코드와 애플리케이션 코드를 브라우저로 로딩한 후, 브라우저 내에서(이 경우에는 크롬) 실행시킨다. 자바스크립트가 브라우저에서 실행되기 때문에 재스민 테스트도 브라우저에서 실행된다.
일단 재스민과 카르마를 설치한 후, 6장의 날씨 앱을 가지고 단위 테스트를 작성해 보겠다.

<< 그림 시작 >>
  1. 카르마 시작
  2. 카르마가 소스와 테스트 파일을 로드
  3. 실행을 위해 브라우저로 전송
  4. 테스트 결과를 수신

  그림 9.9 단위 테스트 도구 카르마와 재스민이 단위 테스트를 실행하는 방법
<< 그림 끝 >>

카르마, 재스민 설정
카르마부터 설치할 것인데, 이 작업은 재스민 설치도 도와준다. 카르마는 재스민과 크롬을 플러그인으로 가지고 있어서 코어 카르마 도구에 추가로 설치할 수 있다. 터미널 창을 열고, 이번 장 시작에 설정했던 프로젝트 디렉토리로 이동한 후 도구 설치를 위한 명령을 실행한다.

$ npm install --save-dev karma karma-jasmine karma-chrome-launcher
$ npm install -g karma-cli

첫 번째 줄은 카르마, 재스민 플러그인과 크롬 플러그인을 프로젝트에 추가하되, 개발 의존적인(development dependencies) 상태로 저장한다. 두 번째 줄은 카르마를 전역으로 추가해서 명령 줄에서 쉽게 실행할 수 있도록 한다.
카르마가 실행되기 전에 뭘 해야할 지 알 수 있도록 설정 파일을 추가해줘야 한다. 카르마는 HTML 파일을 로딩하는 대신 여러분이 지정한 자바스크립트 파일들만 실행하고 페이지를 로딩시킨다(다음절에 이 작업을 할 것이다). 프로젝트 루트에 karma.conf.js라는 새 파일을 만들고 다음 리스트의 코드를 추가한다.

<< 리스트 시작 >>
  리스트 9.1 카르마 설정 파일 (karma.conf.js)

  (왼쪽)
  카르마에게 앱에 포함했던 파일을 로드하라고 지시
  테스트 작성을 도와줄 angular-mock 파일 추가
  (오른쪽)
  재스민을 사용하겠다고 선언
  앱과 테스트 파일을 매칭시키기 위해 글롭(glob) 패턴 사용
  progress 레포터 옵션 사용
  테스트를 크롬에서 실행
<< 리스트 끝 >>

이 설정이 테스트를 위해 사용할 것이다. 사용하려는 테스트 프레임워크를 선언하고(여기서는 재스민), 카르마에 포함시켜야 할 파일을 지정한다. 카르마는 이 파일들을 브라우저(여기서는 크롬)로 로딩한 후, 검색된 모든 테스트를 실행한다. 결과는 콘솔로 보고되는데, 파일로 출력하도록 설정할 수도 있다(HTML이나 XML 등, 몇 가지 파일 타입을 지원한다). 이제 테스트를 작성해서 실행할 수 있다. 앱이 실행되기 위해 필요한 파일들은 무엇이든지 files 목록에 포함시킬 수 있다(위 코드의 Moment.js 라이브러리의 경우를 참고하라).

Chance 필터를 위한 단위 테스트 작성
재스민은 행위 주도 개발(BDD: Behavior-driven development) 프레임워크이다. 어쩌면, 이미 여러분은 여러 가지 애자일 개발 개념에 친숙할지도 모르겠다. 주요 개념은 소프트웨어 개발 프로세스에서 기술팀과 관리팀 사이의 간극을 조화롭게 버무리는 것이다. 테스트를 작성할 때, 되어야 하는 기능(it)을 설명하는 목록을 기술(describe)하게 될 것이다. 괄호로 굳이 원문을 써놓은 이유는 실제 테스트 작성시에 사용하는 문법이기도 하기 때문이다.

<< 글상자 시작 >>
  재스민과 다른 테스트 프레임워크들

  재스민은 매우 강력한 테스팅 프레임워크이지만, 유일한 것은 아니다. 몇 가지 다른 예로 모카(Mocha), QUnit과 Unit.js가 있다. 자바스크립트의 세계에서는 새로운 프레임워크가 수시로 생겨나기 때문에 다른 새로운 옵션들에 대해서도 알아두는 게 좋다.
  무튼, 원하는 테스팅 프레임워크를 쓸 수 있어야 한다. 인기가 많은 것일 수록 지원을 잘 받을 수 있다. 재스민은 AngularJS 1.X 버전 프로젝트에서 사용되는 테스팅 프레임워크이기에 테스팅을 첨 해보는 사람에게는 좋은 선택이다.
  개인적으로는 재스민 사용을 가장 즐기지만, 모카도 자주 사용하고 있는 또 하나의 프레임워크이다. 재스민은 테스팅에 필요한 대부분을 지원하지만, 모카는 다소 기능이 단편적이고 어떤 일을 위해서는 추가적인 도구를 필요로 한다. 재스민이 여러분의 필요를 충족시키지 못하거나, 다른 프레임워크로 더 많은 경험을 쌓아야 하는 것이 아니라면, 아이오닉과 AngularJS 앱에서 사용하고 있는 재스민을 추천한다.
<< 글상자 끝 >>

필자의 생각에 뭔가를 시작하는 가장 쉬운 방법은 몇 가지 예제를 짜보는 것이라고 본다. 이번에 작성할 첫 번째 테스트는 decimal 값을 받아 0에서 100사이의 퍼센티지 값으로 근사한 후 가까운 10단위의 수로 변환하는 Chance 필터를 위한 것이다. 즉, 0.36은 36으로 변한된 후, 40%로 근사가 되는 것이다. 이를 위해 필터를 사용하고 몇 가지 샘플 값을 전달하는 테스트를 작성해서 참 여부를 확인할 것이다. 해당 테스트는 다음의 리스트의 코드로 작성되어 있는데, tests/unit/chance.filter.spec.js 파일을 생성해서 삽입하자.

<< 리스트 시작 >>
  리스트 9.2 Chance 필터 단위 테스트 (tests/unit/chance.filter.spec.js)

  1. 기능을 기술한다. 여기서는 Chance 필터.
  2. App을 유효하게 하기 위해 Angular mocks의 module() 메소드를 사용
  3. 테스트를 선언할 때는 'it should...' 스타일을 사용하고, chanceFilter를 주입하면서 테스트 시작
  4. 필터가 몇 개의 값을 기대한 출력값으로 변환시키는지 확인하기 위해 assertion 라이브러리 사용
<< 리스트 끝 >>

이 테스트에 언급해야 할 것들이 많이 있는데, 하나 하나 살펴보자. 먼저 describe() 메소드(1)부터 시작한다. 이 구문은 작성한 테스트를 묶어 주기 위한 것으로, 관련된 테스트가 모두 이 블럭 안에 존재하게 된다. 다음 블럭은 beforeEach()메소드로, 이 안의 함수가 각각의 테스트 전에 실행된다. 이것은 중요한 점인데, 모든 테스트 사이에 테스트 환경이 초기화되기 때문에 테스트 간에 영속되는 뭔가가 있다고 기대하면 안된다. beforeEach() 메소드는 테스트가 실행되기 전에 여러분이 작성한 앱을 로딩하기 위해 module() 메소드를 사용한다. module() 메소드는 앞서 설정했던 파일에 포함시켰던 Angular mocks 패키지를 사용하고 있기 때문에 유효한 것이다.
it 구문은 특정 기능이 필요함을 선언하는 곳이다. 첫 번째 인자는 문자열인데, 통상적으로 'it should do something.' 형식으로 작성한다. 두 번째 인자는 실행될 함수로, 실제로 뭔가를 수행하고 확인하는 코드를 포함한다. 여기서는 chanceFilter를 주입하기 위해 inject() 함수를 사용한다. 보통은 필터를 바인딩 표현식에 넣어서 {{ 0.34 | chance }}와 같은 식으로 사용하지만, 여기서는 직접 로딩해서 호출했다.
마지막으로, 여섯 개의 expect 구문이 있다. 이들은 앞서 설명했던 assertion들로, chanceFilter에 특정 값을 주고, 지정한 값과 같기를 기대한다고 기술하는 부분이다. 예제에서는 6가지 다른 시나리오로 필터가 작동함을 점검했다. 필요한만큼 경우를 만들어 테스트할 수 있고, 마지막에는 유효하지 않은 값에 대해서도 잘 처리하는지 확인하기 위한 경우를 포함시킬 수 있다.
재스민과 BDD 스타일 테스트의 잇점 중의 하나는 테스트를 선언적 스타일로 작성한다는 것인데, 이 때문에 비개발자도 읽고 이해할 수가 있다. describe()으로 기능을 설명하고 it()으로 해야할 일을 선언하기 때문에, 테스트를 동작의 유효성을 점검하는 용도뿐만이 아니라 기능을 계획하고 명세를 만드는 용도로도 활용할 수 있다.

단위 테스트 실행하기
테스트 실행을 위해서 카르마 커맨드 라인 도구를 써야한다. 이것은 여러분이 파일을 수정하는 현황을 감시하기 위한 세션을 만들어, 파일을 저장할 때마다 자동으로 테스트를 진행한다. 또한 새 크롬 창을 구동시켜, 그안에서 테스트를 실행한다. 프로젝트의 루트 디렉토리에서 다음 명령을 실행한다.

$ karma start

카르마 서버가 시작되면, 파일을 감시하면서 브라우저를 통해 테스트 실행을 처리한다. 그때 그때 테스트를 수행하고 테스트 결과를 콘솔창에 바로 뿌려준다.
필자는 보통 이 터미널 창을 한쪽에 항상 열어둔 채로 개발 내내 테스트를 실행시킨다. 이렇게 하면 테스트를 작성해야 함을 항상 주지시켜 주고, 코드를 깨뜨렸을 때 즉시 알아볼수 있게 도와준다.

Search 콘트롤러를 위한 단위 테스트 작성
이제 콘트롤러 중 하나를 골라 또 다른 테스트를 만들어 볼 것이다(그림 9.3). 대부분의 구조는 전과 같지만, 콘트롤러를 테스트하기 위해서는 몇가지 다른 설정을 해줘야 한다. 적당히 단순한 Search 콘트롤러를 테스트할 예정인데, HTTP 요청을 만들기 때문에 테스트를 위해서 목킹(mocking)을 해야할 것이다.

<< 글상자 시작 >>
  목(mock)이란 무엇이고, 왜 필요한가?

  테스트를 하다 보면, 테스트 실패를 야기할 수 있는 여러 조건들을 격리하고 싶을 때가 있다. 문제는 대부분의 코드가 실행을 위해서 다른 코드를 의존한다는데에 있다. 예를 들어, 콘트롤러가 $http 서비스를 포함하고 있다면, 이것에 의존하고 있는 것이다.
  목은 실제 객체의 동작을 흉내 내도록 설계된 특별한 객체이다. 여러분은 테스트 중에 실제로 HTTP 요청을 보내는 것을 원치는 않을 것이다. 왜냐하면, 이 요청은 시간이 걸리는 작업인데다가, AngularJS에서 버전을 출시하기 전에 $http 서비스에 대해서 이미 테스트를 완료했기에 재차 테스트할 필요가 없기 때문이다. AngularJS에는 $httpBackend라는 $http의 목 버전이 있는데, 이는 Angular Mocks 모듈에 포함되어 있다. 또 다른 예로 로컬 스토리지의 경우도 있는데, 여기에도 실제인 듯 행동하는 localStorage 목 서비스를 만들수 있다. ngCordova도 역시 각 기능을 목킹하는 목 서비스를 제공한다.
  커스텀 코드베이스의 일부가 아닌 것은 뭐든지 단위 테스트를 위해 목을 사용해야 할 것이다. 테스트를 위해 실제 API를 호출하고 싶지는 않을 것이다. 앱에서 사용자 등록을 테스트하는 경우를 생각해 보자. 실제 서비스를 사용하는 대신, 목 오브젝트를 사용해서 의도치 않은 등록을 피한다. 또한 테스트가 충분히 빠르게 수행되어 사용할 여지를 올리고 싶을 것이다. 수시로 실행되어야만 하기 때문이다.
<< 글상자 끝 >>

<< 리스트 시작 >>
  리스트 9.3 Search 콘트롤러 테스트 (test/unit/search-ctrl.spec.js)

  1. Search 콘트롤러의 기능을 테스트할 것임
  2. 자식 스코프의 값에 접근하기 위한 변수 선언
  3. 각 테스트가 실행되기 전에 App 모듈 추가
  4. 각 테스트가 실행되기 전에 테스트를 위한 서비스 주입
  5. 주입된 서비스로 변수 설정
  6. 날씨 API에 대한 HTTP 응답과 템플릿 처리를 위해 httpBackend.when() 사용
  7. scope와 $http 서비스를 사용하는 콘트롤러 인스턴스 생성
  8. model.term의 기본값이 빈 문자열임을 확인하기 위한 스펙 생성
  9. term을 수정하고, 메소드를 호출하고, 요청을 플러쉬한 후 결과를 확인하는 search 메소드 스펙 생성
<< 리스트 끝 >>

이번 테스트는 콘트롤러보다도 길다보니, 다소 걱정이 앞설지도 모르겠다. 이 테스트에서 해야할 많은 작업들은 테스트 환경을 설정하는 것에 관련되어 있다. 이번에도 다뤄야 할 것들이 제법 있는데, 하나씩 헤쳐나가 보자.
먼저 describe 구문(1), 이번에는 Search 콘트롤러 이다. 코드가 함수 안에서 실행되기 때문에, 나중에 쓸 값을 저장할 변수를 몇 개 선언한다(2). 이전 테스트 때처럼, beforeEach() 메소드에 App 모듈을 추가한다(3).
다음 beforeEach() 메소드는 작동하는 콘트롤러를 얻기 위해 필요한 로직을 포함한다(4). 각각 격리된 상태에서 수행되는 테스트를 만들고 있기 때문에, AngularJS가 밑단에서 원래 해주던 작업 일부를 우리가 직접 해야 한다. AngularJS 도큐먼트를 보면 필터, 디렉티브, 컨트롤러와 같이 각각의 타입에 따라 테스트를 설정하는 것을 상세히 다루고 있다. 이 때문에 종종 사람들이 테스트 관련해서 짜증이 나기 시작하는데, 이에 굴하면 안된다!
새로운 스코프를 만들고, httpBackend 서비스를 변수에 저장한다(5). 이 변수들은 이후 스펙에서 필요한 것들로, 이 때문에 바깥에 변수를 만든 것이다. 첫 번째 httpBackend.when() 호출은 지역 검색 요청에 되한 목킹이다(6). HTTP 요청 메소드를 지정하고(여기서는 GET), 요청받을 URL을 선언하고, 메소드 체인으로 response() 메소드를 호출하면서 반환 값을 정의한다. 응답 결과가 실제와 다르다고 해서 걱정할 필요 없다. 응답은 최소한의 요건만 갖추면 되는데, 예제에서는 그냥 객체의 배열이다.
다음 세 개의 httpBackend.when()은 HTTP 프로토콜을 타고 로딩되는 템플릿을 목킹하기 위한 것이다. 이들은 URL로 템플릿을 로딩하는 경우에만 필요한 것인데, 앱의 상태 선언부에 설정되어 있다. 마지막 단계는 콘트롤러를 등록하면서 필요한 의존 서비스들을 전달하기 위해 $controller 서비스를 사용하는 부분이다(7).
마지막으로 실제로 컨트롤러를 테스트하는 두 스펙이 남았다. 첫 번째 스펙은 단순히 model.term 값이 비어있는지 확인한다(8). 콘트롤러의 기본 상태를 테스트하는 것은 좋은 습관이다. 두 번째 스펙은 model.term 값을 변경하고 search() 메소들르 호출한다(9). 이 부분을 httpBackend 목 서비스가 처리한다.
실제 HTTP 요청을 만드는 대신, (6)에서의 목 선언부를 보고, 매칭되는 요청이 있는지 찾는다. 찾았다면, 우리가 선언했던 값(세 개의 빈 객체를 가지는 배열)으로 응답을 보낸다. 배열의 길이를 확인함으로써 세 개의 객체를 가지도록 스코프가 갱신되었는지 확인한다.
카르마가 명령줄에서 실행중인 상태라면, 이 테스트가 자동으로 추가되고 실행될 것이다. 카르마 프로세스를 취소시켰다면, 다시 시작해서 테스트를 통과하는지 살펴본다.

<< 글상자 시작 >>
  재스민에 대해서 좀 더 배우고 싶다면

  재스민은 테스트를 간단히 하려고 여기서 다루지 않았던 특징들이 많이 있다. 테스트를 표현하는 여러 방법도 가지고 있는데, expect(value).toBeDefined()나 expect(value).not.toBeNull()과 같은 것들이다. 재스민 테스트의 대부분을 알고 싶다면, http://jasmine.github.io/의 문서에서 모든 사용할 수 있는 표현들을 살펴보자.
  재스민을 이해하기 위해 필자가 가장 좋아하는 방법은 AngularJS와 Angular 모듈을 위해 작성된 다른 테스트를 살펴보는 것이다. GitHub의 AngularJS 저장소나 여러 써드파티 Angular 모듈 저장소에서 테스트를 찾을 수 있다.
<< 글상자 끝 >>

테스트의 가장 어려운 점은 AngularJS에 의해 관리되는 앱의 많은 부분을 직접 처리하는 방법을 이해하는 것이다. AngularJS 도큐먼트는 여러분이 테스트를 적절히 연결하는 방법을 헷갈려할 때 도와줄, 앱을 테스트하는 방법을 다루는 예제들이 있다. 테스트를 작성하는 작업이 도전적일 수 있지만, 배우고 쓰려는 노력은 가치가 있다. 이제 애플리케이션을 수정해도 언제든지 테스트를 실행시켜 깨진 부분이 없음을 검증할 수 있게 되었다.

9.5.2 Protractor와 WebDriver로 통합 테스트하기
앱의 어떤 부분은 인풋 폼을 탭해서 값을 타이핑하는 것과 같이 사용자 행동을 시뮬레이션 할 수 있는 통합 테스트를 해야 제대로 검증된다. Protractor(http://www.protractortest.org)는 AngularJS를 위해 특별히 만들어진 테스트 프레임워크이다(사실은, Angular 팀이 만들었다). 따라서 아이오닉 앱에도 쓸 수 있다. Protractor는 WebDriver(http://w3c.github.io/webdriver/webdriver-spec.html)라는 API를 기반으로 만들어졌다. 이를 통해 유저의 행동을 프로그래밍으로 재현할 수 있다. WebDriver는 사실 프로그램이 브라우저와 프로그램으로 상호작용하는 방법을 기술한 명세일 뿐이다. Selenium(http://docs.seleniumhq.org/projects/webdriver/)은 WebDriver API 스펙의 영향을 받은 프로젝트였다. 이 API들을 사용해서 테스트를 실행하는 예가 그림 9.10에 나와있다.
Protractor는 WebDriver의 기능을 확장하고, AngularJS 앱을 위한 지원을 추가했다. 기본적으로 WebDriver는 페이지가 준비 상태가 될 때 실행되지만, AngularJS의 다이제스트 루프 때문에, AngularJS가 준비된 상태 이후에 실행되어야만 한다. Protractor는 테스트를 실행하기 전에 AngularJS가 렌더링을 마칠때까지 기다리며, AngularJS 템플릿의 일부분을 타깃으로 호출하기 위한 몇 가지 고유의 API를 제공한다.

<< 그림 시작 >>
  1. Protractor와 WebDriver 시작
  2. Protractor가 파일로부터 테스트를 로드해서 브라우저로 전송
  3. WebDriver는 테스트를 실행하고, 사용자의 행동을 흉내
  4. Protractor로 결과 반환

  그림 9.10 WebDriver/Selenium, Protractor와 재스민으로 통합 테스트를 실행하는 방법
<< 그림 끝 >>

설정을 하면서 WebDriver API를 구현한 Selenium과 사용자를 흉내내 브라우저(기본은 크롬)를 조종하기 위한 플러그인을 사용할 것이다. 테스트를 실행하기 위해 백그라운드에서 돌아가는 Selenium 서버가 있어야 하는데, 이는 Protractor로 쉽게 관리된다.
Protractor는 테스트 실행을 위한 기본 테스트 프레임워크로 재스민을 사용한다. 그렇다고 재스민을 필수로 써야 하는 것은 아니고, 모카나 Cucumber.js오 같이 선호하는 다른 프레임워크를 선택할 수 있다. 우리는 이미 재스민을 썼기 때문에 일을 쉽게 하기 위해 같은 스타일로 테스트를 작성하겠다.

Protractor와 WebDriver 설정 및 실행
먼저 Protractor와 WebDriver를 한번에 설치한다. Protractor를 전역 노드 모듈로 설치하는데, 아이오닉과 코르도바를 설치했던 방법과 같다.

$ npm install -g protractor

이 명령은 Protractor를 다운로드하고 WebDriver를 쉽게 관리할 헬퍼 도구를 생성한다. 이 툴은 WEbDriver를 실행하기 위한 모든 도구를 다운로드하기 위해 사용된다. Selenium 서버와 크롬 드라이버를 다운로드하고 설정한다.

$ webdriver-manager update

Protractor의 버전 넘버와 WebDriver 상태를 확인함으로써 제대로 설치되었는지 체크한다. IEDriver는 필요 없기 때문에 해당 드라이버가 없다는 메세지는 무시해도 괜찮다.

$ protractor --version
Version 1.6.1
$ webdriver-manager status
selenium standalone is up to date
chromedriver is up to date
IEDriver is not present

Protractor 테스트를 실행하고 싶을 때는 항상 Selenium 서버가 실행되고 있는지 먼저 확인해야 한다. 이를 위해 터미널 창을 열고 다음 명령을 실행한다.

$ webdriver-manager start

Selenium 서버 시작에 관한 수많은 진단 정보들이 보일 것이다. 이 창은 열린 상태로 있으면서 테스트 하고 싶을 때마다 실행중인 상태이어야 한다. 서버 중지는 Ctrl-C를 입력하면 된다. 어쩌면 자바가 설치되지 않았다거나 업데이트가 필요하다고 할 수도 있다. 이를 고치려면, http://mng.bz/83Ct 에서 최신 버전의 JDK를 다운로드 해서 설치한다.

Protractor 설정
Protractor를 프로젝트 내에서 실행하려면 설정 파일이 필요하기 때문에, 테스트 작성 전에 추가해야 한다. 대개의 경우에는 쓰지 않는 많은 옵션들이 있지만, Protractor 도큐먼트를 사이트에서 읽어 보길 바란다. 프로젝트 루트 디렉토리에 protractor.conf.js라는 새 파일을 만든다.

exports.config = {
  seleniumAddress: 'http://localhost:4444/wd/hub',
  specs: ['test/e2e/**/*.spec.js']
};

이 설정은 Protractor에게 로컬 Selenium 서버의 주소를 지정한다(주소는 webdriver-manager가 설정했다). 그리고 파일 경로를 담은 배열은 테스트를 실행할 파일을 찾기 위한 것이다. 기억하자. 재스민에서 테스트를 spec이라고 불렀는데, 여기서는 test/e2e 디렉토리 안에서 .spec.js로 끝나는 모든 파일을 찾는다.

Protractor 테스트 작성
우리는 재스민을 사용하고 있기 때문에, 이번 테스트도 단위 테스트와 유사한 구조를 가진다. 큰 차이점은 유저의 행동을 흉내내는 브라우저 자동화 테스트 코드를 작성하는데 집중하는 것이다.
Protractor와 WebDriver는 페이지의 엘리먼트를 찾고 그와 상호작용할 수 있는 메소드 집합을 제공한다. 이는 자바스크립트에서 document.getElementbyId()와 같은 메소드를 사용해서 엘리먼트를 찾는 것과 매우 유사하다. 그러나, Protractor와 WebDriver를 사용하면, CSS 클래스 이름이나 엘리먼트에 사용되는 ngModel과 같은 AngularJS 특정 기능으로 페이지 상의 엘리먼트를 검색할 수 있다.
검색 뷰에 새 테스트를 추가해 보겠다. 검색어를 주고 검색 버튼을 탭하면 검색 페이지가 응답하는 부분을 확인하려고 한다. 단위 테스트는 각 코드 조각이 작동함을 검증할 수 있지만, 여기서는 모든 것이 함께 작동하는 것을 확인하게 될 것이다.
tests/e2e/search.spec.js에 파일을 만들고 다음 리스트의 코드를 추가한다. 이번 테스트들도 단위 테스트때 봤던 describe()과 it() 메소드를 사용할 것이다.

<< 그림 시작 >>
  리스트 9.4 Protractor 테스트 (tests/e2e/search.spec.js)

  1. describe()으로 검색 뷰를 위한 테스트임을 선언
  2. 검색 뷰가 첫 페이지인 앱을 열기
  3. 특정 ngModal 값을 가지는 인풋 엘리먼트를 참조하는 변수 생성
  4. 버튼에 지정한 클래스 이름을 가지는 버튼을 참조하는 변수 생성
  5. ngRepeat 값을 기반으로 결과 목록을 찾아 변수에 대입
  6. 기본 term 엘리먼트의 값이 비어있음을 확인하는 첫 번째 테스트
  7. 값을 검색 상자에 입력하고 검색 결과를 클릭한 후 4개의 결과를 기대하는 두 번째 테스트
  8. 맨 처음 결과를 클릭해서 날씨 뷰에 해당 지역이 로딩되는지 확인하는 세 번째 테스트
<< 그림 끝 >>

실행하기 전에 이 테스트에서 어떤 일이 일어날지 살펴보자. 먼저 describe() 메소드로 검색 뷰를 위한 테스트를 생성했다(1). 그 다음 Protractor의 기능인 browser.get()으로 Protract가 앱을 로딩하게 했다(2). 코드에서는 ionic serve를 백그라운드에서 실행해서 localhost의 서버가 8100번 포트를 열고 있다고 가정한다. Protractor는 스마트해서 페이지를 로딩하고 AngularJS가 렌더링을 마칠때까지 기다려 다음 단계를 실행한다.
그 다음 페이지상의 엘리먼트를 참조할 세 개의 변수를 만들었다. 하나는 검색 상자인데, ngModel의 값을 근거로 엘리먼트를 찾는다(3). 검색 인풋의 어트리뷰트에 ng-model="model.term"을 지정했었기 때문에, element(by.model('model.term'))을 이용해서 찾을 수 있었다. 같은 방식으로 검색 버튼도 변수에 대입할 수 있는데, 이번에는 버튼의 클래스 이름으로 찾았다(4). 세 번째 변수는 결과 목록으로 이번에는 ngRepeat 어트리뷰트의 값에 근거해서 엘리먼트를 찾았다(5). 이제 변수에 테스트하려는 페이지의 요소를 지정했기 때문에 테스트를 작성할 수 있다.
첫 번째 테스트는 그냥 검색 상자의 기본 값이 비어있는지 확인하는 것이다(6). 기본 상태를 확인하는 것은 좋은 습관인데, 이번 테스트는 작동 전에 검색 상자가 값을 가지게 하는 요인이 있는지를 확인하는 용도이다.
두 번째 테스트는 실제 키보드 입력을 에뮬레이트해서 검색 상자에 'london, uk'를 입력한다(7). 그 다음 검색 버튼 클릭을 에뮬레이트하여 실제 검색이 일어나도록 한다. 이 과정을 마치면, 결과의 갯수를 세어 반환된 아이템의 갯수를 확인한다. 검색어에 대한 결과가 4개가 되어야 한다.
마지막 테스트는 목록의 첫번째 결과를 클릭한다(8). 아이켐은 날씨뷰로 링크되어 있기에, 뷰 사이의 링크가 올바른지 테스트한다. 뷰가 로드되면 날씨 뷰의 제목을 확인하고, 아까 목록의 첫 번째 항목의 값과 동일한지 확인한다.
이제 테스트가 무슨 일을 할지 감을 잡았을테니 실행해 보자. 테스트를 실행하려면 세 개의 터미널 창이 필요하다. 하나는 ionic serve를 실행해서 http://localhost:8100에 웹사이트를 띄우기 위한 것이다. 또 하나는 Selenium 서버를 실행을 위한 것이고, 마지막은 Protract 테스트를 실제로 실행시킨다.

$ ionic serve
$ webdriver-manager start
$ protractor protractor.conf.js

protractor 명령을 실행하면, 크롬 브라우저가 열리고 로딩된 앱이 나타나야 한다. 그리고 나서, 빠르게 타이핑, 클릭, 뷰 전환이 되어야 한다. 그러나, 테스트가 실행되는 동안 크롬 내 인터페이스를 볼 수는 있다.

9.6 더 많은 테스트 예제
9장의 프로젝트에는 책에서 다룬 것보다 더 많은 테스트가 있다. 이들을 여러 다른 형식의 테스트를 작성하는 방법을 익히기 위한 예제로 활용하기 바란다.
각 콘트롤러, 필터와 factory 서비스들에 대해서 단위 테스트를 추가해 두었다. 이 테스트들은 여러분이 작성한 거의 모든 종류의 AngularJS 코드를 커버한다. 또, 각 뷰에 대해서 통합 테스트도 추가해 놓았다. 이로써 주요 기능은 점검되고, 서비스는 기대한 대로 데이터를 반환함을 보증한다.
이 장을 위한 GitHub 프로젝트에 질문을 열고 질문을 올리거나 추가적인 테스트를 제안할 수 있다. 프로젝트 URL은 https://github.com/ionic-in-action/chapter9 이다.
지금까지 두 가지 주요 자동화된 테스트에 대해서 논의했다. 이번 장의 목적은 여러분이 테스트를 도입하게 하는 것이었는데, 재스민, 카르마와 Protractor의 문서는 시간을 들여 깊이 읽을 가치가 있다.

9.7 요약
미리보기, 디버깅, 테스트는 개발 프로세스에 있어서 필수적인 부분으로, 이번 장에서는 여러가지 도구와 테크닉을 사용해서 앱의 품질을 향상시키는 방법을 알아봤다. 논의했던 주요 주제들을 요약해보자.
  * 아이오닉 뷰와 아이오닉 랩은 앱 미리보기를 돕기 위해 아이오닉에서 제공하는 기능이다. 아이오닉 뷰는 앱을 스토어에 등록하지 않고도 다른 사람과 앱을 공유할 수 있어 멋지고, 아이오닉 랩은 크로스 플랫폼을 지원하는 앱을 만들 때 안드로이드와 iOS에서의 모습을 함께 놓고 비교할 수 있어 매우 유용하다.
  * 하이브리드 앱 디버깅 기법을 살펴봤다. iOS의 경우 사파리 웹 인스펙터를 장치나 에뮬레이터에 연결해서 앱 안의 웹뷰를 조사한다. 안드로이드는 크롬 카나리아를 장치와 에뮬레이터에 연결하고 웹뷰를 분석한다.
  * 단위 테스트는 재스민 테스팅 프레임워크로 작성할 수 있고, 카르마 테스트 러너로 실행한다. 필터나 콘트롤러와 같은 코드 단위를 각각 테스트해서 기대한 대로 작동하는지 검증할 수 있다.
  * 재스민, Protractor와 WebDriver로 통합 테스트를 작성한다. 이들 테스트는 클릭이나 키보드 타이핑과 같은 사용자 이벤트를 프로그램으로 에뮬레이트 해서 전체 인터페이스가 제대로 동작하는지 확인하기 위한 것이다.
다음 마지막 장에서는 상품으로서 출시하기 위해 앱을 준비하고 빌드하는 방법, 앱 스토어에 출시하는 방법을 알아볼 것이다.
