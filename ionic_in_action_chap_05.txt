5 탭, 향상된 리스트, 폼 컴포넌트들

<< 글상자 시작 >>
  이 장에서 다룰 내용
  * 개별적인 네비게이션 이력을 저장하는 탭 컴포넌트 사용하기
  * 토글, 재정렬 할 수 있는 아이템 목록 표시
  * 데이터 갱신을 위해 당겨서 새로 고침 하기
  * 몇 가지 모바일 폼 입력 컨트롤 다루기
<< 글상자 끝 >>

이번 장에서도 4장에서 그랬듯이 아이오닉의 많은 기능들을 계속 알아볼 것인데, 완결된 앱을 처음부터 끝까지 만들어 볼것이다. 바로, 비트코인에 대한 현재 시장가와 변동 차트를 보여주는 앱이다. 메인 인터페이스는 아이오닉 탭을 사용하여 현재 시장 환율, 환율 변동 이력, 통화 관리의 세 탭으로 구성할 것이다.
또한, 각 탭에 네비게이션 윈도우를 포함하는 방법을 좀 더 배우게 될 것이다. 탭 사이를 이동하면서도 각각의 상태를 유지하는 것은 만족스러운 애플리케이션 경험을 제공하기 위해서 중요한 일이다. 한편, 외부의 소스로부터 데이터를 불러올 때, 탭을 바꾸더라도 데이터를 캐시해 두면 속도를 올리고 불필요한 HTTP 요청을 피할 수 있게 된다.

<< 글상자 시작 >>
  비트코인이란?

  비트코인은 유명한 디지털 (암호화된)화폐이다. 주식이나 물건처럼 판매가와 매입가가 있고, 디지털 마켓을 통해 교환할 수 있다. 이번 장의 목적상, 여러분은 전통적인 화폐(US 달러나 유로화와 같은) 대비 비트코인의 현재 가격이 얼마인지 무척 관심이 많고, 최근 한 달간의 가격 추이를 보고 싶어하는 사람이라고 치자.
  비트코인이 구체적으로 무엇인지, 어떤 기술이 이를 가능케 하는지는 https://bitcoin.org를 참고해 보자.
<< 글상자 끝 >>

그림 5.1은 앞으로 만들 앱을 보여준다. 몇 가지 통화 대비 비트코인의 환율을 지난 24시간 동안 보여주면서 증가 추세인지 감소 추세인지 짐작할 수 있도록 한다. 다음으로, 과거 한달 동안의 이력을 시간 단위로 보여준다. 마지막으로 앱에서 보여주는 여러 화폐들을 개별적으로 끄고 켤 수 있도록 설정하고, 선호하는 통화를 상단에 보이도록 재정렬할 수 있게 한다.
전체 예제는 GitHub의 https://github.com/ionic-in-action/chapter5에서 확인할 수 있다. 또한 https://ionic-in-action-chapter5.herokuapp.com에서 바로 실행 모습을 볼 수 있다. (역주: 페이지 로딩에 다소 시간이 걸릴 수 있으나 정상적으로 서비스 되고 있으므로 기다려보자.)

<< 그림 시작 >>
  (상단 왼쪽)
  현재 환율
    * 통화 목록을 표시
    * 현재 환율와 상태
    * 리스트 컴포넌트
    * 당겨서 새로 고침하기
  (상단 중앙)
  이력 차트
    * 환율 차트를 표시
    * highchart 사용
    * 변경을 위해 셀렉트 박스 사용
  (상단 오른쪽)
  통화
    * 화폐 목록
    * 토글로 온/오프
    * 리스트 컴포넌트
    * 화폐 재정렬
  (하)단
  화폐 상세
    * Display remaining stats
    * 리스트 컴포넌트
    * 이력 탭으로 링크
    * 부모와 같은 탭

  그림 5.1 세 개의 탭과 네 개의 뷰를 가지는 비트코인 예제
<< 그림 끝 >>

5.1 이번 장 프로젝트를 위한 설정
내용을 따라오기 위해 아이오닉 앱을 새로 구성하고 앞으로 계속 소개될 코드를 직접 추가해도 있고, GitHub 저장소의 최종 완료된 앱 코드를 복제한 후 단계별로 확인해도 된다. 브라우저에서 미리 보기를 하려면 ionic serve를 사용한다.

5.1.1 새 앱을 생성하고 직접 코드를 추가하기
아이오닉 커맨드라인 인터페이스(CLI)를 사용해서 신규 프로젝트를 생성하려면, 커맨드 실행 창을 열고 다음의 명령을 실행한다(프로젝트 설정법에 대해서 복습하고 싶다면 2장을 참고하자).

$ ionic start chapter5 https://github.com/ionic-in-action/starter
$ cd chapter5
$ ionic serve

5.1.2 완성된 앱을 복제한 후 진행하기
완성된 앱을 체크아웃 하려면 Git을 쓴다. 다음의 명령어를 실행하여 저장소로부터 소스코드를 복제하고, 1단계의 내용을 체크아웃 한다.

$ git clone https://github.com/ionic-in-action/chapter5.git
$ cd chapter5
$ git checkout –f step1
$ ionic serve

5.2 ionTabs : 탭과 네비게이션 추가
첫 번째로 할 일은 기본 네비게이션 엘리먼트인 ionNavBar와 ionNavView 컴포넌트를 추가하는 것이다. ionNavBar는 현재 활성화된 탭의 제목을 동적으로 업데이트하기에 유용하고, ionNavView는 탭을 포함하는데 사용된다. 이 두가지 컴포넌트에 대해서는 4장의 앱을 만들면서 살펴봤기 때문에, 복습하고 싶다면 돌아가서 참고하기 바란다. Git을 사용해서 따라오고 있다면, 이번 단계에 대한 태그로 체크아웃하면 된다.

$ git checkout -f step2

이번 섹션에서는 그림 5.2와 같은 기본적인 탭과 네비게이션을 구현한다.
다음 리스트의 코드로 www/index.html을 업데이트 해보자.

<< 리스트 시작 >>
  리스트 5.1 ionNavBar와 ionNavView 추가 (www/index.html)

  (왼쪽)
  ionNavBar를 추가하고 스타일 지정
  (오른쪽 위에서 아래로)
  body 엘리먼트에 ngApp 지정
  ionNavBackButton을 추가하여 네비게이션 중에 보여주거나 숨김
  ionNavView 추가
<< 리스트 끝 >>

<< 그림 시작 >>
  네비게이션 바(ionNavBar)
  탭 컨테이너(ionTabs)
  개별 탭들(ionTab)

  그림 5.2 탭, 기본 네비게이션, 빈 컨텐츠를 가진 앱
<< 그림 끝 >>

이 곳에 템플릿이 추가되어, 이동하는 경로에 따라 페이지를 그리게 될 것이다. ionNavBackButton 컴포넌트는 자식 뷰로 이동할 수 있는 뷰가 있을 때 나타날 것이다. 이제 라우팅 경로와 나중에 내용이 나타나게 될 템플릿을 선언해야 한다.
www/js/app.js 파일을 열고, 첫 번째로 라우팅 될 상태를 선언할 수 있다. 이미 작성되어 있는 내용을 수정해서 config() 메서드를 다음과 같이 추가하자.

<< 리스트 시작 >>
  리스트 5.2 앱에 config() 메서드 추가 (www/js/app.js)

  (왼쪽)
  기본 루트 설정
  (오른쪽)
  앱 모듈을 선언하고 ionic 모듈을 포함시킴
  config() 메서드를 선언하고 서비스 주입
  탭을 위한 상태 선언
<< 리스트 끝 >>

이제 경로를 선언했으며, 매칭되는 경로가 없을 때 처리할 기본값도 선언했다. 앱을 미리보기 전에 tabs 템플릿을 추가해야 한다.

5.2.1 탭 컨테이너와 세 개의 탭 추가
탭은 모바일 앱에서 매우 보편적인 인터페이스이며, 아이오닉은 여러분이 이를 신속하게 만들수 있도록 풍부한 기능을 가진 컴포넌트를 제공한다. 탭은 여러 개의 뷰가 연결된 것처럼 나타내기 위해 주로 사용된다. 사용할 수 있는 탭 갯수의 실제적인 제한은 없다. 그러나, 보통은 공간상의 제약으로 두개에서 다섯 개까지 사용된다. 탭은 앱의 거의 모든 곳에서 사용될 수 있으나 ionContent 디렉티브의 경우, ionTabs가 ionContent 안에 위치할 경우에 CSS 충돌이 일어나는 관계로 ionTabs를 포함시킬 수 없다.
아이오닉은 탭 UI를 만들기 위한 두 개의 컴포넌트를 제공하는데, ionTabs와 ionTab이 그것이다. ionSlideBox처럼, ionTabs를 먼저 선언하고, 그 안에 필요한 수만큼의 ionTab을 삽입하면 된다. 이번에는 세 개의 탭을 선언할 것이다.
탭은 아이콘이나 제목, 또는 둘 다 가진다. 여러 가지 다른 클래스를 지정함으로써 제목과 아이콘을 바꿀수 있는데, 예제에서는 제목 위에 아이콘을 올리는 형태로 만들어 보겠다. 한편, 탭은 활성화 상태 여부에 따라 다른 아이콘을 적용해서, 현재 선택된 상태인지 그렇지 않은 경우인지를 표시할 수 있다.
이제 앱에 탭을 추가하기 위해 템플릿을 작성해 보자. www/views/tabs/tabs.html 파일을 새로 만들고 다음 리스트의 코드를 추가하자.

<< 리스트 시작 >>
  리스트 5.3 탭 템플릿 (www/views/tabs/tabs.html)

  모든 탭을 감쌀 ionTabs 컴포넌트를 선언하고 제목과 아이콘 표시를 위한 클래스 지정
  활성화, 비활성화 상태별로 지정된 아이콘과 제목을 가지는 탭 선언
<< 리스트 끝 >>

탭 선언은 정말로 간단해서 각 탭에 대해 지정해야 할 것은 title 어트리뷰트 뿐이다. 탭의 내용은 현재 비어있지만, 브라우저에서 미리 보기를 하면 그림 5.2와 같이 아래에 탭을 볼 수 있다. 각 탭을 클릭해 보면, 아이콘의 상태가 변하면서 활성화 된 탭인지 구분할 수 있다.
탭에 콘텐츠를 추가하기 전에 각 탭이 자신만의 ionNavView를 가지도록 설정부터 해야겠다.

5.3 각 탭에 ionNavView 추가하기
여러분의 탭은 비어있다. 그래서 컴포넌트를 담을 수 있는 ionNavView 컴포넌트를 추가하려고 한다. 각 탭은 각각의 네비게이션 히스토리를 유지한다. 그러므로, 뒤로 가기 버튼은 전체 앱 범위가 아닌 주어진 탭 안에서만 사용하게 된다. 그림 5.3을 보면 사용자가 각각의 네비게이션 히스토리를 가지는 탭을 따라가는 흐름을 볼 수 있다. Git으로 따라오고 있다면, 이번 단계를 위한 코드를 체크아웃하자.

$ git checkout -f step3

<< 그림 시작 >>
  1. 탭1, 뷰1에서 시작
  2. 탭 1, 뷰 2로 이동
  3. 탭 2로 이동
  4. 탭 1, 뷰 2로 이동

  그림 5.3 개별적인 네비게이션 히스토리를 가지는 탭에서의 이동
<< 그림 끝 >>

<< 글상자 시작 >>
  탭에 뷰가 꼭 필요한 것은 아니다

  탭은 콘텐츠라면 무엇이든 포함할 수 있다. 탭은 사실 하나의 커다란 뷰인데, 한번에 하나의 탭만 보여주고 나머지는 숨기는 것이다. 마치 여러장의 종이가 쌓여있어서, 언제든지 밑에 있던 페이지를 위로 올려서 보이게 하는 것과 같다.
  각 탭에 ionNavView 엘리먼트를 사용하는 테크닉에는 커다란 장점이 하나 있다. 바로 탭이 개별적으로 각가의 히스토리를 가질 수 있게 된다는 점이다. 그런 이유로 이 경우에는 위에 말한 종이 더미보다는, 책이 쌓여 있는데 가장 위에 쌓여있는 책은 특정 페이지가 열려있는 상황과 더 비슷하다. 책의 위치를 바꾸게 된다면 열려 있는 페이지에 책갈피를 끼우고, 나중에 그 지점을 펼칠 수 있게 한다.
  (계속)
  즉, 핵심은 탭을 사용하는 방법에 있다. 네비게이션을 제공하는 탭과 하나의 뷰에 더 많은 콘텐츠를 채워넣기 위한 탭이라는 두 가지 주요 경우를 생각해보자.
  네비게이션을 위해 탭을 사용할 때는 개별 탭에 뷰를 추가하는 것이 유용하다. 이번 장의 예제는 이런 상황을 보여줄 것이다.
  하나의 뷰에 많은 콘텐츠를 넣기 위해 탭을 사용할 때는 각 탭마다 개별적으로 뷰를 넣음으로써 얻는 이득이 없을 것이다. 예를 들어, 날씨 앱에서 현재의 상태를 보여주기 위해 탭을 사용하는 경우를 생각해보자. 현재 상태 정보는 API로부터 한꺼번에 불러올 수 있는데, 논리적으로 연결된 정보들이다. 이정보들을 적당한 덩어리로 나누어 보여주기 위해 탭을 사용할 수도 있다. 현재 상태, 기상도, 향후 열흘간의 일기 예보를 표시하기 위해 세 개의 탭을 쓰는 경우처럼 말이다.
  요컨대, 탭 안의 콘텐츠들이 하나의 뷰와 콘트롤러에 논리적으로 담길 수있다면, 탭마다 ionNavView를 쓰지 않기를 추천한다.
<< 글상자 끝 >>

탭에 ionNavView를 추가하는 것으로 시작했다. 이제 각각의 뷰에 이름을 지정해서 이 후에 구분할 수 있도록 한다. 아이오닉 앱에는 이름이 없는 ionNavView가 하나만 존재할 수 있고, 이 뷰는 항상 디폴트 뷰가 된다. 한편, ui-sref 어트리뷰트는 아이콘을 탭 사이를 이동하기 위해 사용될 버튼으로 만들어 준다. 미리보기를 해보면 이번 섹션에서 작업한 내용이 이전과 크게 달라보이지는 않겠지만, 그림 5.4에서 볼 수 있듯이, 활성화된 탭에 따라 달라지는 헤더 바가 보일 것이다.
www/views/tabs/tabs.html 파일을 열고 다음 리스트의 코드로 갱신하자. 바뀌는 부분은 볼드체로 표시되어 있다.

<< 리스트 시작 >>
  리스트 5.4 각각의 뷰를 가지는 탭 템플릿 (www/views/tabs/tabs.html)

  (왼쪽)
  탭을 선택할 때 뷰를 바꿔주는 ui-sref 추가
  (오른쪽)
  탭마다 ionNavView의 이름을 지정
<< 리스트 끝 >>

ionNavView 세 개를 서로 다른 이름으로 추가한다. ui-sref 어트리뷰트는 보통의 href 어트리뷰트와 유사하게 동작하는데, URL을 대신 상태의 이름을 이용하여 특정 상태로 이동할 수 있게 한다.

<< 그림 시작 >>
  (왼쪽 그림 부분을 둘러싼 것들)
  네비게이션 바(ionNavBar)
  탭 컨테이너(ionTabs)
  탭 뷰 컨테이너(ionView)
  각각의 탭들(ionTab)

  (오른쪽 상단의 문장과 도해 부분)
  각 탭은 저마다 ionNavView를 가지며, 탭 컨테이너가 부모가 된다. 각각의 탭은 고유의 ionNavView를 갖고 있어, 네비게이션 히스토리를 각자 가진다.
  ionNavView 엘리먼트의 계층도
  탭 컨테이너(abstract)
  환율 탭(rates-tab)
  이력 탭(history-tab)
  통화 탭(currencies-tab)

  그림 5.4 탭이 바뀜에 따라 제목이 달라진다
<< 그림 끝 >>

이제 새로운 뷰를 위한 경로를 config()에 추가해야 한다. Ui-router는 중첩된 상태(nested states)라는 기능을 가지고 있는데, 상태를 계층적으로 선언할 수 있게 한다. 이번 예제의 경우 탭을 보여주고 각 탭으로 분기하는 상태를 부모로 하고, 각각의 탭을 그 하위의 자식 상태로 한다. 이런 특징은 논리적으로 상태를 조직화 하고, 아이오닉 네비게이션 컴포넌트가 여러분 앱의 네비게이션 구조를 이해 할 수 있도록 하는데 유용하다. config()에 새로운 상태를 추가하고 tabs 상태도 수정하자. 다음 리스트에서 수정된 내용이 볼드로 표시되어 있다.

<< 리스트 시작 >>
  리스트 5.5 탭 자식 상태를 추가한 config() (www/js/app.js)

  1. tabs 상태를 abstract로 수정한다. 왜냐하면, 항상 자식 상태를 사용하기 때문이다.
  2. 부모-자식 관계를 표시하기 위해 닷(.) 표기법을 사용하여 tabs.rates를 선언한다.
  3. 라우팅 할 URL을 선언한다. 자식 상태이기 때문에 여기에는 부모의 URL이 추가된다.
  4. 환율 뷰에 대한 이름을 선언하고, 관련 템플릿을 전달한다.
  이력 뷰 선언
  통화 뷰 선언
  5. 기본 라우팅 경로를 환율 뷰로 지정
<< 리스트 끝 >>

이번 상태 설정에는 몇 가지 새로운 점이 있다. tabs가 abstract:true 속성으로 설정되어 있는데(1), 이렇게 하면 이 상태 자체로는 활성화 될 수 없고, 부모로 지정이 된다.
환율 상태는 tabs.rates라는 이름으로 지정되었다(2). 이렇게 표기함으로써 부모 자식 관계임을 알려준다. URL도 선언 되었는데(3), 주목해야 할 점은 부모-자식 관계를 가지고 있을 때 실제의 URL은 부모의 URL 뒤에 붙인 것이다. 따라서 환율 뷰를 위한 URL은 /rate가 아닌 /tabs/rate가 된다. 마지막으로 해당 상태의 뷰가 선언되었다(4). 뷰의 이름은 앞서 ionNavView에 지정했던 이름인 'rates-tab'과 같아야 한다. 이로써 앱은 환율 탭이 활성화 될 때 지정된 템플릿이 뷰에 주입해야 함을 알게 되었다. 이 후에는 뷰의 다른 속성(예를 들어, 콘트롤러 같은 것)에 대한 정의도 하게 될 것이다.
마지막으로 디폴트 경로를 /tabs에서 /tabs/rates로 수정했다(5). 이렇게 한 이유는 탭 컨테이너의 상태는 abstract가 되어 직접 사용할 수는 없고, 세 개의 탭들 중의 한 개는 항상 보여야 하기 때문이다. 이제 /tabs라는 경로로 접근하려고 하면, 환율 뷰로 리다이렉트가 될 것이다.
이번 섹션에서 마지막으로 해야할 작업은 세 개의 탭 각각에 맞는 기본 템플릿을 추가하는 것이다. 이미 상태를 선언하면서 뷰의 templateUrl 속성에 경로를 지정했다. 다음 세 개의 리스트는 각 탭의 뷰를 위한 간단한 템플릿을 담고 있다.

<< 리스트 시작 >>
  리스트 5.6 환율 탭의 기본 템플릿 (www/views/rates/rates.html)
<< 리스트 끝 >>

<< 리스트 시작 >>
  리스트 5.7 이력 탭의 기본 템플릿 (www/views/history/history.html)
<< 리스트 끝 >>

<< 리스트 시작 >>
  리스트 5.8 통화 탭의 기본 템플릿 (www/views/currencies/currencies.html)
<< 리스트 끝 >>

이 템플릿들은 현재 내용이 비어 있지만, 다음 섹션에서 개별적으로 수정해 나갈 것이다. 브라우저에서 미리 보기를 해보면, 아래쪽 탭을 바꿀때 제목이 바뀌는 것을 볼 수 있을 것이다. 이제 탭 컨테이너에 해야할 작업은 완료했으니 현재 비트코인의 환율을 보여주는 첫 번째 탭을 만들어 보자.

5.4 비트코인의 현재 환율을 표시하기
지금 만들고 있는 앱은 비트코인의 정보를 보여주는 것으로, 첫 번째 탭은 여러 종류의 화폐에 대한 비트코인의 현재 시장가를 표시한다. 이를 구현하기 위해 실시간으로 환율과 환율 추이 정보를 제공하는 무료 서비스인 BitcoinAverage API(https://bitcoinaverage.com)을 이용할 것이다. 이 서비스는 비트코인을 환전할 때의 시장가와 변동값의 평균을 계산한다. Git을 사용하여 따라오고 있다면, 이번 단계를 위한 체크아웃을 하자.

$ git checkout -f step4

이번 섹션에서는 실제 서비스의 데이터를 불러오고 탭에 표시하는 과정을 진행할 것이다. 그림 5.5가 이번 작업의 결과물을 보여준다. 결과 데이터가 최종 업데이트 된 시간이 표시되고, 각 통화별 가격과 흐름을 목록으로 나타낸다.

<< 그림 시작 >>
  API를 통해 데이터를 불러와 통화별로 저장한다.
  리스트 컴포넌트(ionList)
  CSS 스타일을 적용한 가격 표시 부분

  그림 5.5 현재의 비트코인 가격을 불러와 목록으로 표시한 환율 탭
<< 그림 끝 >>

화폐 목록 구현을 편하게 하기 위해 먼저 Currencies 서비스부터 만들것이다. 지원되는 화폐들을 배열로 만든 단순한 것이지만, 엄연한 AngularJS 서비스로서 이번 앱의 여러 부분에서 계속 사용할 것이다.
www/js/app.js 파일을 열고 다음 리스트의 코드를 말미에 추가하자. 추가하려는 줄 앞에 세미콜론이 있다면, 문법 오류가 안나도록 신경써야한다.

<< 리스트 시작 >>
  리스트 5.9 화폐 데이터 서비스 (www/js/app.js)

  AngularJS의 factory 메소드로 서비스를 등록
  화폐 배열을 생성하고, 디폴트 여부를 설정
<< 리스트 끝 >>

Currencies 서비스는 화폐에 대한 정보를 포함하고 있는 객체들의 배열이다. code는 각 통화를 표현하는 표준 코드이고, text는 화폐의 이름이며, selected 속성은 목록에 디폴트로 노출할 지 여부를 결정하기 위한 것이다. 나중에 설정도 할 수 있게 만들 것이지만, 일단 몇 개는 보여주지 않기 위해 false로 설정한다. 이렇게 서비스를 만들어 등록했으니 이제 앱 어디서나 사용할 수 있게 되었다.
Currencies 서비스를 맨 처음 사용할 곳은 환율 뷰를 위한 콘트롤러이다. 이 콘트롤러는 BitcoinAverage API를 사용해서 현재 환율 정보를 불러온다. 일단 불러오면 Currencies 서비스와 결합시켜 스코프에서 쓸 수 있도록 할 것이다. 다음 리스트는 www/views/rates/rates.js에 저장될 환율 탭 콘트롤러의 코드이다.

<< 리스트 시작 >>
  리스트 5.10 환율 탭 콘트롤러 (www/views/rates/rates.js)

  (위로부터 아래로, 왼쪽에서 오른쪽)
  RatesController를 선언하고 사용할 서비스 주입
  스코프에 Currencies 서비스 데이터를 지정
  필요시 호출되어 데이터를 불러올 메소드
  현재 환율을 구하기 위해 BitcoinAverage로 HTTP 요청을 전송
  콘트롤러가 처음 로딩될 때 load 호출
  응답으로 받은 타임스탬프를 자바스크립트 Date 객체로 변환
  통화 목록을 순회하면서 시세 데이터를 저장
<< 리스트 끝 >>

이 콘트롤러는 load() 메소드가 호출될 때 $http 서비스를 이용하여 데이터를 불러온다. Currencies 서비스를 주입하여 스코프에 저장하고, 뷰에서 데이터를 보여줄 때 사용한다. 추가로 Currencies 서비스에 환율 데이터도 저장한다. 이것은 앱 전체에서 단일 데이터이며, 여러 곳에서 동일한 값으로 사용된다. 데이터를 공유할 수 있는 다른 테크닉을 쓸 수도 있겠지만, 이런 접근도 이번 경우에는 잘 들어 맞는다.
자, 이제 데이터를 불러올 수 있게 되었으니, 화면에 표시하고 싶을 것이다. 템플릿을 수정하여 콘트롤러에서 불러온 데이터를 보여줄 시간이다. www/views/rates/rates.html 파일을 열고 다음 리스트의 내용을 적용해보자.

<< 리스트 시작 >>
  리스트 5.11 실제 데이터를 적용한 환율 탭 템플릿 (www/views/rates/rates.html)

  1. ngRepeat로 화폐들을 나열하되, 비활성화 된 것은 제외
  2. 현재 가격이 24시간 평균과 같을 때 보여지는 가격 상자
  3. 현재 가격이 24시간 평균보다 낮을 때 보여지는 가격 상자
  4. 현재 가격이 24시간 평균보다 높을 때 보여지는 가격 상자
  5. 데이터를 불러온 최종 시점을 푸터에 표시하기 위한 ionFooterBar
<< 리스트 끝 >>

이 템플릿은 꽤 설명할 것이 많은데, 맨 위부터 시작해 보자. list 컴포넌트가 사용되었고, ngRepeat를 각 통화별 리스트 아이템을 만들기 위해 사용했다(1). ngRepeat안에는 유감스럽게도 이름도 filter인 필터가 있다(필자를 욕하지 말기를. Angular의 필터 이름이 그렇게 생겨 먹었다). 이것은 selected 속성이 false로 지정된 화폐들을 제외시킨다. 나중에 이 설정을 끄고 켤수 있도록 만들 것이지만, 일단은 Currrencies 서비스안에 기본으로 설정된 값에 의거하여 필터링을 수행한다.
각 아이템 내부에는 텍스트가 바인딩 되어 있고, ng-if 디렉티브를 가지는 세 개의 span 엘리먼트가 있다(2, 3, 4). 이들은 현재의 가격과 추세를 지난 24시간 동안의 평균값에 비교해서 표시하기 위한 것들이다. 세 가지 가능한 경우가 있는데, 평균값과 같거나, 작거나 큰 경우이다. 현재가와 평균가를 두고 계산한 결과를 가지고 한 번에 한 가지 경우만 보이게 된다.
list 영역을 지나 ionContent 다음에  ionFooterBar가 있다(5). 이 두 컴포넌트는 서로를 인지하고, 추가로 탭의 존재를 알고 있어서, 푸터가 탭 위에 자동으로 위치하고 콘텐츠 영역은 푸터가 자리할 수 있도록 사이즈를 조정한다. 이런 처리는 스크롤 가능 영역이 올바른 크기가 되도록 하기 위해 중요하지만, 아이오닉이 여러분을 위해서 자동으로 처리해 준다.
가격 상자가 제대로 보일 수 있도록 CSS를 추가해야 하는데, 이런 용도에 맞게 쓸 아이오닉의 빌트인 컴포넌트가 없기 때문이다. 다음 리스트의 내용으로 www/css/styles.css 파일에 입력하자.

<< 리스트 시작 >>
  리스트 5.12 가격 상자 스타일링 (www/css/styles.css)
  모든 가격 상자를 위한 CSS 규칙들
  (페이지가 바뀌면서 같은 말 한번 더 반복)
  변화량이 양일 때 배경색을 변경
  변화량이 음일 때 배경색을 변경
<< 리스트 끝 >>

이 정도가 이번 앱에 쓸 CSS의 전부라서, 그냥 일반적인 styles.css 파일에다 넣어 버렸다.
좋다, 거의 다 됐는데, 이번에 만든 콘트롤러를 앞서 선언한 상태에 추가하고 index.html 파일에서 새로 만든 자바스크립트 파일을 포함시키면 된다. www/index.html 파일을 열고 </head>앞 다른 자바스크립트 파일들이 모두 선언되어 있는 끝 부분에 <script> 태그를 삽입하자.

<script src="views/rates/rates.js"></script>

마지막으로, 라우팅 상태에 콘트롤러를 추가하기 위해 www/js/app.js 파일을 열고 아래의 볼드로 표시된 부분을 적용하자.

.state('tabs.rates', {
	url: '/rates',
	views: {
		'rates-tab': {
      templateUrl: 'views/rates/rates.html',
			controller: 'RatesController'
		}
	}
})

이제 브라우저를 새로고침하면 불러온 각종 화폐들의 목록과 환율이 보여야 한다. 이번 섹션에서는 많은 내용을 다뤘는데, 여전히 사용성을 높이기 위해 할 작업들이 남아 있다. 다음 섹션에는 단순히 가격과 추세만 보여주는 대신에 지정한 화폐에 대한 상세 정보를 전부 볼 수 있는 뷰를 새로 추가할 것이다.

5.5 같은 탭 뷰에서 상세 환율 보여주기
환율도 좋지만, 시장은 지금 보여주는 것 보다 많은 정보를 갖고 있다. 앱 사용자에게 호가, 입찰가, 거래량 등을 위시하여 가능한 모든 데이터를 보여주고 싶다. 이를 위해 새로운 뷰를 만들면 되는데, 환율 탭에서 진입하고, 뒤로가기 버튼으로 다시 목록으로 돌아가도록 한다. 그림 5.6을 보자. Git으로 따라오고 있다면, 다음 명령어를 수행하자.

$ git checkout -f step5

<< 그림 시작 >>
  뒤로가기 버튼
  Currencies 서비스에 캐시된 데이터
  뱃지
  이력 탭으로 링크
  푸터(ionFooterBar)

  그림 5.6 뒤로가기 버튼이 있는 상세뷰는 환율 탭 위에 있으면서 통화에 관한 상세 정보를 보여준다.
<< 그림 끝 >>

그림을 보면 다른 뷰를 열었음에도 여전히 환율 탭이 활성화 상태임을 볼 수 있는데, 두 뎁스의 네비게이션을 가지고 있고, 뒤로가기 버튼으로 오갈 수 있다. 다른 탭으로 갔다가 돌아 왔을 때에도 상세 뷰는 환율 탭으로 돌아갈 뒤로가기 버튼을 달고 있는 상태로 활성화되어 있다. 탭이 현재 상태를 기억해 주기 때문에 더 나은 UX를 경험할 수 있게 된다.
상세 뷰를 위한 콘트롤러를 만들어 볼 것이다. 자체적으로 데이터를 불러오지 않고, 이미 환율 뷰를 위해 데이터를 불러왔던 데이터를 보여주었던 Currencies 서비스를 이용한다. 다음 리스트는 www/views/detail/detail.js에 들어가야 할 콘트롤러 코드이다.

<< 리스트 시작 >>
  리스트 5.13 상세 뷰 콘트롤러 (www/views/detail/detail.js)

  콘트롤러를 등록하고 서비스 주입
  요청받은 화폐를 찾기 위해 순회한 후 스코프에 저장
  (다음 페이지)
  (동일 내용 반복)
  화폐와 시셰 데이터가 없음녀 환율 뷰로 돌아감
<< 리스트 끝 >>

이번에 상태를 선언할 때에는 currency라는 파라미터를 추가하여, 콘트롤러가 $stateParams 서비스를 통해 해당 파라미터를 사용하도록 할 것이다. 지정된 화폐를 인지했다면, 일치하는 코드가 나올때까지 화폐 목록을 순회하고, 템플릿에서 보여줄 $scope의 모델에 값을 저장한다. 마지막으로 그 모델이 유효하지 않을 경우 환율 뷰로 돌아가게 한다. 보여줄 데이터가 없기 때문이다. 상세 뷰에서 새로 고침을 하면, 역시 보여줄 것이 없는 상태이기 때문에 비어있는 뷰를 보여주는 대신 리다이렉트 시킬 것이다.
이제 상세 뷰를 위한 템플릿을 추가해 보자. 데이터들을 나타내야 하는데, 리스트와 값을 보여주기 위한 뱃지를 쓸 것이다. 아래쪽 영역에는 해당 통화에 대한 이력으로 이동할 링크가 있다. www/views/detail/detail.html 파일을 새로 만들고 다음의 코드를 입력하자.

<< 리스트 시작 >>
  리스트 5.14 상세 뷰 템플릿 (www/views/detail/detail.html)

  통화 코드를 뷰의 타이틀과 바인드
  각각의 값을 뱃지 안에서 보여줌
  tabs.history 상태로 연결할 링크를 추가하고 화페 코드를 파라미터로 전달
<< 리스트 끝 >>

이 템플릿은 보여주고 싶은 값들의 목록을 가진다. 뱃지는 엘리먼트에 badge 클래스와 badge-[color] 클래스를 추가하여 간단히 만든다. 가이드 라인이 제공하는 색 이름을 쓰면 된다(예를 들어 badge-assertive). 거래량 값에는 작은 비트코인 아이콘을 붙였다.
마지막 리스트 아이템은 이전 섹션의 탭 템플릿에서 봤었던 ui-sref 어트리뷰트를 갖고 있다. 그런데 여기서는 함수처럼 사용하고 객체를 넘기고 있는데, 이렇게 하면 다른 상태로 이동할 때 파라미터를 전달할 수 있다. 다른 섹션에서 이력 탭이 이 값을 어떻게 사용하는지 알아볼 것이지만, 일단은 이력 탭으로 링크한다 정도로 생각하자.
늘 해왔듯이 상태 설정에 새로운 라우트 경로를 포함시키고 index.html에 콘트롤러를 포함시켜야 한다. index.html에 다음의 코드를 추가한다.

<script src="views/detail/detail.js"></script>

다음으로 www/js/app.js 파일을 열고 새로운 상태를 선언한다. 다음의 코드를 config() 메서드에 적용하면 된다.

<< 리스트 시작 >>
  리스트 5.15 상세 상태 선언 (www/js/app.js)

  (위)
  화폐 코드를 나타내는 파라미터인 :currency
  (왼쪽)
  템플릿과 콘트롤러 선언
  (아래 오른쪽)
  환율 탭의 뷰를 재사용한다. 이 상태도 같은 영역에 표시되기 때문이다
<< 리스트 끝 >>

이번 상태에 대한 선언은 환율뷰의 상태와 비슷하고 같은 뷰를 재사용하고 있다. :currency 파라미터는 화폐 코드 값을 할당받아 전달될 것이다. 이 값은 앞서 리스트 5.13에서 봤듯이, $stateParams를 통해 받게 된다.
마지막 단계는 환율 뷰에서 해당 통화에 대한 상세 뷰로 이동시킬 링크를 만든느 것이다. 다음 리스트에서 볼드로 표시된 부분처럼 환율 템플릿의 두 군데를 살짝 고치면 된다.

<< 리스트 시작 >>
  리스트 5.16 환율 템플릿에 링크를 추가 (www/views/rates/rates.html)

  환율 뷰에서는 뒤로가기 버튼을 숨기기 위해 hide-back-button 추가
  ui-sref를 추가하고, tabs.detail 상태로 지정하며, 파라미터로 화폐 코드를 넘김
<< 리스트 끝 >>

뷰에서 뒤로가기 버튼이 보이지 않도록 설정한다. 현재 환율 목록은 일종의 최상위 페이지라서 사용자들이 뒤로 갈 수 없고 목록내의 아이템을 선택해야 하기 때문이다.
그 다음에 ui-sref 어트리뷰트를 또 사용해서 tabs.detail 상태로 링크를 걸었고, 화폐 코드를 파라미터로 넘겨 상세 뷰가 어떤 화폐가 선택 되었는지 알 수 있도록 했다.
이제 미리보기를 해서 화폐를 클릭(또는 탭)하면 상세 뷰가 보일 것이다. 환율 뷰로 돌아가기 위한 뒤로가기 버튼도 보일 것이다. 환율 뷰의 마지막 개선 작업을 하고, 다른 두 탭을 위한 작업으로 옮겨가자.

5.6 비트코인 채광율을 갱신하고 도움말 보여주기
환율을 불러오고 상세 내용을 볼수 있지만, 아직 새로 고침을 할 방법은 없다. 사용자는 환율을 계속 갱신해서 볼 수 있기를 원할 것이다. 일반적인 테크닉은 ionRefresher 컴포넌트를 사용해서 사용자가 화면을 아래로 당겼다 놓으면 데이터 업데이트를 시작하도록 하는 것이다.
그리고, 사용자들이 보고 있는 정보들을 설명해주는 빠른 도움말 패널도 만들고 싶다. ionPopoverView 컴포넌트로 도움말 정보를 보여줄 수 있다. 그림 5.7은 ionRefresher와 ionPopoverView 컴포넌트가 활성화된 상태를 보여준다. Git을 사용하고 있다면 이번 단계를 위한 코드로 체크아웃을 하자.

$ git checkout -f step6

<< 그림 시작 >>
  팝오버 창을 띄울 버튼
  팝오버(ionPopoverView)
  갱신 API를 호출할 리프레셔(ionRefresher)

  그림 5.7 팝오버와 당겨서-새로고침 컴포넌트들
<< 그림 끝 >>

5.6.1 ionRefresher : 아래로 당겨 환율을 갱신하기
아이오닉의 ionRefresher 컴포넌트는 ionContent 컴포넌트가 숨겨진 패널을 하나 갖고 있어서 사용자가 컨텐츠 영역을 아래로 당길 때 보이도록한다. 충분이 당겼다가 놓으면 데이터를 다시 불러올 함수를 호출한다. 로딩이 끝나면 이 컴포넌트는 다시 숨김 상태가 된다.
ionRefresher를 적용하기 위해 환율 템플릿과 콘트롤러를 수정해야 한다. 일단 템플릿에 ionRefresher 컴포넌트를 추가한다. 다음 리스트의 볼드 처리된 줄을 www/views/rates/rates.html 템플릿에 삽입하자.

<< 리스트 시작 >>
  리스트 5.17 환율 템플릿에 ionRefresher 추가하기 (www/views/rates/rates.html)

  ionRefresher 컴포넌트는 ionContent의 맨 처음에 삽입되어, 데이터를 불러올 메서드를 호출한다.
<< 리스트 끝 >>

믿을 수 없이 간단하지만, 이게 템플릿에 컴포넌트를 추가하기 위해 해야 할 일의 전부이다. 컨텐츠 위에 보이지 않는 ionRefresher 컴포넌트가 추가되어, 유저가 당길 때 나타날 것이다. 이때 아이콘도 노출되는데, 어떤 아이콘을 사용할지 설정할 수 있지만, 기본 아이콘을 사용하겠다. pulling-text 어트리뷰트는 이 컴포넌트가 수행할 일을 사용자에게 설명하는 메세지를 위한 것이다.
ionRefresher 컴포넌트를 충분히 당겼다가 놓게 되면, 아이콘이 스피너(역주: 뭔가 수행 중일 때 표시되는 뱅글뱅글 도는 아이콘)로 바뀌고 on-refresh에 선언된 load() 메서드를 호출한다. load() 메서드는 콘트롤러에 이미 정의된 데이터 로딩을 처리하는 함수이다. 남은 일 한가지는 데이터 로딩이 끝났을 때, ionRefresher에게 알려주는 것이다. 이 컴포넌트 혼자서는 데이터 로딩이 언제 끝나는지 알수가 없어서, 4장에서 봤던 무한 스크롤 컴포넌트처럼 알아서 숨겨지지 않는다. load() 메서드를 수정해서 ionRefresher 컴포넌트에 완료를 알리는 이벤트를 브로드캐스팅 해야 한다.
www/views/rate/rates.js 파일을 열어 콘트롤러의 load 메서드를 다음과 같이 수정한다.

<< 리스트 시작 >>
  리스트 5.18 ionRefresher를 닫기 위해 load 메서드 수정

  finally() 메서드는 HTTP 요청이 완료되었을때, 성공 실패 여부에 관계없이 호출된다.
  scroll.refreshComplete 이벤트를 브로드캐스팅하면 ionRefresher가 닫을 시점을 알게 된다.
<< 리스트 끝 >>

finally() 메서드는 AngularJS의 프라미스 API (3장에서 다뤘다)의 일부분으로, HTTP 요청이 완료되면 결과의 성공 실패 여부와 관계없이 호출된다. 이를 이용하여 scroll.refreshComplete 이벤트를 브로드캐스팅한다. 요청이 실패했다고 해서 리프레셔가 계속 보이게 하고 싶지는 않을 것이다. 따라서 finally() 메서드는 결과에 관계없이 실행하기에 좋은 지점이다. 지금까지가 뷰에서 '당겨서 새로고침'을 지원하기 위해 해야할 일의 전부였다.

5.6.2 $ionicPopover : 팝오버 창으로 도움말 표시하기
$ionicPopover 컴포넌트는 보통 팝오버 창을 띄우는 헤더 버튼이 사용한다. $ionicPopover 컴포넌트에 넣을 수 있는 내용에는 제한이 없지만, 팝오버 창은 화면의 일부분만 사용한다는 제약은 있다. 전체 화면을 쓰고 싶다면 다른 컴포넌트가 필요할 것이다. 이번 경우에는 현재 화면에 대한 기본 정보를 표시하고 데이터 소스에 신뢰를 주기 위한 용도로 활용해 보겠다.
팝오버는 앱이 실행되는 플랫폼의 스타일에 따라 다르게 보여진다. 모든 플랫폼에서 그에 맞게 보일 필요가 있기 때문에 팝오버 컨테이너의 스타일을 바꾸는 일은 하지 않는게 좋을 것이다.
팝오버 콘텐츠를 위한 새로운 템플릿을 만들자. 필자는 팝오버를 서브뷰로 생각하는 편이라, 새로운 뷰를 만들지는 않고, 이를 포함하는 뷰로 템플릿을 불러온다. 같은 맥락에서, 새로운 폴더를 만드는 대신 컨테이너 뷰 폴더에 템플릿 파일을 두기를 권한다. www/views/rates/help-popover.html 파일을 생성하고 다음을 입력한다.

<< 리스트 시작 >>
  리스트 5.19 팝오버 템플릿 (www/views/rates/help-popover.html)
  ionHeaderBar 사용
  템플릿을 감싸는 ionPopoverView 사용. 팝오버를 위한 ionView처럼 행동
  ionContent를 사용하고 HTML 콘텐츠를 추가
<< 리스트 끝 >>

이 템플릿은 ionView대신 ionPopoverView로 감쌌는데, 이것은 팝오버 만을 위한 특별 템플릿이기 때문이다. 그 다음에 ionHeaderBar를 사용하고 ionContent 컴포넌트로 단순 HTML 텍스트 콘텐츠를 감쌌다.
이제 뷰가 알 수 있도록 팝오버를 등록해야 하는데, 콘트롤러에서 이를 처리한다. 앱의 config()에서 상태를 선언한 것과 매우 유사하게 콘트롤러에서 팝오버를 선언해야 한다. 팝오버는 전역적인 기능은 아니기 때문에 해당하는 하나의 뷰에만 격리해서 위치시키면 오버헤드와 복잡도를 줄일 수 있다. www/views/rates/rates.js를 다시 열어 콘트롤러에 다음의 내용을 추가하자.

<< 리스트 시작 >>
  리스트 5.20 콘트롤러에 팝오버 추가 (www/views/rates/rates.js)

  (10시 방향)
  $ionicPopover 서비스 주입
  (1시 방향)
  템플릿 URL로 팝오버를 선언하고, 스코프는 부모 스코프로 지정
  (4시 방향 차례로)
  템플릿이 로딩되면 스코프에 팝오버 저장
  팝오버를 열기 위한 $scope의 메서드. $event 전달을 필요로 한다
  $destroy 이벤트를 리스닝. 뷰가 사라질때 팝오버도 정리한다.
  (7시 방향)
  콘트롤러의 나머지 부분은 동일
<< 리스트 끝 >>

먼저, $ionicPopover 서비스를 주입해야 한다. 이걸 사용해서 템플릿 URL로부터 새로운 팝오버를 생성한다. 팝오버는 자신만의 스코프를 생성하지만, { scope: $scope } 객체를 전달함으로써 스코프를 연결할 수 있다. 종종 이런 경우가 필요하며, 이렇게 하면 팝오버가 부모의 스코프에 접근할 수 있게 된다. then() 메서드는 템플릿 로딩이 완료되었을 때 실행되며, 새로 만든 팝오버 객체를 $scope.popover 속성에 대입한다.
이제 팝오버 셋업은 했으니, $scope.popover.show($event) 메서드로 팝오버를 보여줄 수 있다. 창을 띄우기 위해 버튼에 ngClick을 추가하고 인자로 $event 변수를 전달해야 한다. $event 값은 클릭 이벤트로 발생된 이벤트 객체인데, 어떤 엘리먼트를 클릭했는지에 대한 정보를 포함하고 있다. 팝오버는 이 정보를 가지고 페이지 어디에 보여줄 지 계산한다. $scope.popover.hide()라는 메서드도 있는데, 프로그램상에서 팝오버를 숨길수 있다. 사용자가 팝오버 영역 밖을 탭하면 창을 닫도록 할 수도 있다.
끝으로 스코프의 $destroy 이벤트를 리스닝하고 있는데, 이 이벤트는 스코프가 메모리에서 해제될 때 발생한다. 메모리 누수를 방지하기 위해 더 이상 사용할 수 없는 팝오버도 삭제를 시킨다.

<< 글상자 시작 >>
  왜 어떤 컴포넌트들은 직접 제거를 해줘야 할까?

  아이오닉 대부분의 컴포넌트들은 더 이상 필요가 없을 때 자동으로 정리가 되어 메모리를 해제하고 성능을 향상시킨다. 그러나, 어떤 컴포넌트들-이른바 모달과 팝오버-은 스코프가 소멸될 때 앱이 컴포넌트를 지워줘야 한다.
  현재의 스코프가 메모리에서 삭제 될 때 $destroy 이벤트가 발생된다. 해당 스코프에 있는 것은 이 때 모두 삭제되지만, 팝오버와 모달은 격리된 스코프를 가지고 있기 때문에 지속된다. 이런 구조 때문에 메모리에서 모달이나 팝오버를 자동으로 제거할 방법은 없다.
  만약에 이런 처리를 잊게 된다면, 앱의 매우 느려지게 될 수 있다. 얼마나 영향을 받을지는 복잡도와 메모리 사용량에 달려있다. 대부분의 앱에서는 이를 까먹어도 별로 티가 안 날 수도 있지만, 역시 최선은 지워주는 것이다.
<< 글상자 끝 >>

이제 팝오버를 띄울 버튼을 추가할 차례다. www/views/rates/rates.html에 있는 환율 템플릿을 열고 다음의 볼드 표시된 코드를 추가한다.

<< 리스트 시작 >>
  리스트 5.21 팝오버를 띄울 버튼 추가 (www/views/rates/rates.html)

  템플릿의 나머지 부분은 동일
  버튼을 추가하고 openHelp($event)를 호출하도록 ngClick 사용
  ionNavButtons으로 네비게이션 바 안의 버튼을 선언할 수 있다
<< 리스트 끝 >>

이제 새로 만든 버튼은 팝오버를 열기 위한 함수를 호출하고, 팝오버는 버튼 아래쪽에 알아서 위치를 잡고 열릴 것이다. $event 값은 ngClick이나 이벤트 객체를 전달하는 다른 이벤트 디렉티브에서 전달하는 AngularJS의 특수 값이다. ionNavButton은 네비게이션 바의 주 영역에 나타나는데, 이는 플랫폼에 따라 왼쪽이 되기도 하고 오른쪽이 되기도 한다.
환율 뷰는 이제 마무리했다. 지금까지 도움말 정보를 위한 팝오버를 추가했고, 목록의 환율을 갱신하기 위해 당겨서 새로고침을 하도록 했다. 다음 섹션부터는 지난 한 달간의 가격 이력을 불러오고 차트를 그려주는 이력 탭을 만들 것이다.

5.7 이력 데이터 차트
만들고 있는 앱으로 비트코인의 가격이 주어진 통화 대비 지난 한 달간 환율이 어떻게 변했는지 보고 싶다. 이를 위해 Highcharts를 구현한 highcharts-ng라 는 AngularJS의 디렉티브를 사용할 것이다. 그렇다고 Highcharts를 사용하는 방법을 중점적으로 다룬다는 의미는 아니니, 상세 도큐먼트는 http://highcharts.com에서 참고하도록 하자. Git을 사용한다면 이번 단계를 위해 다음 명령을 수행하자.

$ git checkout -f step7

Bitcoin Average API를 통해 데이터를 불러 올 것이지만, 이 데이터는 JSON 타입이 아닌 CSV(comma-separated value) 데이터이다. JSON 데이터 전송을 지원하지 않기 때문에(CSV 포맷이 더 간결해서, 정보 전송을 위해 더 적은 바이트를 소모한다), 데이터를 파싱해서 Highchart가 이해할 수 있는 포맷으로 변환해야 한다.
이번 장의 결과는 그림 5.8에서 볼 수 있다. 차트와 함께 현재 화폐 이름을 보여주는 셀렉트 박스를 가지고 있다. 여기서 화폐 종류를 선택해서 차트를 볼 수 있다.

<< 그림 시작 >>
  Select 컴포넌트
  API로 불러온 데이터를 Highchart로 표현

  그림 5.8 이력 탭은 지난 한 달간의 평균 가격을 차트로 보여준다.
<< 그림 끝 >>

5.7.1 서드 파티 라이브러리 설치
이번 앱은 서드 파티 라이브러리가 필요하므로, 복사본을 다운로드 해서 설치를 해야한다. ionic add라는 기능을 써야하는데, 내부적으로는 프로젝트에 삽입될 라이브러리 다운로드를 위해 Bower라는 유틸리티를 사용한다. Bower를 설치하지 않았다면, npm을 사용해서 설치할 수 있다.

$ npm install -g bower

(역주 : npm에 적절한 접근 권한을 설정하지 않았다면, sudo를 통해 위의 명령을 실행해야 한다. 즉, $ sudo npm install -g bower로 실행한다. npm에 적절한 접근 권한을 설정하고 싶다면, https://docs.npmjs.com/getting-started/fixing-npm-permissions를 참고하자)
그리고 나서 라이브러리를 두 개 설치해야 한다. 바로 차트 라이브러리인 Highcharts와 이를 AngularJS 스타일로 래핑한 highcharts-ng이다. 다음 명령어로 최신 버전을 프로젝트로 다운로드할 수 있다.

$ ionic add highcharts-release#4.0.4 highcharts-ng#0.0.7

위의 명령은 각 라이브리별로 설치할 버전을 정해줬는데, 이렇게 하면 이 책의 예제는 기대한대로 작동할 거라고 간주할 수 있다. 라이브러리들은 www/lib 디렉토리에 설치된다. (역주: '#버전번호'를 생략하면 최신 버전을 받게 된다. 이글을 번역하고 있는 현재 각 라이브러리의 최신 버전은 v4.2.3과 v0.0.11이다.)
이제 index.html 파일에 필요한 스크립트들을 포함시켜야 한다. 앞의 두 줄은 Highcharts를 위한 것이고, 세번째 줄은 Highcharts-ng를 가리킨다.

<script src="lib/highcharts-release/adapters/standalone-framework.js"></script>
<script src="lib/highcharts-release/highcharts.js"></script>
<script src="lib/highcharts-ng/dist/highcharts-ng.js"></script>

마지막 단계는 highcharts-ng 모듈을 프로젝트의 의존 모델로 선언해서 사용할 수 있도록 하는 것이다. www/js/app.js를 열고 추가하자.

angular.module('App', ['ionic', 'highcharts-ng'])

이제 필요한 서드 파티 스크립트 설정은 끝났으니 이력 탭을 위한 템플릿을 만들어 보겠다.

5.7.2 Highcharts를 이용한 이력 탭 템플릿, 셀렉트 박스로 환율 토글하기
일전에 이력 탭의 탬플릿을 빈 것으로 만들었기 때문에, 화폐를 선택하기 위한 셀렉트 박스를 포함하게끔 수정하고 Highcharts 컴포넌트를 설정해야 한다. 셀렉트 박스 컨테이너를 만들기 위해 아이템을 하나 가지는 인셋 리스트를 사용한다.

<< 리스트 시작 >>
  리스트 5.22 차트를 가지는 이력 탬플릿 (www/views/history/history.html)
  (윗줄 2개)
  이 뷰에서는 뒤로가기 버튼을 숨긴다
  셀렉트 박스를 포함하기 위해 인셋 리스트를 사용한다
  (아랫줄 3개)
  값의 변화를 추적하기 위해 ngChange와 ngModel이 적용된 HTML 셀렉트 박스를 사용한다
  Highcharts 컴포넌트는 차트 객체를 config 어트리뷰트로 받아들인다
  활성화 된 각각의 화폐에 대해 옵션을 생성
<< 리스트 끝 >>

셀렉트 박스 컴포넌트는 기본 HTML 셀렉트 박스를 기반으로 하지만, 아이오닉에 의해 모바일 친화적인 스타일을 가진다. 모바일 장치에서 셀렉트 박스가 사용될 때는 플랫폼이 넘겨 받아 UI를 처리한다. 앱에서 이를 제어 할수는 없지만, 플랫폼 각각이 가장 네이티브하다고 느끼는 방법으로 셀렉트 박스를 표시해주기 때문에 좋은 일이다.
셀렉트 박스에서 활성화 된 화폐들의 목록을 보여주기 위해 이번에도 Currencies 서비스를 사용한다. ngModel을 통해 셀렉트 박스에서 선택된 값을 추적할 수 있다. 값이 바뀌면 ngChange가 발동되어 changeCurrency() 메서드를 호출하고, 바뀐 화폐에 대한 차트를 보여주도록 뷰를 갱신한다.
끝으로 highchart 디렉티브가 차트 객체를 받고 있는데, 이 객체는 콘트롤러에서 선언할 것이다. 차트 객체의 값을 기반으로 해서 디렉티브가 Highchart를 이용하여 불러온 데이터에 맞는 차트르 그리게 된다.
템플릿에 해줘야 할 것은 이게 전부이지만, 제대로 작동하도록 하기 위해 콘트롤러가 해야할 일은 적지 않을 것이다.

5.7.3 이력 탭 컨트롤로 데이터 불러오기, 차트 설정하기
콘트롤러는 차트 설정을 처리하고, 차트를 위한 데이터를 불어오고, 차트가 쓸 수 있도록 데이터 포맷을 다듬어야 한다. $http 서비스를 다시 사용해서 데이터를 불러오고, 이를 다시 Highcharts가 이해할 수 있는 규칙에 따라 차트 오브젝트로 구성한다. 얻어 오는 데이터가 Highcharts가 필요로 하는 포맷과 맞지 않기 때문에 보여주기 전에 데이터를 변환해야 한다. 한편, 콘트롤러는 화폐 변경에 대해서도 처리해야 하고, 템플릿에 선택 가능한 화폐 목록도 입력해야 한다.
www/views/history/history.js 파일을 새로 만들고 다음 리스트의 코드를 추가하자. 다루는 내용이 많기 때문에 신경써서 하나씩 살펴봐야 할 것이다.

<< 리스트 시작 >>
  리스트 5.23 이력 콘트롤러 (www/views/history/history.js)

  1. 콘트롤러를 만들고 서비스를 주입
  2. history 모델을 정의하고, US 달러를 기본으로 설정
  3. 스코프에 화폐 목록을 저장
  4. 새로운 통화가 선택되었을 때, 변경 사항을 처리할 함수
  5. Highcharts 디렉티브가 차트를 보여줄 때 사용할 차트 정의 객체
  (다음 페이지)
  6. 선택한 화폐를 기준으로 이력 정보를 불러옴
  7. 가격 문자열을 분리시켜 가격 행의 배열로 변환
  8. 데이터를 저장할 빈 series 객체를 생성
  9. 루프를 돌며 가격 행에 접근
  10. 컴마로 분리된 문자열을 분리해서 배열로 변환
  11. 시간과 가격 정보를 파싱하고, 포맷을 지정
  12. 날짜와 값이 유효하면 series에 추가
  13. 완료된 series 데이터를 차트에 추가
 14. $ionicView.enter 이벤트를 감지하면, 잘못 캐시된 화폐 모델 값을 재설정 한다.
<< 리스트 끝 >>

뭔가 많이 하고 있는 것처럼 보이는데, 대부분은 데이터의 포맷을 잡고 차트를 설정하는 것에 대한 작업들이다. 위에서부터 짚어 가보자. 처음에 만든 history 모델은 $stateParams를 통해 전달 받은 화폐 값을 저장한다(1). 화폐 정보가 제공되지 않는 경우에는 기본값으로 US 달러를 사용한다(2). 다음에 Currencies 서비스를 $scope에 저장한다(3).
changeCurrencies() 메서드는 셀렉트 박스의 값을 받아 현재의 상태를 갱신한다(4). $stage.go 메서드를 호출하는데, 이는 템플릿 상의 ui-sref와 기능적으로 같다.
나머지 부분은 콘트롤러가 차트에 관한 것이다(5). highcharts-ng 모듈에서 사용되고, 차트 생성을 담당할 객체를 먼저 만든다. 이 객체에 대해 완전히 이해하고 싶다면, https://github.com/pablojim/highcharts-ng에서 highcharts-ng 도큐먼트를 읽어 보기 바란다.
이후는 데이터를 불러와서 포맷을 구성하는 것에 관한 구현이다. $http 서비스는 CSV 형식으로 데이터를 불러오는데(6), API가 이 형식만 지원하기 때문이다. 자바스크립트는 CSV를 다루기 위한 빌트인 된 방법이 없기 때문에 곤란하긴 하지만, 다행히 직접 파싱할 수 있다. 차트는 연속된 데이터 집합을 필요로 하는데, 이를 위한 빈 집합 객체를 하나 만든다. split 메서드로 CSV 데이터를 자바스크립트 배열로 쪼갠다(7, 8). 한편, 이 데이터들은 우리가 별로 관심이 없는 메타 데이터들과 함께 오는데, 불필요한 부분은 버리고 차트에 찍을 포인트에 관한 것만 모은다(9, 10, 11). 브라우저의 개발자 도구를 통해 서버로부터 온 응답에 원하지 않는 응답이 어떤 식으로 존재하고 있는지 확인할 수 있다. 이제 series에 포인트를 찍을 데이터를 추가하고, series를 차트에 전달한다(12, 13). 이제 가격과 함께 그래프가 보일 것이다.
마지막 블럭은 아이오닉의 빌트인 네비게이션 이벤트를 감지하기 위해 리스너를 등록하는 것이다. 아이오닉은 상태를 메모리에 캐싱하는 기능을 가지고 있는데, 나중에 돌아왔을 때 빠르게 상태를 돌려준다. 기본적으로 10개까지 상태를 캐싱하는데, 이를 넘게 되면 히스토리에서 가장 오래된 상태부터 제거한다.
<select> 엘리멘트에 ngChange 이벤트가 발생하면, 앱이 다른 상태의 뷰로 이동한다. 사용자가 셀렉트 박스의 값을 바꾸면, 뷰를 위한 모델에 저장되고, 앱은 다른 상태로 이동하게 되는 것이다. US 달러로 처음에 선택 하고, 유로로 바꾼 상황을 가정해 보자. US 달러가 선택된 처음 상태는 셀렉트 박스의 값은 유로를 가리키는 상황으로 캐시되어, 나중에 US 달러 뷰로 돌아 왔을 때, 유로를 가리키는 상태로 보이게 된다. 이 문제를 해결하기 위해 $ionicView.beforeEnter 이벤트를 리스닝하다가(14), 셀렉트 박스의 값을 URL 파라미터로 전달받은 값으로 설정한다.
한편 이 상황은 상태가 로딩될 때마다 콘트롤러가 실행된다고 기대할 때 문제가 된다. 캐쉬된 상태가 재사용될 때는, 재로딩이 될 필요가 없기 때문이다. 스코프 메서드 안에 있지 않고 실행되는 콘트롤러의 코드들은 상태가 캐시에서 돌아왔을 때 재실행 되지 않는다. 예제의 경우 콘트롤러 안의 대부분의 코드가 이에 해당되는데, 그렇기 때문에 셀렉트 박스의 화폐 값이 설정되는 코드가 재실행 된다고 기대할 수가 없다. 아이오닉의 네비게이션 이벤트를 이용하면, 상태가 캐시되어 있는지의 여부에 관계없이 로드될 때마다 로직을 실행시킬 수 있다.
마무리를 위해 콘트롤러 스크립트를 index.html에 추가하고, 상태 정의 부분도 파라미터와 콘트롤러를 추가하도록 수정한다. index.html에는 스크립트 부의 마지막 부분에 history 콘트롤러를 추가한다.

<script src="views/history/history.js"></script>

그런 후 wwwjs/app.js 파일을 열고 아래 볼드 표시된 부분처럼 이력에 대한 상태를 수정한다.

<< 리스트 시작 >>
  리스트 5.24 이력 탭에 대한 상태 정의 부분 수정 (www/js/app.js)
  화폐 값을 전달하는 파라미터 추가
  (다음 페이지)
  콘트롤러 선언
<< 리스트 끝 >>

이제 미리보기를 하면 이력 탭을 볼 수 있다. 차트가 로딩 되고, 다른 차트를 보기 위해 선택한 화폐를 바꿀수 있다. 그리고 환율 탭의 상세 뷰에서 이력 탭으로 걸어 두었던 링크도 이제 작동한다. 환율 탭으로 돌아가서 특정 화폐에 대한 상세 뷰를 선택하고, 이력 보기 링크를 선택하면 그에 대한 이력 탭으로 이동할 것이다.
이제 마지막 작업은 화폐 탭을 만드는 것으로, 다른 탭에서 보여지는 화폐를 토글하고 정렬을 설정하는 역할을 한다.

5.8 환율 탭에서 목록을 재정렬하고 토글하기
마지막 탭에서는 통화 목록의 정렬을 변경하거나 화면에 보여줄지 여부를 토글할 수 있다. 일종의 설정 창인데, 사용자는 관심을 두고 있는 화폐와 무시할 화폐를 정하고 위에서 아래로 좋아하는 순으로 정렬할 수 있게 된다. 그림 5.9는 토글과 재정렬 기능이 구현된 화폐 목록 화면을 나타낸다. Git을 사용하고 있다면, 다음 명령으로 체크아웃 하자.

$ git checkout -f step8

<< 그림 시작 >>
  재정렬 기능을 켜는 버튼
  화폐를 토글 (ionToggle)
  정렬을 바꾸기 위해 아이템을 드래그
  재정렬 핸들 (ionReorderButton)

  그림 5.9 온/오프 토글 기능과 목록의 정렬 순서를 바꿀수 있는 화폐 탭
<< 그림 끝 >>

5.8.1 ionReorderButton : 목록 재정렬 기능 추가
화폐 탭에 대한 템플릿을 추가하자. 여기에는 ionReorderButton을 사용한 재정렬 기능이 들어간다. 재정렬은 ionList 디렉티브에만 동작한다. 재정렬 상태값을 true나 false로 지정함에 따라 정렬을 위한 핸들이 나타났다, 사라졌다 한다. 핸들이 나타나면, 아이템을 드래그 해서 새 위치로 이동시킬 수 있고, 이 때 콘트롤러는 바뀐 순서가 반영된 모델로 갱신한다. www/views/currencies/currencies.html 파일을 열고 다음의 코드로 수정한다.

<< 리스트 시작 >>
  리스트 5.25 화폐 템플릿 (www/views/currencies/currencies.html)

  재정렬 상태를 토글링하는 버튼 추가
  목록이 재정렬될 수 있음을 선언하기 위해 show-reorder 사용
  ionReorderButton이 꼭 포함되어야 하고, 아이템이 이동한 뒤에는 메서드를 호출해야 한다
<< 리스트 끝 >>

재정렬 할 수 있는 화폐 목록을 만들었다. ionList 컴포넌트는 show-reorder 어트리뷰트로 ionReorderButton이 보여져야 할지 말지를 판단한다. 이 두 개가 서로 맞물려 재정렬 기능이 만들어지게 되는 것이다. 네비게이션 바의 버튼은 state.reordering 속성을 토글할 때 사용되는데, 이로 인해 재정렬 기능이 숨겨지거나 나타난다.
on-reorder 메서드는 자리 바꿈이 끝났을 때 처리할 작업을 핸들링하는 역할을 한다. $fromIndex와 $toIndex라는 두 개의 파라미터가 전달된다. 배열내 아이템의 인덱스 값을 가지고 있는데, 이걸 가지고 어디서 어디로 이동했는지 알수 있다. 다음에 콘트롤러에 이 메서드를 추가할 것이다. www/views/currencies/currencies.js 파일을 열고 다음 리스트의 코드를 추가하자.

<< 리스트 시작 >>
  리스트 5.26 화폐 콘트롤러 (www/views/currencies/currencies.js)

  콘트롤러를 선언하고 서비스를 주입
  Currencies를 스코프에 대입
  기본 재정렬 상태 값을 선언
  (다음 페이지)
  탭을 떠나면 재정렬 기능을 끔
  배열의 splice()를 사용하여, 아이템 이동을 처리
<< 리스트 끝 >>

콘트롤러 코드는 간결한데, 스코프 변수에 값을 저장하는 것으로 시작된다. $stateChangeStart 이벤트를 기다려서 현재의 탭이 포커스를 잃으면 언제든지 재정렬 기능을 불능상태로 만든다. 이 이벤트는 탭이 바뀔 때마다 발생된다. 이렇게 작동시키는 것은 사용성 때문인데, 이렇게 하지 않으면 재정렬 중 다른 탭에 갔다가 돌아오면 여전히 재정렬 중인 상태가 될 것이다. move() 메서드는 어디서 왔는지, 어디로 가려는지를 가리키는 두 인덱스를 받아 아이템을 처리한다. splice(역주: 자바스크립트 배열의 멤버 함수)를 쓰면 원래 자리의 아이템을 지우고, 새로운 위치에 재삽입을 할 수 있다.
이제 화폐 목록은 자리를 바꿀 수 있게 되었고, 아이템의 위치가 바뀌게 되면 다른 탭들도 새롭게 정렬된 순서를 반영하게 되었다. Currencies 서비스의 공유 가능한 특성이 힘을 발휘한 것이다(역주: AngularJS의 서비스는 앱 전체에서 하나만 존재하는 싱글턴 오브젝트이다). 한 곳에서 수정을 하면, 이를 사용하는 다른 상태에 모두 반영이 된다.

5.8.2 ionToggle : 아이템 토글 기능 추가
한 가지 더 원하는 기능은 관심 있는 아이템만 볼 수 있도록 화폐에 온/오프 설정을 할 수 있는 기능이다. ionToggle이라는 컴포넌트를 사용할 수 있는데, 이번에는 CSS 버전을 사용하려고 한다. ionReorderButton과 ionToggle이 궁합이 맞지 않기 때문이다. ionToggle 컴포넌트는 CSS 버전을 추상화 해서 쓰기 간편하게 만든 것일 뿐, 특별한 기능이 더 있는 것은 아니다.
템플릿을 다시 열고, ionToggle 컴포넌트를 추가한다. 리스트에서 ionItem이 토글을 포함하고 있는 것을 확인할 수 있다.

<< 리스트 시작 >>
  리스트 5.27 화폐 목록에 토글 기능 추가 (www/views/currencies/currencies.html)

  toggle 클래스를 가지는 라벨 선언
  토글 스타일을 위한 item-toggle 클래스 추가
  checkbox input에 currency.selected 모델 설정
  CSS가 토글 아이콘을 생성하는데 필요한 엘리먼트 추가
<< 리스트 끝 >>

ionToggle 컴포넌트는 checkbox input으로 토글 값을 추적한다. 체크박스와 토글러는 모두 불리언 값이기에 전통적인 HTML 체크박스에 CSS 스타일을 입혀 만든다. 다른 탭에서 사용할 수 없는 아이템을 필터링하기 위해 각 화폐마다 currency.selected 모델을 이용해다. 어떤 아이템을 온/오프로 토글링하면 다른 탭들은 그 즉시 보이기/숨기기 상태가 업데이트 될 것이다. Currencies 서비스 공유의 힘이 다시 한번 발휘된 셈이다.
이제 미리보기를 해 보면 모든 것이 완료되어야 한다. 특정 화폐에 대한 환율을 볼 수 있고, 상세 내용을 보고, 지난 한달간의 가격 추이를 볼 수 있으며, 어떤 화폐에 대한 내용을 볼지를 결정하고 순서도 정해줄 수 있다.

5.9 도전할 주제들
많은 컴포넌트들을 다루었다. 여러분이 이해한 것을 발전시키고 컴포넌트에 좀 더 익숙해지기 위해서, 다음의 작업들도 시도해 보자.
  * 자동으로 환율 갱신 - 1분에 한번 자동으로 환율을 갱신해도록 해보자. 사용해 볼 만한 것으로 $interval이라는 서비스를 AngularJS가 제공하고 있다.
  * 화폐 설정을 유지 - 화폐의 정렬 순서나 토글 상태를 영속적으로 유지하기 위해서 localStorage나 indexedDB를 사용하는 기술이 있다. 앱 시작 시 기본값으로 설정하기 전에 캐시로부터 화폐를 불러오도록 관리하는 로직을 추가해보자.
  * 더 많은 차트 - BitcoinAverage API는 이력 데이터들을 다양하게 제공한다. 일례로 비트코인이 시작된 이래 현재까지의 가격이 있다. 이력 탭에 설정을 추가해서 차트 데이터를 다른 형식으로 바꿀수 있게 해보자. BitcoinAverage API 상세를 파악해 보라.
  * 상세 뷰 개선 - 현재의 상세 뷰는 매우 간단하고 단순한 정보 목록일 뿐이다. 아이오닉의 CSS 컴포넌트를 더 활용하거나 직접 만들어서 보기에도 멋지게 고쳐보자.

5.10 정리
이번 장에서 우리는 아이오닉 컴포넌트들을 알아봤고, BitcoinAverage API로부터 받은 데이터를 차트 라이브러리인 Highcharts로 활용하는 법도 살펴봤다. 중요한 주제들만 요약해 보자.
  * 탭은 앱 안에서 네비게이션 구조를 제공하는 멋진 방법이다. 때때로 단순 탭만 필요한 경우도 있지만, 이번 예제와 같이 탭별로 개별적인 네비게이션 이력이 필요한 경우도 있다.
  * 서드파티 스크립트와 AngularJS 모듈을 포함시키는 방법은 쉽지만, 각 모듈은 개별적으로 익혀야 할 고유의 기능들을 가지고 있다.
  * 리스트는 재정렬이 가능하며, 뱃지 기능을 지원하고, 토글 컴포넌트를 포함할 수 있다.
  * Currencies 서비스의 경우처럼, 서비스를 이용하면 뷰 사이의 데이터를 공유할 수 있다.
6장에서는 사이드 메뉴, 모달, 그리고 스크롤 컴포넌트 등 나머지 주요 컴포넌트들과 아이오닉의 기능을 살펴볼 것이다.
