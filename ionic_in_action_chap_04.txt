4. 아이오닉 네비게이션과 기본 컴포넌트들

<< 글상자 시작>>
이 장에서 다룰 내용
  * 앱에서 상태와 네비게이션 관리하기
  * 아이콘, 목록과 카드를 콘텐츠와 깔끔하게 연결하여 보여주기
  * 외부 소스로부터 데이터를 불러와서 로딩 화면에 보여주기
  * 지속적으로 데이터를 불러오면서 무한 스크롤하기
  * 앱 인트로에 슬라이드쇼 컴포넌트 사용하기
<< 글상자 끝 >>

이 장에서는 가상의 하와이 리조트를 위해 완전한 기능을 갖춘 모바일 앱을 만드는 법을 보여줄 것이다. 또한 아이오닉 컴포넌트 몇 가지를 소개할 것인데 로더, 콘텐츠 컨테이너와 슬라이드 쇼 같은 것들이다.
이 장은 완전한 앱을 만들기 위한 공정을 단계별로 보여주기 위해 구성되었다. 전체 앱을 먼저 보고 싶다면 GitHub에서 전체 예제를 받을 수 있다. https://github.com/ionic-in-action/chapter4에서 확인할 수 있다. 또한, http://ionic-in-action-chapter4.herokuapp.com에서 전체 모습을 확인해 볼 수 있다.
모든 모바일 앱의 필수적인 부분은 앱 내에서 사용자가 이동하는 경로를 관리하는 것이다. 그런 이유로 초반에는 애플리케이션 네비게이션을 위해 필수적인 기초 공사를 할 것이다. 그 다음에 빌드를 하고, 아이오닉 사용자 인터페이스를 설명하기 위한 새로운 뷰들을 추가해 나갈 것이다. 모든 컴포넌트는 현재 날씨의 상세, 방문자의 예약 상세, 다가오는 리조트의 이벤트들을 보여주는 앱의 기능을 위해 작동할 것이다. 그리고 슬라이더를 사용하여, 이미 다른 앱에서 많이 봐왔던 앱 둘러보기 기능을 포함시킬 것이다. 마지막으로 앱의 기능을 향상 시키기 위한 도전 과제와 배운 것을 연습해 볼 수 있는 몇 가지 주제를 제안하려고 한다.
그림 4.1은 앱의 기본 흐름을 보여준다. 이는 사용자가 할 수 있는 것이 무엇인지, 어떤 경로로 이동해야 하는지에 대한 개념을 나타낸다. 각 뷰에는 기본 기능들을 나열했다. 그림 4.1과 같은 형식의 뼈대는 어떤 모바일 앱이든 기획하는데 도움이 된다.
이제 이 앱을 만들어 보자!

<< 그림 시작 >>
(맨 위 그림)
  사용자가 앱을 열고 둘러본다.
  인트로 뷰
    * slidebox를 사용
    * 첫 사용때만 보여줌
    * 스킵 버튼 사용

  (두 번째 그림)
  홈 뷰
    * 다른 뷰로 링크
    * list 컴포넌트 사용
    * 뒤로 가기 버튼 없음
    * 아이콘 사용

  (세 번째 줄, 맨 왼쪽 그림)
  예약 뷰
    * 손님의 예약 상세 내용 표시
    * list 컴포넌트 사용
    * 뒤로 가기 버튼 표시
    * 아이콘 사용

  (세 번째 줄, 가운데 그림)
  날씨 뷰
    * 현재의 날씨
    * list 컴포넌트 사용
    * 뒤로 가기 버튼 표시
    * 아이콘 사용
    * API로부터 데이터 불러오기

  (세 번째 줄, 맨 오른쪽 그림)
  레스토랑 뷰
    * 지역 레스토랑 목록
    * 뒤로 가기 버튼 표시
    * cards 컴포넌트 사용
    * 무한 스크롤

  그림 4.1 리조트 앱의 뷰와 사용 흐름을 나타내는 뼈대
<< 그림 끝 >>

4.1 이번 장 프로젝트를 위한 설정
이번 장 학습을 위해 신규 앱을 위한 코든 코드를 직접 짜면서 따라오는 방법과 Github에서 복제를 한 후 적절한 지점마다 체크아웃을 하는 방법이 있다. 어떤 방법을 쓰던 각 단계에 대한 코드를 살펴보고 실행할 수 있다. 따라서 선택은 각자의 몫이다. 이 책의 모든 코드를 프로젝트에 복사하듯 작성하는게 싫다면, Git을 사용하는 쪽이 더 빠른 방법이 되겠다.

4.1.1 새 앱을 생성하고 직접 코드 추가하기
아이오닉 커맨드라인 인터페이스(CLI)로 앱 개발을 위한 새 프로젝트를 만들고 싶다면, 터미널을 열고 다음의 명령어를 실행한다(프로젝트 설정 방법을 복습하고 싶다면 2장을 참고하자).

$ ionic start chapter4 https://github.com/ionic-in-action/starter
$ cd chapter4
$ ionic serve

4.1.2 완료했던 앱을 복제한 후 진행
완성된 앱을 체크아웃 하거나 각 단계를 따라가기 위해 Git을 쓰고자 한다면, 다음의 명령으로 저장소를 복제하고 첫 단계를 체크아웃한다.

$ git clone https://github.com/ionic-in-action/chapter4.git
$ cd chapter4
$ git checkout –f step1
$ ionic serve

4.2 앱 네비게이션 구현을 위한 설정 작업
리조트 앱을 만들기 전에 그림 4.2를 보자. 사용자가 열 수 있는 앱의 여러 화면을 보여준다. 각 부분을 개별적으로 개발할 것인데, 여기서 전체의 모습을 볼 수 있다.
첫 번째 작업은 앱의 네비게이션을 설정하는 일이며, 그 다음부터 각 뷰에 콘텐츠를 추가하게 될 것이다. 아이오닉은 ui-router라는 서드 파티 라우팅 프레임워크를 사용한다. 이것은 네비게이션을 위한 중앙 통제 센터 같은 것이다. ui-router에 익숙하지 않은 여러분을 위해 필요한 핵심 기능들을 보여줄 것이다. 자신만의 커스텀 네비게이션 테크닉을 개발할게 아니라면 내부 동작에 대해서 너무 걱정할 필요는 없다.

<< 그림 시작 >>
  [윗줄 왼쪽부터]
  소개, 홈, 예약
  [아랫줄 왼쪽부터]
  날씨 불러오기, 날씨, 식당

  그림 4.2 완성된 앱의 모든 화면들
<< 그림 끝 >>

네비게이션과 라우팅이라는 두 개의 다르지만 서로 연관된 개념을 설명하려고 한다. 네비게이션은 앱 내에서 사용자가 (다른 화면으로 이동하기 위해 버튼을 탭하는 식으로)여기저기 이동하는 것이라는 의미로 사용되었고, 라우팅은 사용자가 이동할 때 해야할 일(버튼을 탭했을 때 어디로 보내야 할지 결정한다던가)을 결정하는 앱 내부의 프로세스를 의미한다. 다시 말해 네비게이션은 유저의 행동이고 라우팅은 유저의 입력에 반응하기 위한 애플리케이션의 로직이다.

<< 글상자 시작 >>
  아이오닉이 ngRoute가 아닌 ui-router를 쓰는 이유
  AngularJS에는 ngRoute라는 공식 라우터가 있으나 아이오닉은 이를 사용하지 않는다. 주 이유는 ngRoute가 ui-router에서는 지원하는 '뷰 이름 사용', '뷰안에 뷰 포함'과 '병렬식 뷰'와 같은 기능을 제공하지 않기 때문이다. 예를들면 여러 개의 뷰로 구성된 탭 인터페이스 같은 것이다. 이런 기능은 ionNavView 디렉티브의 형태로 아이오닉 기본 구성으로 포함되어있다. 아이오닉은 ui-router에만 작동을 하기 때문에, ngRoute를 사용하려고 한다면 몇 가지 이슈가 발생할 것이다.
  이 책에서 다루지 못하는 ui-router의 특징이 많이 있는데, 자세한 내용은 https://angular-ui.github.io/ui-router/를 참고하자. 더 향상된 기능 개발을 위한 유용하고 재미있는 기능들을 볼 수 있다.
<< 글상자 끝 >>

그림 4.1과 그림 4.2를 훑어 봤을 때, 실제 개발 할 뷰는 5개가 있음을 알 수 있다.
  * 소개
  * 홈
  * 예약
  * 날씨
  * 식당들
전통적인 웹사이트는 페이지 개념을 가지는데, 모바일 앱에서는 구별된 페이지가 없다. 사용자가 앱 안을 이동할 때, 페이지가 바뀔 때마다 주소 표시줄의 URL이 바뀌고 다시 불러오는 웹사이트와 비교하면, 뷰의 변화가 분명하게 인지되지는 않는다. 필자는 뷰를 잘 정의된 시각적 경험이라고 생각하는 방식을 좋아하는데, 앞서 이야기한 목록을 마치 앱 안에서 볼 수 있는 다섯 개의 확실히 구분되는 장소들이라고 생각하는 것이다. 앱에서 네비게이션 설정을 하기 전에 사용자를 위한 앱 네비게이션을 어떻게 설계하면 좋을지 논의해 보자.

4.2.1 잘 설계한 앱 네비게이션이란
모바일 앱 네비게이션은 어떤 면에서 새로운 도시를 여행하는 것과 같다. 이 새로운 도시에 기차를 타고 도착했다고 상상해보자. 그리고선 기차 역을 나와 시내 근처로 걷고 있다. '뭘 하면 좋을까'라던가 '어떻게 다녀 볼까(박물관 방문과 같은)' 등등의 여러 생각이 있겠지만, 우선은 목적지에 대해 지금 있는 장소를 이해하기 위해 도로의 표지판에 의지할 수 밖에 없다. 도로 표지판에 익숙하고 상식적인 도시의 규칙을 알고 있다면, 목적지로 가는 길을 찾을 수 있다. 마찬가지로, 여러분의 앱에서도 사용자들을 위한 도로 표지판을 제공해야할 책임이 있다.

<< 그림 시작 >>
  Address bar : 주소 표시줄
  Reload button : 새로 고침 버튼
  Forward and back button : 앞으로, 뒤로 이동 버튼
  No Navigation Built In : 기본 탑재된 네비게이션 도구는 없다

  그림 4.3 브라우저는 주소 표시줄이나 새로고침, 뒤로가기 버튼과 같은 네비게이션 도구를 갖고 있다. 앱은 버튼이 없다. 따라서 개발자가 네비게이션 옵션을 제공해야 한다.
<< 그림 끝 >>

하이브리드 앱 구조에서 웹 애플리케이션을 만들고 있다고는 해도 사용자 경험이 브라우저 내에서 웹 애플리케이션을 보는 것과는 다르다. 왜냐하면 하이브리드 앱은 그림 4.3에서 볼 수 있듯이 브라우저 윈도우도 없고, 주소 표시줄이나 뒤로가기, 새로 고침 버튼과 같은 기능도 없기 때문이다. 이 말은 곧, 앱 개발자인 여러분이 앱 내부를 이동할 수 있는 장치를 제공해야 한다는 뜻이다.
네비게이션을 고민할 때에는, 사용자가 뷰와 뷰사이를 어떻게 이동할지 이해하기 위해 그림 4.1과 같은 흐름을 생각해야 한다. 유저가 어떤 뷰로 이동할 수 있는 경로는 여러 가지가 있을 수 있지만, 언제나 명확하고 직관적이어야 한다. 사용자를 위한 네비게이션을 만드는 방법은 독자적인 방법부터 아이오닉이 기본적으로 제공하는 좀 더 일반적인 것까지 다양하다. 어떻게 이동해야 할지 배워가야 하는 사용자 경험을 제공하는 것 보다는 보편적인 네비게이션 기술을 쓰는 편이 좋다.
평소에 사용하고 있는 네 다섯개의 앱을 관찰하고, 그들이 쓰고 있는 네비게이션 흐름을 이해해 보려고 시도해 보기를 추천한다. 버튼을 사용하고 있는가? 앱의 핵심 기능을 사용하도록 돕는 사이드 메뉴나 탭이 있는가? 사용중 헤맨적이 있는가? 있다면 왜 그런지 알겠는가? 이런 부분을 진지하게 고민해 보는 것이 앱을 설계할 때 도움이 될 것이다.

4.2.2 상태 제공자로 앱뷰 선언하기

<< 그림 시작 >>
  네비게이션 바(ionNavBar)
  비어있는 뷰(ionNavView)

  그림 4.4 네비게이션과 콘텐츠가 없는 한 개의 뷰로 구성된 기본 앱
<< 그림 끝 >>

이제 코드를 자세히 볼 시간이다. 처음으로 할 일은 앱의 HTML 마크업에 아이오닉 네비게이션 컴포넌트를 추가하는 것이다. 다음으로 뷰를 하나 선언할 것이다. 결과는 그림 4.4와 같은데, 아무 내용이 없는 메인 콘텐츠 컨테이너와 네비게이션 바가 있다. Git으로 따라오고 있다면 이번 단계의 코드를 체크아웃하자.

$ git checkout -f step2

ionNavView와 ionNavBar는 네비게이션을 위한 아이오닉의 기본 컴포넌트이다. ionNavView는 앱이 불러올 여러 뷰 콘텐츠를 위한 플레이스 홀더처럼 동작하고, ionNavBar는 사용자가 뷰와 뷰사이를 이동할 때 갱신되는 헤더 바를 보여준다. 이 두 컴포넌트는 서로 함께 동작하도록 설계되어 있지만, 상단 바를 안 쓰겠다면 ionNavBar 없이 ionNavView만 쓸 수도 있다.
HTML의 프레임에 친숙하다면, ionNavView는 그 안에 콘텐츠를 불러오는 느낌과 비슷하다. 그러나 ionNavView는 실제로 프레임은 아니다. AngularJS와 템플릿에 대해 좀 더 알고 싶다면, 3장으로 돌아가 참고한다. AngularJS는 마크업을 처리하는 방법을 가지고 있고(템플릿), 뷰 내부로 주입할 수 있다(이 경우, ionNavView 내부로 주입). ionNavView가 없다면 앱이 콘텐츠를 어디로 붙여야 할지 알 수가 없기 때문에 네비게이션을 사용한다면 앱이 최소한 하나의 ionNavView를 항상 필요로 한다.
ionNavBar는 앱의 상단 막대로 자리잡고 있는데, 많은 앱에서 볼 수 있는 형태다. 타이틀 바 같기도 하다. 현재 뷰의 제목을 표시하고 뒤로 가기 버튼과 같은 도구 버튼을 배치할 수 있는 곳이라고 생각하면 되겠다. ionNavBackButton 컴포넌트를 이번 앱에 포함시킬 것인데, 사용자가 뒤로 갈 방법이 필요하기 때문이다. 그림 4.1에서 아래쪽 줄에 배치된 뷰들은 홈 뷰로 돌아가기 위한 뒤로 가기 버튼을 모두 가지고 있다. 다만, 홈 뷰는 그 버튼을 보여주지 않는데 최상위 뷰이기에 보여줄 필요가 없기 때문이다.
리스트 4.1과 같이 index.html 파일을 열어 네비게이션 컴포넌트를 추가한다. 이것들은 리스트 4.2에서 보게될 자바스크립트가 없이는 실행될 수 없긴 하지만, 일단 마크업 레벨에서 집중하기 위해 살펴보도록 하겠다. 해당 코드는 </body> 태그 안의 콘텐츠 관련 부분만 보여주는 것이지만, 여러분은 HTML 파일의 나머지 부분가지 모두 작성해야 한다.

<< 리스트 시작 >>
  리스트 4.1 마크업으로 살펴보는 앱 네비게이션 컴포넌트(www/index.html)

  (윗줄 세 개 왼쪽에서 오른쪽으로)
  ionNavBar 선언. par-positive 클래스로 스타일을 지정한다
  ionNavView 선언. 이곳을 통해 각 뷰들이 콘텐츠를 보여줄 것이다
  뒤로 가기 버튼의 아이콘은 화살표 모양을 사용한다.
  (아랫줄 두 개 왼쪽에서 오른쪽으로)
  AngularJS 앱을 페이지와 연결
  ionNavBackButton 선언. 뒤로 가야할 경우가 있느냐에 따라 보이거나 숨김
<< 리스트 끝 >>

지금까지 콘텐츠를 담기 위한 플레이스 홀더의 선언을 마쳤다. 아직 실제 뷰를 선언하지는 않았지만, 작성하게 되면 이 컴포넌트가 주어진 정보를 가지고 무엇을 해야할 지 자동으로 인식할 것이다. 여러분이 앞으로 만들 많은 앱들은 앱 네비게이션을 위한 기본 작업으로 리스트 4.1과 유사한 마크업을 가지게 될 것이다.
몇 몇 컴포넌트들은 클래스를 가지고 있음을 볼 수 있는데, 이것들은 아이오닉에서 미리 만들어 놓은 공통 클래스들이다. 아이오닉은 CSS 클래스로 컴포넌트의 표시 형식을 자유롭게 변경할 수 있다. 이 부분에 대해서는 후에 더 자세히 다루도록 하겠다.
코드를 실행해보면 아직 실제로 돌아가는 것은 없다는 것을 알게 될 것이다. 아직 아무런 뷰도 선언하지 않았기 때문이다. 이제 선언해 줘야 할 것들은 애플리케이션의 상태 목록이다. 상태(state)는 ui-router에서 사용하는 개념이다. 상태라는 것은 뷰에서 보여지는 내용과 같은 애플리케이션에서 현재의 모습을 묘사한 것으로, 뷰로 접근하기 위한 URL, 연결된 콘트롤러의 이름, 뷰를 위한 템플릿과 같은 명세를 포함하고 있다. 이 책에서는 일반적인 형식의 뷰에 연결되는 상태를 선언해 볼 것이다(예를 들면, 그림 4.1의 홈 뷰도도 상태이다). 상태에 대한 더 깊은 논의를 보고 싶다면 https://github.com/angular-ui/ui-router/wiki에서 ui-router의 상세 내용을 참고하면 되겠다.
앞서 라우팅이란 유저가 네비게이션을 할 수 있는 애플리케이션의 경로를 결정하는 것을 의미하는 개념이라고 했었다. 이것은 폴더의 트리 구조처럼 생각할 수도 있는데, 상태는 다른 상태들의 자식이 될 수 있도 있다.
이제 home 상태를 만들어 보겠다. 아직 뷰에 관련된 디렉토리 내의 다른 파일들은 만들지 않는다. 선언될 상태에는 앱에서 사용자가 특정 장소로 이동할 수 있는 방법을 포함해야 한다. 이것은 URL을 사용하는 방법이 될 수도 있고, 상태의 이름을 사용할 수도 있다. 여기서는 상태의 이름을 사용하려고 한다.
리스트 4.2처럼 상태를 추가해보자. 상태 추가는 AngularJS 앱을 정의하고 있는 app.js 파일 내에서 이뤄진다. 상태를 선언하기 위해 $stateProvider 서비스와 유효하지 않은 요청이 올 경우를 처리하기 위한 $urlRouterProvider 서비스를 사용한다. 리스트에 나타난 코드는 첫 줄 바로 다음에 추가된 것이다.

<< 리스트 시작 >>
  리스트 4.2 앱 상태 선언 (www/js/app.js)
  (줄 위치에 관계 없이 가장 왼쪽에서 오른쪽으로 번역)
  이미 파일에 존재했던 AngularJS 모듈 선언부
  새 config 메소드를 추가하고 $stateProvider 주입
  홈 뷰를 위한 첫 번째 상태를 선언
  이미 존재했던 run 메소드
  요청받은 상태를 찾을 수 없는 경우에 이동시킬 URL
  뷰 표시를 위해 해당 URL의 템플릿을 로딩하라고 지정
  <a>로 링크를 걸 때 사용될, 상태의 URL 버전
<< 리스트 끝 >>

자, 이제 첫 번째 상태를 선언했고 home이라고 명명했다. 매우 간단하다. 이제 templateURL로 지정한 URL에 존재하는 템플릿을 로딩하려고 할 것이다. 이번 장에서 앱에 더 많은 상태를 추가하면서, 제공할 수 있는 다른 설정 옵션들도 보게 될 것이다. ui-router 문서를 참고하면 모든 옵션을 항상 확인할 수 있을 것이다. 이번 장의 예제는 가장 일반적인 옵션 항목들만 보여줄 것이다.
otherwise() 메소드는 중요하다. 애플리케이션이 요청받은 경로를 찾을 수 없는 경우(웹사이트의 404 에러 페이지와 같은)가 발생하는 경우를 처리해 주기 때문이다. 사용자가 존재하지 않는 상태에 대해 요청을 보냈다면, otherwise() 메소드가 작동하여 홈 뷰를 표시할 것이다. 라우팅 문제가 발생할 경우를 대비해 otherwise() 메소드를 선언해 두는 것은 언제나 좋은 생각인데, 빈 페이지나 에러 페이지를 띄우는 대신 다른 것을 보여줄 수도 있다. 예컨대, 사용자들이 피드백을 보낼 수 있는 기능을 가지는 특수한 에러 페이지를 만드는 것도 고려해 볼 수 있다.
템플릿이 있다고 가정하고 상태의 속성으로 지정했지만, 아직 우리는 이 파일을 만들지 않았다. 이제 첫 뷰가 제대로 작동하도록 마지막 파일을 추가하고, 뷰가 엡으로 어떻게 불러 들이는지 알아볼 때가 되었다. 필자는 모든 뷰를 views라는 하나의 폴더에 모아서 관리하는 것을 선호하는 편인데, 그런 이유로 www/views/home/home.html에 새 파일을 만들고, 다음의 리스트 내용을 삽입하였다.

<< 리스트 시작 >>
  리스트 4.3 홈 뷰를 위한 템플릿 추가 (www/views/home/home.html)
  뷰 템플릿을 선언하기 위해 ionView 사용. view-title의 내용은 ionNavBar에 사용되고, hide-back-button 값은 뒤로 가기 버튼을 숨긴다
<< 리스트 끝 >>

이제 코드를 실행하여 제대로 돌아가는지 확인해 보자. 상단에 파란색 네비게이션 바가 있고 제목이 "Aloha Resort"로 나와야 한다. 나머지 뷰 영역은 비어 있지만, 앞으로 내용을 추가할 것이다. 그림 4.4처럼 보여야 정상이다.
hide-back-button 어트리뷰트를 눈여겨 보자. 이것은 ionNavBar에게 '이 뷰는 뒤로 가기 버튼을 보여주고 싶지 않아'라고 전해준다. 이 외에도 문서에서 찾아 볼 수 있는 다른 ionView 어트리뷰트가 더 있다.
뭐 아직은 그렇게 멋지다는 생각은 안들것이다! 다음 파트에서 홈 뷰를 계속해서 만들어 가보자. 그 과정에서 콘텐츠 영역에 대해 다루고, 아이콘과 리스트를 사용하는 법을 살펴볼 것이다.

4.3 홈 뷰 만들기
지금까지 만든 예제는 빈 내용의 뷰와 제목줄만 가지고 있는데, 이제 콘텐츠를 좀 더 넣어 보겠다. 이 페이지의 주요 기능은 사용자에게 날씨, 식당, 예약 뷰로 보낼 수 있는 링크의 목록을 제공하는 것이다. Git을 사용하고 있다면, 이번 단계에 대한 내용을 체크아웃 한다.

$ git checkout -f step3

리스트 4.3에는 아주 기본적인 뷰가 선언되어 있었다. 여기에 약간 내용을 채워보자. 먼저 ionContent를 추가할 것인데, 이것은 콘텐츠를 위한 제너릭 래퍼이자 지금 당장은 확인할 수 없는 많은 기능을 가지고 있다. 그 다음 각 뷰로 연결되는 링크 목록을 생성할 것이다. 마지막으로 좀 더 있어 보이도록 아이콘을 몇 개 추가해 보겠다. 그림 4.5가 이번에 만들 모습을 보여준다.

4.3.1 콘텐트 컨테이너 생성
ionContent는 가장 일반적으로 사용되는 콘텐츠 컨테이너이다. 다음과 같은 여러 가지 기능을 제공한다:
  * 콘텐츠 영역의 크기를 장치에 따라 맞추어 준다 - 디바이스에 기반해서 콘텐츠 컨테이너의 적절한 높이를 결정해 준다.
  * 헤더와 푸터를 인식 - 헤더와 푸터가 있는지를 인식하고 그에 맞게 사이즈와 위치를 잡는다.
  * 스크롤 제어 - 스크롤을 관리하는 설정 옵션이 여러개 있다. 예를 들어, 한쪽 방향으로만 스크롤을 시킬 수도 있고, 스크롤 기능을 끌 수도 있다.
ionContent에는 많은 옵션이 있는데, 특히 스크롤 제어와 관련된 것이 많다. 대부분의 경우에는 그런 옵션들이 별 필요 없을 것이지만, 공식 문서에서 어떤 옵션들이 있는지 살펴볼 수 있다. 이 태그를 홈 뷰에 추가하자. 다시 홈 뷰 파일을 열고, 다음 리스트의 내용을 추가하면 된다.

<< 그림 시작 >>
  홈 뷰
  아이콘(Ionicons)
  링크 목록(list 컴포넌트)
  콘텐츠 영역(ionContent)

  그림 4.5 아이콘과 링크 목록을 포함한 홈 뷰. 콘텐츠는 네비게이션바 아래에 자리잡고 있다
<< 그림 끝 >>

<< 리스트 시작 >>
  리스트 4.4 홈 뷰에 ionContent 추가 (www/views/home/home.html)
  (왼쪽에서 오른쪽)
  뷰를 위한 콘텐츠를 담는 ionContent
  이 전에 선언했던 ionView
<< 리스트 끝 >>

이게 다라고? 그렇다! 이번 경우에 ionContent는 정말 쓰기 쉬운데, 기본 기능을 그대로 쓰고, 이보다 복잡한 기능을 만들 필요가 없기 때문이다. 콘텐츠 영역은 리사이즈 되고, 네비게이션 바를 고려해서 콘텐츠의 크기와 위치를 계산한다. ionContent를 안 쓰게 되면, 콘텐츠가 네비게이션 바 뒤쪽이자 왼쪽 위 구석부터 시작하게 되는데(역주: 네비게이션바를 무시한 왼쪽 위에서 콘텐츠 영역이 시작되고, 네비게이션 바는 이를 덮어 버린다. 따라서 맨 위쪽에 존재하는 콘텐츠는 네비게이션 바로 인해 가려져 보이게 되거나 안보일 수 있다), 이는 우리가 원하는게 결코 아니다.

<< 글상자 시작 >>
  콘텐츠가 잘못된 위치에 있는가?

  대부분의 경우에 콘텐츠를 감싸기 위해 ionContent를 사용하게 되는데, 만일 콘텐츠가 화면상 이상한 위치에서 나타난다면 ionContent가 올바른 위치에 있는지 재확인 해야 한다.
  ionContent를 쓰고 싶지 않은 상황이 있을수 있다. 5장에서 탭이 ionContent 내부에 있지 않는 경우를 보게 될 것이다. ionContent를 사용하지 않는다면, 원하는 모습으로 보이도록 하기 위해 때때로 CSS를 추가해야 할 수도 있다. 예를 들어, ionHeaderBar를 ionContent 없이 사용한다면, 콘텐츠 영역 일부를 ionHeaderBar가 덮어버리게 된다. 아이오닉은 대부분의 경우에서 디자인과 컴포넌트가 작동하도록 노력하지만, 권장 방식을 벗어난 활용은 확장된 CSS를 필요로 하기도 한다.
<< 글상자 끝 >>

4.3.2 CSS 컴포넌트 사용, 간단한 링크 목록 추가
이제 콘텐츠 컨테이너를 갖게 되었고, 링크 목록을 추가하고 싶다. 아이오닉은 엘리먼트에 적용할 수 있는 간단한 CSS 클래스들을 다수 가지고 있다. 만일 여러분이 부트스트랩(Bootstrap)이나 파운데이션(Foundation)과 같은 프론트 엔드 인터페이스 프레임워크에 익숙하다면, 비주얼 컴포넌트를 만들 때 클래스를 추가하는 방식이 꽤 친근할 것이다. 체크 박스, 범위 슬라이더, 버튼과 같은 몇 몇 폼 요소들은 아예 모바일 환경에 맞춘 디자인을 가지고 있다.
아이오닉에는 list 컴포넌트가 있는데, 이것은 목록과 목록내 각 아이템을 위한 클래스들 이다. list 컴포넌트는 스타일을 조정할 수 있는 옵션들이 있는데, 가장 기본적인 형태를 적용하고 아이콘을 추가해 보겠다.
리스트 4.5와 같이 앱에 링크 목록을 추가해 보자. <ul> 태그를 사용할 수도 있지만, 여기서는 div를 사용해서 a 태그 목록을 감싸는 법을 설명하겠다. 이 부분은 중요하게 숙지해야 할 부분인데, CSS 스타일 지정은 매우 완벽하고, 다른 엘리먼트에도 클래스를 적용시킬 수 있기 때문이다.

<< 리스트 시작 >>
  리스트 4.5 홈 뷰에 목록 추가하기 (www/views/home/home.html)
  (위에서 아래)
  이미 선언했던 ionView와 ionContent
  목록 컨테이너로 지정하기 위해 list 클래스 추가
  목록내 아이템으로 지정하기 위해 item 클래스 추가.
<< 리스트 끝 >>

CSS 컴포넌트를 사용한다는 것은 컴포넌트 가이드라인을 따른다는 것이고, 이는 요소에 적절한 CSS 클래스를 지정해야 한다는 것을 의미한다. 다음 장에서 더 복잡한 목록을 보게 될 것이지만, 아이템을 간단히 보여주기 위해서 이 정도면 충분하다. 공식 문서는 여러 가지 다른 모습으로 리스트의 아이템(디바이더, 썸네일 등)들을 표시하는 방법도 설명을 하고 있다.
리스트는 각기 다른 URL로의 링크들을 가지고 있다. 각 뷰를 하나씩 추가하면, 앱에서 그 곳으로 이동할 수 있게 된다. <a> 태그에 item 클래스를 추가하면, 목록내 아이템 표시 형식이 적용된다. 이 세 개의 링크는 세 개의 뷰와 연관되어 있다. (그림 4.1 참고)

<< 글상자 시작 >>
  CSS와 자바스크립트 컴포넌트

  아이오닉 공식 문서를 보면, 컴포넌트가 두 가지 카테고리(CSS와 자바스크립트)로 구별되어 있다는 것을 알게 될 것이다. 자세히 보면 어떤 컴포넌트는 양쪽 영역에 모두 존재하는데, 헤더바나 목록 같은 것들이 그렇다. 왜 두 개가 있는지, 하나가 다른 하나보다 좋은 건지 의아해 질지도 모르겠다.
  어떤 컴포넌트들은 CSS에만 있고(버튼들), 어떤 것들은 자바스크립트에만 있으며(무한 스크롤), 또 어떤 것들은 양쪽에 다 있다(탭). CSS 컴포넌트는 시각적인 표현에 관한 기능을 제공하지만, 기능적 설정이나 인터랙션에 대한 것은 없다. 자바스크립트 컴포넌트는 더 지적이고 상호 작용성을 가지는 컴포넌트이며, CSS 컴포넌트로부터 만들어질 수도 있고 아닐 수도 있다.
  몇 몇 컴포넌트 타입은 CSS와 자바스크립트로 구현되었다. 탭이 그런 경우에 해당된다. CSS 컴포넌트의 룩앤필만 취하고 자바스크립트 버전에서 제공되는 기능은 필요 없는 경우도 있을 수 있다. 아이오닉은 매우 빠르게 작동하긴 하지만, 자바스크립트의 사용을 줄일 수 있다면 오버헤드를 줄이는데 도움이 될 것이다.
  또한, 컴포넌트가 CSS와 자바스크립트 버전을 모두 갖고 있다면, 자바스크립트 컴포넌트를 사용하되, CSS로 외양을 바꿀 수 있다. 이번 장을 예로 들자면, ionNavBar의 색을 바꾸기 위해 CSS 클래스를 사용하고 있다.
<< 글상자 끝 >>

4.3.3 목록 내 아이템에 아이콘 추가하기
이 뷰를 위해 해야 할 마지막 작업은 아이콘을 몇 개 추가하는 것이다. 아이오닉은 Ionicons라는 아이콘 세트를 갖고 있는데, 기본으로 탑재되어 있다. 아이콘은 많은 곳에서 사용되기 때문에 여러분도 빈번히 보게 될 것이다. http://ionicons.com에서 사용할 수 있는 아이콘들이 나열되어 있다. 이 아이콘들은 사실 폰트 아이콘으로, 표준 문자를 아이콘으로 대체한 커스텀 폰트이며 아이콘을 표시하기 위해 CSS 클래스를 사용한다. 다른 아이콘 라이브러리를 사용하고 싶다면(이를테면 Font Awesome과 같은), 충돌 없이 포함시켜 쓸 수 있다.
list 컴포넌트는 아이콘을 사용하는 특별한 표시 형식을 가지고 있다. 추가적인 CSS 클래스를 사용하고 아이콘 엘리먼트를 더하면, 목록 아이템의 텍스트 왼쪽에 아이콘이 보이는 효과를 만들 수 있다. 여러분도 아마 텍스트 왼쪽에 아이콘을 놓고 싶으리라 생각한다. 아이콘을 추가하고 목록 아이템에 새로운 클래스를 지정하는 다음 코드를 적용함으로써 홈 뷰 작업을 마칠 수 있다.

<< 리스트 시작 >>
  리스트 4.6 홈 뷰에 아이콘 추가하기 (www/views/home/home.html)
  (왼쪽부터 오른쪽)
  item-icon-left 클래스를 추가하여 원하는 스타일로 지정
  ion 클래스로 아이콘을 지정하는 이탤릭 엘리먼트 추가
<< 리스트 끝 >>

이것이 바로 아이콘을 포함시키는 가장 일반적인 방법인데, 아이콘이 목록 안에 있기 때문에 item-icon-left라는 특수 클래스를 써야 한다. 아이콘을 오른쪽에 보여주고 싶다면 item-icon-right를 쓰면 된다.
아이콘은 종종 이런 식(<i class="icon ion-calendar"></i>)으로 선언되기도 한다. 원래 <i> 태그는 텍스트를 포함시켜, 그 모양을 변형시키는 인라인 엘리먼트이다. 그러나, 텍스트를 포함시키지 않고, 두 가지 클래스를 지정했다. 첫째는 icon 클래스인데 아이콘이 되기 위한 기본 CSS 스타일을 지정하는 것이고, 둘째는 ion-calendar로써 표시할 특정 아이콘을 지정하는 것이다. 이렇게 하면 인라인 엘리먼트가 아이콘이 된다. 적용된 아이콘과 전체 홈 뷰의 모습은 그림 4.5에서 볼 수 있다.
이제 홈 뷰는 원하는 대로 되었고, 예약뷰로 진행하자. 콘트롤러를 사용하여 정보를 표시하는 법을 알아볼 것이다.

4.4 예약 뷰 구현을 위해 콘트롤러와 모델 사용하기
데이터를 불러오고, 유저와 상호 작용할 목적으로 콘트롤러에 관련 로직을 추가할 일은 굉장히 자주 벌어지는 일이다. 홈 뷰는 딱히 커스텀 로직이라고 할 것이 없는데, 정적인 링크 목록만 표시하기 때문이다. 그러나 예약 뷰는, 사용자에 특화된 데이터를 불러오고 표시할 수 있어야 한다. 예제일 뿐이기 때문에 데이터를 불러오기 위해 진짜 호텔 데이터베이스를 사용할 필요는 없지만, 그래도 데이터를 포함시키려면 콘트롤러를 써야 한다. AngularJS가 처음인 독자라면, 이번 장을 계속 진행하기 전에 3장으로 돌아가 콘트롤러에 대한 섹션을 복습하기 바란다. Git을 사용하여 따라오고 있는 독자라면, step4 태그를 사용하여 코드를 체크아웃 하자.

$git checkout -f step4

아이오닉에서 콘트롤러를 선언하는 것은 3장에서 봤던 AngularJS에서 콘트롤러를 사용하는 패턴과 똑같다. 아이오닉은 자체 프레임워크를 제작하는 대신에 AngularJS를 토대로 만들어져 있고, AngularJS를 이용하고 있다는 사실을 기억해야 한다. 우리는 새로운 콘트롤러를 만들어, 예약 뷰를 위한 모델을 포함시킬 것이다. 이번 작업의 결과물은 그림 4.6과 같다.

<< 그림 시작 >>
  아이콘이 있는 목록(list 컴포넌트, Ionicons)
  데이터 바인딩 ($scope.reservation)
  그림 4.6 콘트롤러에서 데이터를 불러와 바인딩을 하는 예약 뷰
<< 그림 끝 >>

AnguarJS에서 모델을 만들기 위해 $scope 객체에 값을 추가했던 3장의 내용을 복기해보자. 그 때와 마찬가지 방법으로 도착과 출발 일자, 방 번호와 같은 예약 상세 정보를 위한 속성을 객체에 추가할 것이다. 다음 리스트의 콘트롤러를 확인하고, www/views/reservation/reservation.js 파일을 추가한다.

<< 리스트 시작 >>
  리스트 4.7 예약 콘트롤러 (www/views/reservation/reservation.js)

  (왼쪽 -> 오른쪽. 위 -> 아래)
  체류 날짜 설정. 자동으로 오늘부터 다음주까지 계산
  예약을 위한 다른 정적 값들
  앱 모듈 참조
  reservation 모델 객체를 $scope에 추가
  콘트롤러 선언. 이름과 함수를 제공하며, 함수는 $scope와 같은 주입할 객체 목록을 가진다.
<< 리스트 끝 >>

이 콘트롤러는 많은 일을 하지는 않지만, 사용자의 데이터를 저장할 장소를 제공하고 AngularJS의 바인딩 기능을 사용한다. 홈 뷰에 이런 기능을 넣지 않은 이유는, 홈 뷰의 아이템 목록은 매우 간단하고 정적 정보이기 때문이다. 여기서 표시되는 정보가 유저에 따라 어떻게 바뀌는지, 콘트롤러에서 어떻게 불러오는지 보게 될 것이다.
이 콘트롤러는 정보를 뿌려주기 위해 home.html 파일과 같은 템플릿이 필요하다. 예약 뷰는 홈 뷰처럼 목록을 가지고 있고, 아이콘도 몇 개 포함하고 있다.
이 템플릿과 홈 템플릿 사이의 중요한 차이점은 콘트롤러로부터 템플릿으로 데이터를 바인딩하는 것이다. 바인딩 할 때에 AngularJS 필터도 사용할 것인데, 필터는 모델의 데이터를 다른 표시 형식으로 변환시키는데 아주 유용한 방법이다. 진행하면서 AngularJS 표현식도 약간 다룰 것이다.
리스트 4.8은 방금 만든 콘트롤러를 위한 예약 뷰이다.

<< 글상자 시작 >>
  프로젝트내 파일 구조 잡기

  아마도 지금쯤이면 필자가 파일을 뷰 단위로 모아서 관리하는 이유를 좀 더 명확히 알게 되었으리라 생각한다. 이렇게 하면 연관된 파일들을 묶어 준다. 많은 AngularJS 튜토리얼은 자바스크립트를 한 곳에 묶고, HTML파일들은 따로 묶어서 연관된 파일들을 추적하기 힘들게 한다. 이 다음에 CSS 파일도 뷰폴더에 함께 묶는 것을 보게 될 것이다. 하나의 뷰에 관련된 모든 파일을 한 곳에 모아두는 것은 필자의 작업 효율을 크게 향상 시켜왔다. 더이상 연관 코드가 어디 있는지 찾는데 귀중한 시간을 쓰지 않는다.
  여러분은 나의 방식을 따라할 필요는 없지만, 이 방식은 다년간 AnguarJS로 애플리케이션을 개발하면서 선호하게 된 방식이며, 이 책에는 그렇게 적용되었다.
<< 글상자 끝 >>

<< 리스트 시작 >>
  리스트 4.8 예약 뷰 템플릿 (www/views/reservation/reservation.html)

  (왼쪽 위->아래)
  콘텐츠 표시를 위한 래퍼 추가
  바인딩에 필터를 사용한 리스트 아이템. 여기서는 날짜 형식 지정
  (오른쪽 위->아래)
  제목이 Reservation인 뷰 선언
  list 컴포넌트 클래스로 목록 감싸기
  아이콘과 함께 아이템을 표시. 템플릿에 방 번호를 바인딩.
  (뒷장)
  표현식과 필터로 바인딩
<< 리스트 끝 >>

얼핏 보면 홈 뷰와 매우 유사해 보인다. 그러나 콘트롤러의 모델($scope.reservation)에 데이터를 추가하고 템플릿에서 표시하기 위해 AngularJS의 바인딩을 사용하였다. 바인딩은 AngularJS에서는 매우 일상적인 행위이고, 여러분도 자주 사용하게 될 것이다. {{}} 사이에 있는 것은 무엇이든 AngularJS의 표현식으로 해석된다. 이 표현식은 $scope으로 데이터를 바인딩하는 것은 물론이고, 수식을 쓰면 자동적으로 계산된다. 표현식과 데이터 바인딩을 좀 더 깊이 설명했던 3장을 참고하자.
예제의 {{reservation.rate * 7 | currency}} 부분을 좀 더 들여다 보자. 우선 파이프 문자(|)를 기준으로 두 부분으로 나눠져 있다. 왼쪽은 표현식이고 오른쪽은 필터이다. 표현식을 보면 하루 요금에 7을 곱함으로써 일주일 비용을 계산할 수 있다. reservation.rate는 $scope의 속성을 조사함으로써 값을 얻으려고 한다. 만약, 이 값이 존재하지 않는다면, 표현식은 실패가 되고 아무것도 보이지 않는다. 필터는 선택사항인데, AngularJS의 currency 필터를 쓰게 되면, 브라우저의 정보에 기반해 판단한 현지 화폐 단위 형식으로 표현된다. 그렇다고 해서 reservation.rate 속성 값이 바뀌지는 않는다. 다만, 표현 방법만 변형될 뿐이다.
표현식에 관련된 많은 트릭과 가능한 기능들이 있지만, 가장 많이 쓰는 방식은 역시 바인딩 된 데이터를 뷰에 그냥 보여주는 것이다. 이 부분은 나중에 날씨 뷰에서 다시 보게 될 것이다. 다음 뷰로 넘어가기 전에 이 뷰에 대한 애플리케이션 상태를 설정해야 한다. 예약 뷰 관련 파일들을 가지고 있지만, 아직 애플리케이션에게 언제 띄우라고 말해주지 하지 않았다. app.js 파일을 다시 열고, 다음 리스트를 참고해서 새로운 상태를 추가한다. 홈 뷰에 대한 선언 다음에 세미콜론 없이 바로 붙여 쓴다.

<< 리스트 시작 >>
  리스트 4.9 예약 상태 선언 (www/js/app.js)
  (왼쪽에서 오른쪽, 위에서 아래)
  불러 올 뷰 파일 선언
  reservation이라는 새로운 상태 선언
  /reservation URL에 대해 처리
  이 뷰를 위한 콘트롤러의 이름 지정
<< 리스트 끝 >>

좋다. 이제 뷰도 선언했고, 작동해야 할 터이다. 실제로 그런가? 실은 아직 할 것이 남아있는데, 이 작업은 잊어버리기 쉬운 종류의 것이다. 애플리케이션을 개발하면서 새로운 자바스크립트 파일을 하나 만들었지만, 아직 index.html에 추가하지 않았다. 자바스크립트 콘솔에서 ResercationController가 정의되지 않은 개체라는 오류를 보게 된다면, 아직 그 파일을 추가하지 않았거나 문법상 오류가 있는 상황이다. 다음의 선언을 index.html 파일의 </head> 앞에 추가한다.

<script src="views/reservation/reservation.js"></script>

이제 앱을 실행시켜 예약 상세 내용을 보기 위한 링크를 탭 할 수 있다. 그림 4.6과 같은 모습이 되어야 한다. 뒤로 가기 버튼이 나타나는 것을 볼 수 있는데, 자식 뷰로 네비게이션을 할 때마다 뒤로 가기 버튼이 자동으로 나왔다가 숨었다가 할 것이다. 홈 뷰에서는 숨겼기 때문에 예약 뷰와 같은 자식 뷰로 이동하면 뒤로 가기 버튼이 보일 것이다. 한 가지 염두해야 할 것은, 예약 뷰를 보고 있는 상태에서 새로 고침을 하면 뒤로 가기 버튼이 사라진다는 것이다. 이것은 예약 뷰에서 첫 방문을 한 것으로 간주되기 때문에 히스토리 상에서 뒤로 갈 곳이 없기 때문이다. 그러므로, 홈으로 돌아갈 수 없어 갇힌 상태라면, 브라우저의 주소 표시줄에 URL을 http://localhost:8100로 지정해서 이동하면 되겠다.

4.5 날씨 뷰에 데이터 불러오기
여러분이 열대 지방의 리조트에 있다면 일기 예보가 맑고 따뜻한지 알아두면 좋을 것이다. 해변으로 왔다면 물놀이에 좋은 날씨가 금상첨화일 것이다! 다음으로 우리가 만들 뷰는 외부 서비스로부터 날씨 데이터를 불러올 것이다. 이런 데이터를 제공하는 서비스는 많이 있는데, 여기서는 오픈 웨더 맵(Open Weather Map)을 사용하려고 한다. 무료이며 오픈 API를 제공한다. 다른 서비스도 있지만 계정이 필요하거나 돈을 지불해야 할지도 모른다. Git으로 진도를 따라오고 있다면 step5 태그로 체크아웃 하기 바란다.

$ git checkout -f step5

예약 뷰와 마찬가지로 AngularJS 콘트롤러가 필요하다. 이 콘트롤러는 오픈 웨더 맵으로부터 데이터를 불러와 모델에 저장하고 뷰에서 바인딩을 할 수 있게 한다. 데이터 로딩을 처리하기 위해 AngularJS의 $http 서비스를 사용할 것이다. 오픈 웨더 맵에 요청을 전송하는 프록시 API를 만들어 두었기 때문에 설사 오픈 웨더 맵 서비스가 다운이 되더라도 여전히 작동할 것이다.
이 뷰는 앞서 만든 것과는 다른 내용을 담는 아이템 목록이다. 즉, 온도, 조건, 낮 최고 기온과 최저 기온, 풍속과 풍향 같은 것들이다. 한편 정보를 계산하기 위해 템플릿의 표현식에서 $scope 메소드를 사용하는 방법도 알아 본다. 예컨대, 각도로 주어진 풍향 정보를 변환해 동서남북 방위로 표현한다.
외부 서비스로부터 정보를 불러올 때는 다소 시간이 소요된다. 지금까지는 뷰로 이동하면 정보가 즉시 나타났는데, 이번에는 날씨 데이터가 로딩될 때까지는 보여줄 수 없다. 1초 내로 응답이 올 수도 있고 몇 초가 걸릴 수도 있는데, 네트웍의 속도나 서버의 응답 속도, 기타 여러 가지 변수(대부분 우리가 통제할 수 없는)에 달려있다. 더 나은 사용자 경험을 제공하기 위해서 데이터가 로딩되는 동안에 로딩 인디케이터를 보여줄 수 있는 $ionicLoading 서비스를 다루는 법도 알려주겠다.

<< 그림 시작 >>
  (왼쪽에서 오른쪽)
  기상 상황 목록 (list 컴포넌트)
  API로 불러온 데이터 바인딩($scope.weather)
  각도를 방향으로 변환하는 표현식 ($scope.getDirection(deg))

  그림 4.7 날씨 뷰: 불러오기 전(left)과 후(right)
<< 그림 끝 >>

그림 4.7은 지역 날씨의 상세 내용을 실제로 불러와서 표시한 화면이다.
템플릿 파일을 추가한 후 콘트롤러도 추가하고 데이터를 불러오는 단계를 구현한 다음, 표시하는 순서로 구현해보자.

4.5.1 날씨 뷰에 사용할 템플릿 추가
날씨 뷰를 위한 템플릿은 간단한 편이다. 기상 상황을 목록으로 보여주기만 하면 된다. 리스트를 만들고 불러올 데이터의 값을 바인딩한다. 이제 다루려고 하는 새로운 AngularJS 표현식 하나를 제외하면 대부분은 이미 익숙할 것이다.
날씨 뷰를 위한 파일을 www/view/weather/weather.html로 하나 만들고 다음 리스트의 코드를 입력하자.

<< 리스트 시작 >>
  리스트 4.10 날시 뷰 템플릿 (www/views/weather/weather.html)

  뷰를 선언하고 navBar의 제목을 지정
  콘텐츠를 감쌀 컨테이너
  (뒷장)
  날씨 객체의 속성 데이터를 바인딩하는 아이템 목록 추가
  이 아이템은 두 개의 바인딩을 갖고 있다. 두번째는 스코프의 메소드를 호출한다.
<< 리스트 끝 >>

새로운 뷰를 만들고 제목을 "현재 날씨"라고 붙였다. 콘텐츠 영역의 위치를 관리하기 위한 콘텐츠 컨테이너의 역할을 한다. 리스트에서 'list' CSS 클래스를 또 사용했는데, 날씨의 상세를 나열하기 위한 간단한 방법으로 이용했다.
이 템플릿은 좀 더 복잡한 바인딩을 갖고 있는데, 오픈 웨더 맵이 반환하는 데이터가 AngularJS에 의해 자바스크립트 객체로 변환되는 JSON 문자열 형식이기 때문이다. 브라우저에 http://api.openweathermap.org/data/2.5/ weather?q=London,uk를 입력하고 이동해보면 오픈 웨더 맵 API가 반환하는 날씨 데이터의 형식을 확인 해 볼 수 있다.
나머지 부분과 약간 다른 한 표현식에 대해서 좀 더 설명을 해야 겠다. 목록내 마지막 아이템을 보면 {{getDirection(weather.wind.deg)}}를 볼 수 있을 것이다. 이 표현식은 실제로는 콘트롤러의 $scope에 연결되어 있는 메소드를 참조한다. 아직 이 메소드를 구현하지는 않았지만, 여튼간에 이 메소드는 이름이 getDirection이고 인수를 한 개 받는데, 바로 각도로 표현된 바람의 방향이다. 필요한 경우에 메소드를 이와 같은 표현식을 사용하여 쓸수 있다.

4.5.2 외부 데이터를 불러오기 위한 콘트롤러 만들기
이제 콘트롤러를 만들고 데이터를 불러올 시간이다. URL을 통해 데이터를 불러오기 위해 AngularJS의 $http 서비스를 사용할 것이다. 콘트롤러에 $http를 주입하고, 해당 URL에 GET 요청을 보내고, 이에 대한 성공과 실패를 처리한다. 콘트롤러를 만들기 위해 www/views/weather/weather.js 라는 새파일을 만들고, 다음 리스트의 내용을 작성한다.

<< 리스트 시작 >>
  리스트 4.11 날씨 뷰 콘트롤러 (www/views/weather/weather.js)
  (맨윗줄)
  가능한 풍향을 담고 있는 배열
  App 모듈을 참조
  콘트롤러를 선언하고 $scope와 $http 주입
  (왼쪽면 두 개)
  에러처리는 나중에 여기서 처리됨
  풍향을 계산
  (오른쪽 4개, 위에서부터 순서대로)
  날씨 데이터를 $scope.wather 모델에 대입
  성공 응답을 처리. 반환된 날씨 오브젝트를 얻는다.
  지정한 URL로 데이터를 불러오기 위해 HTTP 요청을 보냄
  숫자로 표현된 방향 값을 풍향 배열 내의 값으로 변환하기 위한 메소드
<< 리스트 끝 >>

이 콘트롤러는 유저가 뷰를 열 때마다 자동으로 날씨 데이터를 불러올 것이다. $scope.weather 모델로 불러오면, 템플릿이 해당 데이터를 바인딩 할 수 있다. 브라우저의 개발자 도구를 이용해서 API 호출에 대한 응답으로 어떤 것이 돌아왔는지 확인할 수 있다. 여튼, 이것이 URL을 가지고 나의 애플리케이션으로 데이터를 불러오는 가장 기본 방법이다.
아직 API가 데이터를 돌려주지 않은 경우에 대한 오류를 처리하지 않았다. 이 부분은 다음 섹션에서 추가할 예정이지만, 중요한 것은 언제나 $http 에 대한 에러에 대한 처리는 해야 한다.
getDirection 메소드는 각도로 표시된 풍향 값을 인수로 받아 방향 배열에 입력된 좀 더 친근한 방위 값으로 변환해서 반환한다. AngularJS의 필터를 이용해도 적절히 구현할 수 있긴 하지만, 이번 예제의 목적상 굳이 이런 방식도 사용해 보았다.
방금 만든 뷰를 상태 목록에 추가하고, 새로 만든 콘트롤러를 포함시키기 위해 <script> 태그도 추가하자. 먼저 app.js 파일을 열어 다음 리스트와 같이 상태 목록의 마지막 부분에 새로운 상태를 추가한다.

<< 리스트 시작 >>
  리스트 4.22 날씨 뷰에 대한 상태를 선언 (www/js/app.js)
  (왼쪽에서 오른쪽)
  상태 정의를 위해 URL, 콘트롤러, 템플릿 값 추가
  날씨 상태를 선언하고, 현재의 목록에 추가
<< 리스트 끝 >>

index.html 파일을 열고 날씨 콘트롤러를 로딩하기 위해 </head> 태그 바로 앞에 다음의 <scrip> 태그를 추가한다.

<script src="views/weather/weather.js"></script>

이제 ionic serve를 실행해서 현재까지 제작한 앱을 확인하자. 날씨 링크를 선택하면 날씨 뷰가 열릴 것이다. 데이터가 로딩될 때까지 잠깐 동안은 뷰는 열리지만 바인딩된 데이터 쪽은 비어 보일 것이다. 이런 모습이 그렇게 보기 좋지는 않고, 사용자를 혼란스럽게 할 수도 있다. 데이터 로딩 중임을 알리는 인디케이터 추가는 더 나은 사용자 경험을 위해 중요한 일이다. 해 보자.

4.5.3 날씨 뷰에 로딩 인디케이터 추가
불러오기 화면은 로딩이 끝날 때까지 사용자가 앱을 사용할 수 없게 만든다. 이 때문에 어떨 때 쓰는게 적절할 지, 또는 사용자의 앱 이용을 불필요하게 막는 것은 아닌지 고민해야 한다. 데이터를 완전히 불러올 때까지 앱 사용을 멈춰야 한다면, 이런 인디케이터 컴포넌트는 간편한 방법이 된다. 예를 들어, 앱이 구동되면서 계정 정보를 불러오는 경우에 불러오기 화면을 표시할 수 있는데, 불러오기 전에는 할 수 있는게 없기 때문에 적절한 경우가 된다. 그림 4.8을 참고하자.

<< 그림 시작 >>
  (왼쪽 하나)
  배경의 오버레이는 로딩 중에는 사용할 수 없도록 막는다.
  (오른쪽 둘, 위에서 아래로)
  아직 데이터 로딩이 되지 않아, 빈 값으로 보여짐
  로딩 인디케이터 ($ionicLoading service)

  그림 4.8 API를 통해 데이터를 불러오는 동안에 로딩 인디케이터가 활성화 된 날씨 뷰
<< 그림 끝 >>

로딩 컴포넌트는 show()와 hide()라는 두 개의 메소드를 가지고 있다. 언제 로딩이 끝나는지 자동으로 알지 못하기 때문에, 로딩 컴포넌트를 숨겨야 할 경우에는 명시적으로 hide()를 호출해야 한다.
예제의 경우, HTTP 요청이 완료 될 때까지 로딩 인디케이터를 보여주고 싶다. 그러므로, 요청을 보내기 바로 전에 show()를 호출하고, 응답이 왔을 때 hide()를 호출하면 된다. 앞서 말했듯이 로딩 인디케이터는 스스로 숨길 타이밍을 알지 못하기 때문에 자동으로 숨겨지는 일은 없다.
로딩 컴포넌트는 자바스크립트만 사용하기 때문에 콘트롤러의 구현만으로 끝난다. 날씨 콘트롤러 파일을 열고 다음 리스트의 내용을 추가해보자.

<< 리스트 시작 >>
  리스트 4.13 로딩 컴포넌트를 날씨 뷰에 추가하기(www/views/weather/weather.js)

  (위애서 아래로)
  $ionicLoading 서비스를 콘트롤러에 주입
  HTTP 요청이 시작되기 직전에 로딩 컴포넌트를 표시
  응답이 성공하면 로딩 컴포넌트를 숨김
  에러가 발생하면 로더에 메세지를 표시하고, 3초후에 닫음.
<< 리스트 끝 >>

수정된 콘트롤러를 보면, 로딩 컴포넌트가 어떻게 보여지고 숨겨지는지 알 수 있을 것이다. 우선 $ionicLoading 서비스를 주입해야 한다. 아이오닉 서비스는 AngularJS를 기반으로 하기 때문에, 주입하는 방식도 AngularJS의 그것(이를테면 $http)과 동일하다.
show()는 비동기 명령이 실행되기 전에 사용되었다. 자바스크립트로 구현된 HTTP 요청은 언제나 비동기로 동작하며, HTTP 응답이 완료되었을 때 여러분이 어떤 처리를 할 지 선택할 수 있도록 success와 error 메소드를 제공한다. 바라던 대로 성공적이면 hide()를 호출하기만 하면 된다. 그러나 오류가 발생한 경우라면 로딩 컴포넌트를 에러 메세지 표시를 위해 재설정한다.
두 번째 show()는 3초 뒤에 자동으로 닫을 것인데, 이 경우에는 에러를 표시하기 위해 사용하고 있기 때문이다. 작동 방식을 변경하는 설정을 포함하는 객체를 인수로 받는데, 이 객체를 통해 메세지를 표시하는 등의 커스터마이징을 할 수 있다.
로딩 컴포넌트는 한 번에 하나만 존재할 수 있다. 따라서 show 메소드를 두 번 호출했다고 해서 두 개가 생기는 것이 아니고, 이미 보여지고 있는 컴포넌트에 새로운 설정이 적용될 뿐이다. 여러 개의 비동기 이벤트가 발생하는 상황에서는 중요한 점이다. 언제 컴포넌트를 숨길지 적절히 선택하도록 로직을 짜야 한다. 예를 들어, 두 개의 별도 HTTP 요청으로 데이터를 불러오는 차트를 표시하는 경우, 로딩 컴포넌트를 숨기기 전에 두 개의 요청이 완료되어야 할 지, 아니면 하나라도 먼저 끝나면 바로 표시를 하고 두 번째 요청이 완료될 때 추가를 할 것인지 결정해야 한다.
한편, 에러가 발생 했을 때 사용자가 피드백을 남길 수 있게 하는 컴포넌트의 사용을 고려해 볼 필요도 있다. 이 부분은 뒷 장에서 다를 것이다. 에러 타입에 따라 다르게 동작하기를 원할 수 있다. 예컨대, 날씨 API가 일시적으로 다운 되었다는 메세지를 받았을 때 잠시 기다렸다가 다시 데이터 로딩을 시도할 수도 있는 것이다.
다음으로 만들어 볼 것은 식당 목록 뷰인데, 카드 형식의 UI 사용과 무한 스크롤링 컴포넌트를 다루어 볼 것이다.

4.6 레스토랑 뷰를 위한 카드 UI 무한 스크롤링
식당 뷰에서는 리조트 손님들이 즐길 수 있는 현지 식당의 목록을 보여주려고 한다. 이를 위해 외부 웹사이트로부터 식당 목록을 불러오고, 카드 컴포넌트를 사용해서 식당의 이름과 사진을 보여줄 것이다. 거기에 더하여 무한 스크롤을 사용해서 목록의 맨 아래에 도착할 즈음에 추가로 장소를 불러오려고 한다.
카드는 목록의 변형된 형태로 리스트 4.14를 보면 알게 될것이다. 카드 컴포넌트는 많은 앱에서 애용되는 형태인데, 아이템을 깔끔하고 멋져 보이기 때문이다. 카드 UI는 어느 정도의 비주얼 콘텐츠와 그렇지 않은 나머지를 섞어 보여주기에 최고이다. Git을 사용해서 따라오고 있다면 step6 태그로 체크 아웃하자.

$ git checkout -f step6

예제에서는 이 책을 위해 만들어진 API를 통해 데이터를 불러온다. 그림 4.9의 뷰를 보면 카드 목록이 있고, 아래로 스크롤 할 때 무한 스크롤 로딩 인디케이터가 추가 아이템을 불러올 때까지 표시되는 것을 볼 수 있다.
www/views/restaurants/restaurants.html 파일을 만들고 다음 리스트의 코드를 입력하자.

<< 리스트 시작 >>
  리스트 4.14 식당 뷰 템플릿 (www/views/restaurants/restaurants.html)

  왼쪽에서 오른쪽
  카드 목록을 만들고 ngRepeat 사용
  뷰 선언
  (뒷장)
  카드 아이템은 이름과 식당의 위치를 표시
  카드는 이미지와 같은 다른 목록 형식을 사용할 수 있다.
  무한 스크롤 엘리먼트는 목록의 하단 어디쯤 왔을 때 getRestaurants()를 호출한다.
<< 리스트 끝 >>

목록 아이템에 card 클래스를 추가하면 카드 표현을 만들 수 있다. 각 카드는 그 자체로 목록이지만, 각 식당에 대한 새로운 카드를 만들기 위해서 ngRepeat를 사용한다. 이 뷰의 가장 큰 차이점은 ionInfiniteScroll 컴포넌트의 포함이다.
무한 스크롤은 꽤 단순한 규칙으로 작동한다. 컴포넌트가 뷰 영역의 특정 거리 안에 있으면(기본값은 1%), on-infinite 어트리뷰트에 선언한 메소드를 호출하는 것이다. 시작시 뷰는 식당 정보가 없기 때문에, 로딩 인디케이터를 표시하고 초기 데이터 세트를 불러오기 위해 getRestaurants() 메소드를 호출할 것이다. 한번 불러온 후에 무한 스크롤 컴포넌트는 로딩 인디케이터를 숨길 것이고, 아이템 목록의 아래쪽으로 밀려 내려간다. 사용자가 아래로 스크롤할 때, 다시 트리거가 발동한다. 무한 스크롤의 특이한 행동 때문에 실제로 두 번의 로딩 메소드가 호출될 수도 있다. 이를 교정하기 위해서 무한 스크롤의 immediate-check 어트리뷰트를 false로 설정하여 시작시 무한 스크롤러가 로딩을 하지 못하게 하고, 콘트롤러에서 직접 데이터를 불러온다.

<< 그림 시작 >>
  카드의 텍스트 영역
  카드 이미지
  스크롤을 하면, 더 많은 카드가 나타남

  그림 4.9 로컬 식당에 대한 카드와 무한 스크롤을 가지고 있는 식당 뷰
<< 그림 끝 >>

무한 스크롤 컴포넌트는 데이터가 반환되는 한, 그리고 볼 수 있는 상태가 된다면 언제든지 데이터를 요청할 것이다. 그러나 더 이상 불러올 데이터가 없는 상황에서는 더이상 요청을 보내지 않도록 해야 한다. ngIf 표현식은 무한 스크롤이 서비스로부터 가능한 데이터를 모두 받았을 경우 불능 상태로 만든다. 콘트롤러에서 이 로직을 구현해야 하는데, API는 가능한 데이터의 페이지 수만 값으로 반환하기 때문에 이미 불러온 데이터가 몇 개인지 내부에서 확인하고 있어야 한다.
이제 뷰에 대한 콘트롤러를 추가해보자. 이 콘트롤러는 식당 데이터를 불러오기 위한 처리를 해야 하고, 무한 스크롤 컴포넌트에 새로운 데이터가 불려졌음을 알려 스스로 숨김 처리를 할 수 있게 해줘야 한다. 다음 리스트의 코드는 www/views/restaurants/restaurants.js에 있는 콘트롤러의 코드이다.

<< 리스트 시작 >>
  리스트 4.15 식당 뷰 콘트롤러(www/views/restaurants/restaurants.js)

  (번호없는 것) 콘트롤러를 생성하고 서비스 주입
  1. 뷰를 위한 스코프 변수 생성
  2. 식당을 불러 올 메소드 정의
  3. 페이지 수를 증가시키고 데이터를 위한 HTTP 요청 생성
  4. 식당 목록을 받아서 ngRepeat를 위한 식당 배열에 추가
  5. API가 보낸 값에 따라 전체 페이지 수를 업데이트
  6. 무한 스크롤 컴포넌트에 모든 것이 완료되었음을 알리는 이벤트를 브로드캐스트
  7. 무한 스크롤에 브로드캐스팅하고 에러 로그를 남김으로써 에러 처리
  8. 페이지 로딩시 식당 첫 페이지 데이터 불러오기
<< 리스트 끝 >>

리스트 4.15는 page, total, restaurants 세 개의 변수로 시작한다. page 변수는 API 요청으로 받은 마지막 페이지를 기록하기 위한 것이고, total은 불러올 수 있는 전체 페이지 수를 저장한다(처음 API 호출로 얻어온다). restaurants는 빈 배열로 선언되는데, 식당 목록을 생성하기 위한 ngRepeat에 사용될 것이다.
날씨 콘트롤러와 마찬가지로 데이터 로딩을 위해 API를 호출해야 한다. 스코프 메소드 getRestaurants()에 구현되는데, 이 메소드는 반복적으로 호출될 것이다. 무한 스크롤이 추가로 데이터를 더 불러 올때마다, getRestaurants()가 호출될 것이다. 이 메소드는 일단 페이지 값을 증가시키고 HTTP 요청을 만든다. 데이터가 반환되면, 결과 값을 restaurants 배열에 추가한다. 또한 total 값에 가능한 페이지 수를 대입시킨다.
무한 스크롤이 발동되고 getRestaurants()가 호출될 때, 스크롤 컴포넌트는 HTTP 요청이 완료되는 시점을 알지 못한다. 모든 작업이 완료되면 $scope.$broadcast('scroll.infiniteScrollComplete')를 호출해서 알려줄 수 있는데, 스크롤 컴포넌트가 완료되도록 메세지를 전달한다. 이 이벤트가 발생하면, 무한 스크롤은 로딩 에니메이션을 중단한다. 그렇지 않은 경우에는 계속 에니메이션이 실행될 것이다. 한편, 에러가 발생했을 때는 에러 로그를 콘솔에 남기고 컴포넌트에 완료를 알려준다. 코드의 마지막 줄은 getRestaurants()를 호출함으로써 초기 데이터를 불러오는 부분이다.
작동하는 것을 보기 위해서, 이번에 만든 뷰를 상태에 추가해야 한다. 늘 해왔듯이 app.js 파일에 식당 뷰를 위한 새로운 상태가 추가되어야 한다.

.state('restaurants', {
          url: '/restaurants',
          controller: 'RestaurantsController',
          templateUrl: 'views/restaurants/restaurants.html'
});

또한, 새로운 콘트롤러 파일은 index.html에 로딩되어야 한다.

<script src="views/restaurants/restaurants.js"></script>

이제 앱을 실행시켜 식당 목록이 카드 목록으로 표시되는 것을 볼 수 있다. 마지막 목표는 앱 설명을 추가하는 것으로, 간단한 소개와 이 앱이 어떤 것인지 살펴보는 슬라이드 세트를 포함할 것이다. 슬라이드 박스 컴포넌트를 사용하는 방법을 살펴보고 만들어 보자!

4.7 둘러보기 기능을 위해 슬라이드 박스 컴포넌트 사용하기
리조트 측에서는 처음 누군가가 앱을 사용할 때 이 앱의 기능을 빠르게 둘러볼 수 있기를 원한다. 이를 위한 방법은 여러 가지가 있겠지만, 여기서 택한 방법은 ionSlideBox 컴포넌트로 세 가지 중요한 특징을 간단한 슬라이드로 보여주는 것이다. Git을 사용하고 있으면, 예제를 마치기 위해 step7로 체크아웃 한다.

$ git checkout -f step7

슬라이드 박스는 많은 곳에서 다양한 방법으로 사용된다. 제품의 이미지 목록을 넘겨보기 형식으로 멋지게 보여주거나 제안하는 아이템을 로테이팅 방식으로 돌려보게 할 수 있다. 슬라이드 박스로 자동으로 실행되는 슬라이드 쇼를 만들수도 있고, 유저가 아이템을 직접 넘겨보게 할 수 있다.
$ionSlideBoxDelegate 서비스는 프로그램 상에서 슬라이드 박스를 제어해야 할 때 사용할 수 있다. 예를 들어, 버튼이 있는데, 탭하면 특정 슬라이드로 바로 갈수 있도록 슬라이드 박스를 제어할 때 사용할 수 있다. 여기서는 그 서비스를 쓰지는 않을 것이지만, 슬라이드 박스의 작동을 더 제어할 필요가 있을 때 도움이 될 것이다. 한편, 같은 뷰에 안에서 슬라이드 박스를 여러 가지 방법으로 이용할 수 있는데, 각각을 독립적으로 제어할 수 있다. 슬라이드 박스 서비스는 각각의 슬라이드 박스 인스터스에 이름을 붙이고, 이를 이용해서 개별적으로 다룬다.
예제에서는 둘러보기를 위해 슬라이드 박스를 사용하여 세 장의 슬라이드를 보여줄 것이다. 여기에 약간의 CSS를 추가할 것이다. 기본 설정이 콘텐츠의 기본 사이즈에 맞추도록 되어 있는데, 우리는 풀 스크린으로 보여주고 싶기 때문이다. 슬라이드 박스의 동작에 대해서는 그림 4.10을 참고하자.

<< 그림 시작 >>
  (위에서 아래로)
  둘러보기를 마치기 위한 네비게이션 바 버튼
  세 장중 첫 장을 보여주고 있는 슬라이드 박스(ionSlideBox)
  슬라이드 콘텐츠: 큰 아이콘과 텍스트(Ionicons)
  슬라이드 박스 페이저
  그림 4.10 둘러보기 뷰에 사용된 슬라이드 박스 컴포넌트
<< 그림 끝 >>

슬라이드 박스를 추가하는 방법을 살펴 보자. 대부분의 경우에는 이 컴포넌트를 보여주기 위해서 마크업만 추가하면 된다. 다음 리스트는 해당 뷰 템플릿을 위한 코드를 나타내는데, www/views/tour/tour.html이라는 새파일을 만들고 입력한다.

<< 리스트 시작 >>
  리스트 4.16 둘러 보기 뷰 템플릿 (www/views/tour/tour.html)

  (왼쪽 두개)
  뷰를 선언하고 CSS에서 활용할ID를 지정
  ionSlideBox는 콘텐츠를 내부에 포함하며 페이저를 사용한다
  (오른쪽 두개)
  사용자가 홈 뷰로 돌아갈 수 있도록 네비게이션 바에 버튼을 추가
  각각의 ionSlide는 슬라이드 박스에 신규 슬라이드로서 자동으로 추가됨
<< 리스트 끝 >>

슬라이드 박스를 위한 태그명은 매우 명확해서 개발자들이 이해하기 쉽다. 세 개의 슬라이드를 포함하고 있으며, 각각은 아이콘과 앱에 대한 약간의 정보를 헤더 태그로 포함하고 있다. 슬라이드 박스의 크기는 계산된 콘텐츠의 크기와 같다. 왜냐하면, 현재로써는 아이콘과 헤더 태그가 표준 HTML 엘리먼트로 선언되어 있기 때문인데, 슬라이드 박스의 높이가 텍스트의 높이와 같다.
그러므로, CSS 스타일을 적용해서 이 점을 개선시키고자 한다. ionView에 id를 추가했는데, CSS를 추가할 때 이것을 이용하려고 한다. 필자는 CSS에 -view 접미어를 붙이는 것을 선호하는데, 이렇게 하면 내가 만든 스타일이 다른 영역에는 영향을 주지 않음을 확신하기가 쉽기 때문이다. 그러나, 여러분은 각자의 기호에 따라 CSS 셀렉터명을 정하면 되겠다.
이제 앱에 CSS를 추가할 때가 되었다. 둘러 보기에 원하는 디자인을 적용하기 위해 세 개의 스타일 블럭을 정의한다. www/views/tour/tour.css 파일을 새로 만들고, 다음 리스트의 내용을 입력한다.

<< 리스트 시작 >>
  리스트 4.17 둘러 보기 뷰를 위한 CSS (www/views/tour/tour.css)

  슬라이더 높이를 화면에 맞춤
  (다음 페이지)
  슬라이드 top에 패딩을 주고, 콘텐츠는 중앙 정렬
  아이콘을 크게 만들고, 인라인 블럭으로 표시
<< 리스트 끝 >>

www/index.html에 CSS 참조를 추가하여 스타일을 로딩할 수 있도록 하자.

<link href="views/tour/tour.css" rel="stylesheet">

본 CSS는 아이콘의 크기를 키우고, 콘텐츠를 중앙에 정렬하며, 높이를 화면의 크기에 맞춘다. 이렇게 하면 사용자가 화면 전체 영역에서 스와이핑하여 슬라이드를 넘겨보기가 쉬워진다(상단의 헤더 바는 제외). 이게 없으면, 사용자가 콘텐츠 영역 내에서만 스와이핑을 해야만 한다. 여러분의 입맛에 맞게 스타일을 바꾸거나 개선시키면 되는데, 보여지는 콘텐츠의 성격에 따라 상당히 바꿔야 할 수도 있다.
마지막 단계는 새로 만든 뷰를 위한 상태를 추가하는 것으로, 앱이 처음에 열리면 둘러 보기가 보이도록 디폴트 상태도 바꾸는게 좋겠다. app.js 파일을 다시 열고, 새로운 상태를 추가하고, otherwise()의 인자도 바꾸어 주자.

<< 리스트 시작 >>
  리스트 4.18 둘러 보기 상태를 추가하고 기본 라우팅 상태를 수정 (www.js/app.js)

  (위에서 아래로)
  둘러 보기 상태를 추가
  둘러 보기 상태로 이동하도록 otherwise() 라우팅을 수정
<< 리스트 끝 >>

이것으로 앱 제작은 끝이 났다. 앱을 시작하면 맨 먼저 둘러보기가 뜨고, 홈 뷰로 이동할 수 있다. 만일 라이브 리로드 기능을 켜고 개발을 하는 중이라면, 둘러보기로 리디렉션이 안 일어날 수도 있다. 그런 경우, 주소 표시줄의 URL에서 /#/ 뒷 부분은 제거하고 열어보자. 라우팅이 초기화 되고 둘러 보기로 이동될 것이다.

4.8 도전 주제들
지금까지 모바일 앱의 네비게이션 인터페이스를 구성하는 방법에 대해서 많은 것을 배웠다. 좀 더 깊이 이해하기 위해서 이번 장의 예제를 개선시킬 몇 가지 도전적인 주제를 나열해 보았다.
  * 새로운 상태 추가 - 앱에 새로운 상태를 추가한다. 예를 들어 리조트로 가는 방향을 보여주는 뷰를 위한 상태를 추가한다던가.
  * 디자인 개선 - 창의성을 발휘하여 날씨 뷰의 표현을 개선시켜보자. 힌트를 얻기 위해 날씨 앱을 참고해보자.
  * 풍향을 위한 필터 구현 - 날씨 뷰에서 getDirection() 스코프 메소드를 풍향 값을 받아 문자열을 반환하는 필터로 교체해본다.
  * 날씨 데이터 캐싱 - 언제나 새로운 날씨 데이터를 요청하는 대신에 캐싱을 해 두고, 15분 이상 지난 상황일 때에만 새로 불러오도록 한다. 데이터 저장을 위해 localStorage를 사용하는 것을 고민해 보라.
  * 날씨 서비스 제작 - 이번 데모는 데이터 로딩을 위해 콘트롤러에서 $http를 사용했다. 콘트롤러가 $http를 직접 사용하지 않도록 날씨 데이터를 불러오는 AngularJS 서비스를 만들어 보라.

4.9 정리
이 장에서는 아이오닉 앱에서 네비게이션이 의미하는 바와 여러 가지 컴포넌트를 다루었다. 중요 주제들을 다시 복습해보자.
  * 아이오닉 앱은 상태라는 개념을 가지고 제작된다. 상태는 $stateProvider를 사용하여 config() 메소드 내부에서 선언된다.
  * 아이오닉은 상태가 변경될 때 ionNavView 컴포넌트의 내부로 템플릿을 불러온다.
  * ionNavBar 태그는 현재의 뷰에 선언된 제목으로 네비게이션 바를 업데이트 한다.
  * 목록과 카드 컴포넌트는 콘텐츠 목록을 모바일에서 보여주기에 적합한 방법이다.
  * 콘트롤러에서 $http 서비스를 이용하여 데이터를 불러올 수 있고, $ionicLoading 서비스는 로딩 인디케이터를 보여줄 때 사용한다.
  * ionSlideBox는 모바일 인터페이스 상의 슬라이드 쇼를 위한 컴포넌트이며, 이 장에서는 앱 소개를 위한 둘러보기에 사용되었다.
5장에서는 앱 네비게이션을 위한 탭 사용에 대해서 알아볼 것이다. 이와 함께 당겨서 새로 고침하기, 향상된 목록과 폼과 같은 다수의 아이오닉 기능도 함께 둘러볼 예정이다.
